<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UE ShaderParameter</title>
      <link href="/2025/04/24/UEShader%20Parameter/"/>
      <url>/2025/04/24/UEShader%20Parameter/</url>
      
        <content type="html"><![CDATA[<h1 id="UE-ShaderParameter"><a href="#UE-ShaderParameter" class="headerlink" title="UE ShaderParameter"></a>UE ShaderParameter</h1><p>UE的shader参数从声明，到被绑定到真正的shader中，是一条非常漫长但又环环相扣的流程，最近在看自定义meshpass的实现，正好看到这块，顺便整理记录下。</p><p>梳理的顺序将按照以下顺序来分析，前两节的内容不是本文的重点，所以这里会带过下大致的流程，不会展开分析。</p><ul><li>Shader信息收集&amp;编译</li><li>Shader参数的定义</li><li>Shader参数检查</li><li>Shader参数绑定</li><li>UE的多种Buffer设置原理（比如viewuniformbuffer，addpass</li></ul><span id="more"></span><h2 id="1-Shader信息收集-amp-编译"><a href="#1-Shader信息收集-amp-编译" class="headerlink" title="1. Shader信息收集&amp;编译"></a>1. Shader信息收集&amp;编译</h2><p>我们都知道，UE的Shader分为MaterialShader和GlobalShader，一个可以实例化，一个全局只有一份，这两种Shader的信息收集和定义大致相同，但是编译时机和存储方式不一样。</p><p>对于分散在各个文件中的Shader定义，会通过定义宏将FShderType收集到一个全局的变量中。在引擎初始化的时候会利用之前static变量收集的信息进行编译GlobalShader，把编译的结果存储在一个GGlobalShaderMap中。而对于MaterialShader，则是存储在每个Material对于的ShaderMap中。在用到对应的材质的时候，才会执行编译。</p><p>在编译完成后，会调用Shader宏中提供的构造函数指针，构造FShader。</p><h2 id="2-参数定义"><a href="#2-参数定义" class="headerlink" title="2. 参数定义"></a>2. 参数定义</h2><p>首先不得不提的一些宏： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_SHADER_PARAMETER_STRUCT </span><br><span class="line">SHADER_PARAMETER_STRUCT_REF </span><br><span class="line">BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT </span><br><span class="line">SHADER_PARAMETER ...</span><br></pre></td></tr></table></figure><p>我们一个个来看</p><p>一般一个简单的shader如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FLightGridCompactCS</span> : <span class="keyword">public</span> FGlobalShader</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">DECLARE_GLOBAL_SHADER</span>(FLightGridCompactCS)</span><br><span class="line">   <span class="built_in">SHADER_USE_PARAMETER_STRUCT</span>(FLightGridCompactCS, FGlobalShader)</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">BEGIN_SHADER_PARAMETER_STRUCT</span>(FParameters, )</span><br><span class="line">      <span class="built_in">SHADER_PARAMETER_STRUCT_REF</span>(FForwardLightData, Forward)</span><br><span class="line">      <span class="built_in">SHADER_PARAMETER_STRUCT_REF</span>(FViewUniformShaderParameters, View)</span><br><span class="line">      <span class="built_in">SHADER_PARAMETER_UAV</span>(RWBuffer&lt;uint&gt;, RWNumCulledLightsGrid)</span><br><span class="line">      <span class="built_in">SHADER_PARAMETER_UAV</span>(RWBuffer&lt;uint&gt;, RWCulledLightDataGrid)</span><br><span class="line">      <span class="built_in">SHADER_PARAMETER_RDG_BUFFER_UAV</span>(RWBuffer&lt;uint&gt;, RWNextCulledLightData)</span><br><span class="line">      <span class="built_in">SHADER_PARAMETER_RDG_BUFFER_SRV</span>(Buffer&lt;uint&gt;, StartOffsetGrid)</span><br><span class="line">      <span class="built_in">SHADER_PARAMETER_RDG_BUFFER_SRV</span>(Buffer&lt;uint&gt;, CulledLightLinks)</span><br><span class="line"></span><br><span class="line">   <span class="built_in">END_SHADER_PARAMETER_STRUCT</span>()</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">ShouldCompilePermutation</span><span class="params">(<span class="type">const</span> FGlobalShaderPermutationParameters&amp; Parameters)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">IsFeatureLevelSupported</span>(Parameters.Platform, ERHIFeatureLevel::SM5) || <span class="built_in">IsMobileDeferredShadingEnabled</span>(Parameters.Platform);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ModifyCompilationEnvironment</span><span class="params">(<span class="type">const</span> FGlobalShaderPermutationParameters&amp; Parameters, FShaderCompilerEnvironment&amp; OutEnvironment)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      FGlobalShader::<span class="built_in">ModifyCompilationEnvironment</span>(Parameters, OutEnvironment);</span><br><span class="line">      OutEnvironment.<span class="built_in">SetDefine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;THREADGROUP_SIZE&quot;</span>), LightGridInjectionGroupSize);</span><br><span class="line">      FForwardLightingParameters::<span class="built_in">ModifyCompilationEnvironment</span>(Parameters.Platform, OutEnvironment);</span><br><span class="line">      OutEnvironment.<span class="built_in">SetDefine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;LIGHT_LINK_STRIDE&quot;</span>), LightLinkStride);</span><br><span class="line">      OutEnvironment.<span class="built_in">SetDefine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MAX_CAPTURES&quot;</span>), GMaxNumReflectionCaptures);</span><br><span class="line">      OutEnvironment.<span class="built_in">SetDefine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;ENABLE_LIGHT_CULLING_VIEW_SPACE_BUILD_DATA&quot;</span>), ENABLE_LIGHT_CULLING_VIEW_SPACE_BUILD_DATA);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在分析宏之前，首先要明确，我们声明的shader参数分为两种：</p><ol><li>全局参数</li><li>局部参数</li></ol><p>这两者的区别就是，局部参数只能在当前shader使用，而全局参数可以被任何一个shader使用，无需在usf里再去声明，而在shader中声明的参数，可以两种类型混着来。</p><h3 id="shader参数宏分析"><a href="#shader参数宏分析" class="headerlink" title="shader参数宏分析"></a>shader参数宏分析</h3><h3 id="2-1-BEGIN-SHADER-PARAMETER-STRUCT"><a href="#2-1-BEGIN-SHADER-PARAMETER-STRUCT" class="headerlink" title="2.1 BEGIN_SHADER_PARAMETER_STRUCT"></a>2.1 BEGIN_SHADER_PARAMETER_STRUCT</h3><p>这是一组宏，可以在中间声明各种类型/结构的shader参数。</p><h4 id="第一层Define"><a href="#第一层Define" class="headerlink" title="第一层Define:"></a>第一层Define:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Begins &amp; ends a shader parameter structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * BEGIN_SHADER_PARAMETER_STRUCT(FMyParameterStruct, RENDERER_API)</span></span><br><span class="line"><span class="comment"> * END_SHADER_PARAMETER_STRUCT()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEGIN_SHADER_PARAMETER_STRUCT(StructTypeName, PrefixKeywords) \</span></span><br><span class="line"><span class="meta">   INTERNAL_SHADER_PARAMETER_STRUCT_BEGIN(StructTypeName, PrefixKeywords, &#123;&#125;, INTERNAL_SHADER_PARAMETER_GET_STRUCT_METADATA(StructTypeName), INTERNAL_SHADER_PARAMETER_STRUCT_CREATE_UNIFORM_BUFFER)</span></span><br></pre></td></tr></table></figure><p>这里的StructTypeName就是FParameters，Prefixkeywords是空，宏里套宏，经典操作。</p><h4 id="第二层Define"><a href="#第二层Define" class="headerlink" title="第二层Define"></a>第二层Define</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Begins a uniform buffer struct declaration. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERNAL_SHADER_PARAMETER_STRUCT_BEGIN(StructTypeName,PrefixKeywords,ConstructorSuffix,GetStructMetadataScope,CreateUniformBufferImpl) \</span></span><br><span class="line"><span class="meta">   MS_ALIGN(SHADER_PARAMETER_STRUCT_ALIGNMENT) class PrefixKeywords StructTypeName \</span></span><br><span class="line"><span class="meta">   &#123; \</span></span><br><span class="line"><span class="meta">   public: \</span></span><br><span class="line"><span class="meta">      StructTypeName () ConstructorSuffix \</span></span><br><span class="line"><span class="meta">      struct FTypeInfo &#123; \</span></span><br><span class="line"><span class="meta">         static constexpr int32 NumRows = 1; \</span></span><br><span class="line"><span class="meta">         static constexpr int32 NumColumns = 1; \</span></span><br><span class="line"><span class="meta">         static constexpr int32 NumElements = 0; \</span></span><br><span class="line"><span class="meta">         static constexpr int32 Alignment = SHADER_PARAMETER_STRUCT_ALIGNMENT; \</span></span><br><span class="line"><span class="meta">         static constexpr bool bIsStoredInConstantBuffer = true; \</span></span><br><span class="line"><span class="meta">         using TAlignedType = StructTypeName; \</span></span><br><span class="line"><span class="meta">         static inline const FShaderParametersMetadata* GetStructMetadata() &#123; GetStructMetadataScope &#125; \</span></span><br><span class="line"><span class="meta">      &#125;; \</span></span><br><span class="line"><span class="meta">      static FUniformBufferRHIRef CreateUniformBuffer(const StructTypeName&amp; InContents, EUniformBufferUsage InUsage) \</span></span><br><span class="line"><span class="meta">      &#123; \</span></span><br><span class="line"><span class="meta">         CreateUniformBufferImpl \</span></span><br><span class="line"><span class="meta">      &#125; \</span></span><br><span class="line"><span class="meta">   private: \</span></span><br><span class="line"><span class="meta">      typedef StructTypeName zzTThisStruct; \</span></span><br><span class="line"><span class="meta">      struct zzFirstMemberId &#123; enum &#123; HasDeclaredResource = 0 &#125;; &#125;; \</span></span><br><span class="line"><span class="meta">      typedef void* zzFuncPtr; \</span></span><br><span class="line"><span class="meta">      typedef zzFuncPtr(*zzMemberFunc)(zzFirstMemberId, TArray<span class="string">&lt;FShaderParametersMetadata::FMember&gt;</span>*); \</span></span><br><span class="line"><span class="meta">      static zzFuncPtr zzAppendMemberGetPrev(zzFirstMemberId, TArray<span class="string">&lt;FShaderParametersMetadata::FMember&gt;</span>*) \</span></span><br><span class="line"><span class="meta">      &#123; \</span></span><br><span class="line"><span class="meta">         return nullptr; \</span></span><br><span class="line"><span class="meta">      &#125; \</span></span><br><span class="line"><span class="meta">      typedef zzFirstMemberId</span></span><br></pre></td></tr></table></figure><p>这里传进来的StructTypeName还是FParameters，第二，三个参数是空，第四五个参数是由宏生成的，可以跳转这里<a href="https://lilithgames.feishu.cn/docx/LXyBdl7MSoDd28xGUK2cgcZRnMg#BmhAdsdmBoRyCZxsFUncfejCnEd">UE4 shader参数</a> </p><p>第三行声明了一个FParameters类，后面都是这个类的成员变量和宏：</p><p>第六行声明了一个构造函数。</p><p>第七行声明了一个FTypeInfo的结构体。</p><p>第14行声明了一个函数，返回元数据：实现就是第四个参数。</p><p>第16行声明了一个创建uniformbuffer的接口，实现就是第五个参数。</p><p>第21-&gt;28行其实就是声明了一个函数指针：zzMemberFunc，一个函数zzAppendMemberGetPrev</p><p><strong>最后这里留了一个typedef，但没指定typedef的对象，对应这里</strong></p><p><strong>总结起来，BEGIN_SHADER_PARAMETER_STRUCT主要就是声明了FParameters这个类，然后声明了这个类的一些类型信息的成员。</strong></p><h4 id="第四个参数"><a href="#第四个参数" class="headerlink" title="第四个参数"></a>第四个参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTERNAL_SHADER_PARAMETER_GET_STRUCT_METADATA(StructTypeName) \</span></span><br><span class="line"><span class="meta">   static FShaderParametersMetadata StaticStructMetadata(\</span></span><br><span class="line"><span class="meta">      FShaderParametersMetadata::EUseCase::ShaderParameterStruct, \</span></span><br><span class="line"><span class="meta">      TEXT(#StructTypeName), \</span></span><br><span class="line"><span class="meta">      TEXT(#StructTypeName), \</span></span><br><span class="line"><span class="meta">      nullptr, \</span></span><br><span class="line"><span class="meta">      nullptr, \</span></span><br><span class="line"><span class="meta">      sizeof(StructTypeName), \</span></span><br><span class="line"><span class="meta">      StructTypeName::zzGetMembers()); \</span></span><br><span class="line"><span class="meta">   return &amp;StaticStructMetadata;</span></span><br></pre></td></tr></table></figure><p>可以看出来这里其实只是声明了一个静态变量FShaderParametersMetadata ，把这个变量返回了。</p><h4 id="第五个参数"><a href="#第五个参数" class="headerlink" title="第五个参数"></a>第五个参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTERNAL_SHADER_PARAMETER_STRUCT_CREATE_UNIFORM_BUFFER return nullptr;</span></span><br></pre></td></tr></table></figure><p>只是返回一个空指针</p><h3 id="2-2-SHADER-PARAMETER"><a href="#2-2-SHADER-PARAMETER" class="headerlink" title="2.2 SHADER_PARAMETER"></a>2.2 SHADER_PARAMETER</h3><p>Begin和End之间可以插入任意类型的shader参数，先分析一个最简单的，SHADER_PARAMETER主要是用来声明一个基础类型的shader参数</p><h4 id="第一层define"><a href="#第一层define" class="headerlink" title="第一层define"></a>第一层define</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_PARAMETER(MemberType,MemberName) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER_EX(MemberType,MemberName,EShaderPrecisionModifier::Float)</span></span><br></pre></td></tr></table></figure><h4 id="第二层define"><a href="#第二层define" class="headerlink" title="第二层define"></a>第二层define</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_PARAMETER_EX(MemberType,MemberName,Precision) \</span></span><br><span class="line"><span class="meta">   INTERNAL_SHADER_PARAMETER_EXPLICIT(TShaderParameterTypeInfo<span class="string">&lt;MemberType&gt;</span>::BaseType, TShaderPa</span></span><br><span class="line">   rameterTypeInfo&lt;MemberType&gt;, MemberType,MemberName,,,Precision,<span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>),<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>首先看第一个参数：TShaderParameterTypeInfo<MemberType>::BaseType 我们用Bool值举例：</MemberType></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compile SHADER_PARAMETER(bool, MyBool), just to give good error message to programmer why they shouldn&#x27;t do that.</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TShaderParameterTypeInfo</span>&lt;<span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">static</span> <span class="keyword">constexpr</span> EUniformBufferBaseType BaseType = UBMT_BOOL;</span><br><span class="line">   <span class="type">static</span> <span class="keyword">constexpr</span> int32 NumRows = <span class="number">1</span>;</span><br><span class="line">   <span class="type">static</span> <span class="keyword">constexpr</span> int32 NumColumns = <span class="number">1</span>;</span><br><span class="line">   <span class="type">static</span> <span class="keyword">constexpr</span> int32 NumElements = <span class="number">0</span>;</span><br><span class="line">   <span class="type">static</span> <span class="keyword">constexpr</span> int32 Alignment = <span class="number">4</span>;</span><br><span class="line">   <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> bIsStoredInConstantBuffer = <span class="literal">true</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">using</span> TAlignedType = TAlignedTypedef&lt;<span class="type">bool</span>, Alignment&gt;::Type;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">const</span> FShaderParametersMetadata* <span class="title">GetStructMetadata</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的第一个参数其实就是定义类型的一个枚举值:enum EUniformBufferBaseType : uint8</p><p>第二个参数是TShaderParameterTypeInfo<MemberType>类本身，后面几个参数都比较简单了。</MemberType></p><h4 id="第三层define"><a href="#第三层define" class="headerlink" title="第三层define"></a>第三层define</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Declares a member of a uniform buffer struct. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERNAL_SHADER_PARAMETER_EXPLICIT(BaseType,TypeInfo,MemberType,MemberName,ArrayDecl,DefaultValue,Precision,OptionalShaderType,IsMemberStruct) \</span></span><br><span class="line"><span class="meta">      zzMemberId##MemberName; \</span></span><br><span class="line"><span class="meta">   public: \</span></span><br><span class="line"><span class="meta">      TypeInfo::TAlignedType MemberName DefaultValue; \</span></span><br><span class="line"><span class="meta">      static_assert(BaseType != UBMT_INVALID, <span class="string">&quot;Invalid type &quot;</span> #MemberType <span class="string">&quot; of member &quot;</span> #MemberName <span class="string">&quot;.&quot;</span>); \</span></span><br><span class="line"><span class="meta">   private: \</span></span><br><span class="line"><span class="meta">      struct zzNextMemberId##MemberName &#123; enum &#123; HasDeclaredResource = zzMemberId##MemberName::HasDeclaredResource || !TypeInfo::bIsStoredInConstantBuffer &#125;; &#125;; \</span></span><br><span class="line"><span class="meta">      static zzFuncPtr zzAppendMemberGetPrev(zzNextMemberId##MemberName, TArray<span class="string">&lt;FShaderParametersMetadata::FMember&gt;</span>* Members) \</span></span><br><span class="line"><span class="meta">      &#123; \</span></span><br><span class="line"><span class="meta">         static_assert(TypeInfo::bIsStoredInConstantBuffer || TIsArrayOrRefOfType<span class="string">&lt;decltype(OptionalShaderType), TCHAR&gt;</span>::Value, <span class="string">&quot;No shader type for &quot;</span> #MemberName <span class="string">&quot;.&quot;</span>); \</span></span><br><span class="line"><span class="meta">         static_assert(\</span></span><br><span class="line"><span class="meta">            (STRUCT_OFFSET(zzTThisStruct, MemberName) &amp; (TypeInfo::Alignment - 1)) == 0, \</span></span><br><span class="line"><span class="meta">            <span class="string">&quot;Misaligned uniform buffer struct member &quot;</span> #MemberName <span class="string">&quot;.&quot;</span>); \</span></span><br><span class="line"><span class="meta">         Members-&gt;Add(FShaderParametersMetadata::FMember( \</span></span><br><span class="line"><span class="meta">            TEXT(#MemberName), \</span></span><br><span class="line"><span class="meta">            OptionalShaderType, \</span></span><br><span class="line"><span class="meta">            STRUCT_OFFSET(zzTThisStruct,MemberName), \</span></span><br><span class="line"><span class="meta">            EUniformBufferBaseType(BaseType), \</span></span><br><span class="line"><span class="meta">            Precision, \</span></span><br><span class="line"><span class="meta">            TypeInfo::NumRows, \</span></span><br><span class="line"><span class="meta">            TypeInfo::NumColumns, \</span></span><br><span class="line"><span class="meta">            TypeInfo::NumElements, \</span></span><br><span class="line"><span class="meta">            TypeInfo::GetStructMetadata() \</span></span><br><span class="line"><span class="meta">            )); \</span></span><br><span class="line"><span class="meta">         zzFuncPtr(*PrevFunc)(zzMemberId##MemberName, TArray<span class="string">&lt;FShaderParametersMetadata::FMember&gt;</span>*); \</span></span><br><span class="line"><span class="meta">         PrevFunc = zzAppendMemberGetPrev; \</span></span><br><span class="line"><span class="meta">         return (zzFuncPtr)PrevFunc; \</span></span><br><span class="line"><span class="meta">      &#125; \</span></span><br><span class="line"><span class="meta">      typedef zzNextMemberId##MemberName</span></span><br></pre></td></tr></table></figure><p>这里上来就写zzMemberId##MemberName; <strong>承接了上面的typedef</strong></p><p>合起来就是：typedef zzFirstMemberId zzMemberId##MemberName;</p><p>看到这里也能猜到了，每个ShaderParameter之间都是靠这样的形式来把前后的参数链起来：具体做法是：</p><p>Begin宏定义了一个<strong>结构体</strong>：</p><p> struct zzFirstMemberId { enum { HasDeclaredResource = 0 }; }; </p><p>第一个shader参数承接上文：声明了第一个<strong>结构体的变量</strong>：zzMemberId##MemberName</p><p>接着定义第二个结构体：</p><p>struct zzNextMemberId##MemberName { enum { HasDeclaredResource = zzMemberId##MemberName::HasDeclaredResource || !TypeInfo::bIsStoredInConstantBuffer }; };</p><p>第二个结构体里的枚举值就是第一个结构体里的枚举值。（可能有点绕）</p><p>依此类推。zzAppendMemberGetPrev定义一个静态函数。</p><p>这个静态函数做了两件事：</p><ol><li>首先把当前的membe添加到TArray<FShaderParametersMetadata::FMember>* Members里去</FShaderParametersMetadata::FMember></li><li>返回上一个成员的zzAppendMemberGetPrev函数（他们通过参数不同重载实现）</li></ol><h3 id="2-3-END-SHADER-PARAMETER-STRUCT-宏"><a href="#2-3-END-SHADER-PARAMETER-STRUCT-宏" class="headerlink" title="2.3.END_SHADER_PARAMETER_STRUCT 宏"></a>2.3.END_SHADER_PARAMETER_STRUCT 宏</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> END_SHADER_PARAMETER_STRUCT() \</span></span><br><span class="line"><span class="meta">      zzLastMemberId; \</span></span><br><span class="line"><span class="meta">   public: \</span></span><br><span class="line"><span class="meta">      static TArray<span class="string">&lt;FShaderParametersMetadata::FMember&gt;</span> zzGetMembers() &#123; \</span></span><br><span class="line"><span class="meta">         TArray<span class="string">&lt;FShaderParametersMetadata::FMember&gt;</span> Members; \</span></span><br><span class="line"><span class="meta">         zzFuncPtr(*LastFunc)(zzLastMemberId, TArray<span class="string">&lt;FShaderParametersMetadata::FMember&gt;</span>*); \</span></span><br><span class="line"><span class="meta">         LastFunc = zzAppendMemberGetPrev; \</span></span><br><span class="line"><span class="meta">         zzFuncPtr Ptr = (zzFuncPtr)LastFunc; \</span></span><br><span class="line"><span class="meta">         do \</span></span><br><span class="line"><span class="meta">         &#123; \</span></span><br><span class="line"><span class="meta">            Ptr = reinterpret_cast<span class="string">&lt;zzMemberFunc&gt;</span>(Ptr)(zzFirstMemberId(), &amp;Members); \</span></span><br><span class="line"><span class="meta">         &#125; while (Ptr); \</span></span><br><span class="line"><span class="meta">         Algo::Reverse(Members); \</span></span><br><span class="line"><span class="meta">         return Members; \</span></span><br><span class="line"><span class="meta">      &#125; \</span></span><br><span class="line"><span class="meta">   &#125; GCC_ALIGN(SHADER_PARAMETER_STRUCT_ALIGNMENT);</span></span><br></pre></td></tr></table></figure><p>End宏主要做了两件事</p><ol><li>承接上面的typedef</li><li>定义了一个静态函数，这个函数会依次执行上面的链路接口zzAppendMemberGetPrev，把shader参数都添加进Members变量中，最终返回Members数组。</li></ol><h3 id="2-4-SHADER-USE-PARAMETER-STRUCT"><a href="#2-4-SHADER-USE-PARAMETER-STRUCT" class="headerlink" title="2.4 SHADER_USE_PARAMETER_STRUCT"></a>2.4 SHADER_USE_PARAMETER_STRUCT</h3><h4 id="第一层define-1"><a href="#第一层define-1" class="headerlink" title="第一层define"></a>第一层define</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_USE_PARAMETER_STRUCT(ShaderClass, ShaderParentClass) \</span></span><br><span class="line"><span class="meta">   SHADER_USE_PARAMETER_STRUCT_INTERNAL(ShaderClass, ShaderParentClass, true) \</span></span><br><span class="line"><span class="meta">   \</span></span><br><span class="line"><span class="meta">   static inline const FShaderParametersMetadata* GetRootParametersMetadata() &#123; return FParameters::FTypeInfo::GetStructMetadata(); &#125;</span></span><br></pre></td></tr></table></figure><h4 id="第二层define-1"><a href="#第二层define-1" class="headerlink" title="第二层define"></a>第二层define</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_USE_PARAMETER_STRUCT_INTERNAL(ShaderClass, ShaderParentClass, bShouldBindEverything) \</span></span><br><span class="line"><span class="meta">   ShaderClass(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer) \</span></span><br><span class="line"><span class="meta">      : ShaderParentClass(Initializer) \</span></span><br><span class="line"><span class="meta">   &#123; \</span></span><br><span class="line"><span class="meta">      BindForLegacyShaderParameters<span class="string">&lt;FParameters&gt;</span>(this, Initializer.PermutationId, Initializer.ParameterMap, bShouldBindEverything); \</span></span><br><span class="line"><span class="meta">   &#125; \</span></span><br><span class="line"><span class="meta">   \</span></span><br><span class="line"><span class="meta">   ShaderClass() \</span></span><br><span class="line"><span class="meta">   &#123; &#125; \</span></span><br></pre></td></tr></table></figure><p>这里其实就是定义了一个构造函数，调用了BindForLegacyShaderParameters。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FParameterStruct&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BindForLegacyShaderParameters</span><span class="params">(FShader* Shader, int32 PermutationId, <span class="type">const</span> FShaderParameterMap&amp; ParameterMap, <span class="type">bool</span> bShouldBindEverything = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Shader-&gt;Bindings.<span class="built_in">BindForLegacyShaderParameters</span>(Shader, PermutationId, ParameterMap, *FParameterStruct::FTypeInfo::<span class="built_in">GetStructMetadata</span>(), bShouldBindEverything);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到BindForLegacyShaderParameters以<strong>FParameters的GetStructMetadata</strong>为参数。</p><p>这个接口是不是很眼熟呢，定义的地方就是Begin宏的第四个参数里，而GetStructMetada的构造函数中，又包含了StructTypeName::zzGetMembers()。这样通过</p><p><strong>SHADER_USE_PARAMETER_STRUCT-&gt;GetStructMetadata-&gt;zzGetMembers</strong> 的传递关系，最终把所有shader参数的信息都拿到了！BindForLegacyShaderParameters的使用我们放到第三节讲。</p><h3 id="2-5-SHADER-PARAMETER-STRUCT-REF"><a href="#2-5-SHADER-PARAMETER-STRUCT-REF" class="headerlink" title="2.5 SHADER_PARAMETER_STRUCT_REF"></a>2.5 SHADER_PARAMETER_STRUCT_REF</h3><p>其他的Shader宏都大同小异，无非是模板参数不同，指向的资源不同，之所以再分析下这个宏是因为大部分shader参数都能在usf文件中找到对应的声明，但是这个宏声明的参数没找到，好奇心驱使看一下这个宏：</p><p>这个是个引用shader参数，代表它实际上的声明并不在这里。比如第一节提到的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SHADER_PARAMETER_STRUCT_REF</span>(FForwardLightData, Forward)</span><br></pre></td></tr></table></figure><p>变量声明实际为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FORWARD_GLOBAL_LIGHT_DATA_UNIFORM_BUFFER_MEMBER_TABLE \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(uint32,NumLocalLights) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(uint32, NumReflectionCaptures) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(uint32, HasDirectionalLight) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(uint32, NumGridCells) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(FIntVector, CulledGridSize) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(uint32, MaxCulledLightsPerCell) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(uint32, LightGridPixelSizeShift) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(FVector, LightGridZParams) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(FVector, DirectionalLightDirection) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(FVector, DirectionalLightColor) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(float, DirectionalLightVolumetricScatteringIntensity) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(uint32, DirectionalLightShadowMapChannelMask) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(FVector2D, DirectionalLightDistanceFadeMAD) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(uint32, NumDirectionalLightCascades) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(FVector4, CascadeEndDepths) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER_ARRAY(FMatrix, DirectionalLightWorldToShadowMatrix, [GMaxForwardShadowCascades]) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER_ARRAY(FVector4, DirectionalLightShadowmapMinMax, [GMaxForwardShadowCascades]) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(FVector4, DirectionalLightShadowmapAtlasBufferSize) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(float, DirectionalLightDepthBias) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(uint32, DirectionalLightUseStaticShadowing) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(uint32, SimpleLightsEndIndex) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(uint32, ClusteredDeferredSupportedEndIndex) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(FVector4, DirectionalLightStaticShadowBufferSize) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER(FMatrix, DirectionalLightWorldToStaticShadow) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER_TEXTURE(Texture2D, DirectionalLightShadowmapAtlas) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER_SAMPLER(SamplerState, ShadowmapSampler) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER_TEXTURE(Texture2D, DirectionalLightStaticShadowmap) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER_SAMPLER(SamplerState, StaticShadowmapSampler) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER_SRV(StrongTypedBuffer<span class="string">&lt;float4&gt;</span>, ForwardLocalLightBuffer) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER_SRV(StrongTypedBuffer<span class="string">&lt;uint&gt;</span>, NumCulledLightsGrid) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER_SRV(StrongTypedBuffer<span class="string">&lt;uint&gt;</span>, CulledLightDataGrid) \</span></span><br><span class="line"><span class="meta">   SHADER_PARAMETER_TEXTURE(Texture2D, DummyRectLightSourceTexture)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT_WITH_CONSTRUCTOR</span>(FForwardLightData,)</span><br><span class="line">   <span class="function">FORWARD_GLOBAL_LIGHT_DATA_UNIFORM_BUFFER_MEMBER_TABLE</span></span><br><span class="line"><span class="function"><span class="title">END_GLOBAL_SHADER_PARAMETER_STRUCT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">IMPLEMENT_GLOBAL_SHADER_PARAMETER_STRUCT</span><span class="params">(FForwardLightData, <span class="string">&quot;ForwardLightData&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这里的宏结构展开和上面分析的差不多，区别是IMPLEMENT_GLOBAL_SHADER_PARAMETER_STRUCT会声明一个全局的静态变量，在Main函数之前初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMPLEMENT_UNIFORM_BUFFER_STRUCT(StructTypeName,ShaderVariableName) \</span></span><br><span class="line"><span class="meta">   FShaderParametersMetadata StructTypeName::StaticStructMetadata( \</span></span><br><span class="line"><span class="meta">   FShaderParametersMetadata::EUseCase::UniformBuffer, \</span></span><br><span class="line"><span class="meta">   TEXT(#StructTypeName), \</span></span><br><span class="line"><span class="meta">   TEXT(#StructTypeName), \</span></span><br><span class="line"><span class="meta">   TEXT(ShaderVariableName), \</span></span><br><span class="line"><span class="meta">   nullptr, \</span></span><br><span class="line"><span class="meta">   sizeof(StructTypeName), \</span></span><br><span class="line"><span class="meta">   StructTypeName::zzGetMembers())</span></span><br></pre></td></tr></table></figure><p>初始化的时候会调用到上面分析过的zzGetMembers函数，把shader参数信息全部收集起来，然后调用FShaderParametersMetadata的构造函数</p><p><img src="https://lilithgames.feishu.cn/space/api/box/stream/download/asynccode/?code=NTIxYzdjZTJjMjJmNjM1OWU3ZTczZGIxYThhMTg3MGFfMmRheHhHYmRGSFpZVFZZTWFkckR1TUJiUTdpOTQyQ0ZfVG9rZW46UkluMWJZa3RXb0xjUnR4cjhkaWNuT1ZCbnZjXzE3NDU0ODI1NzM6MTc0NTQ4NjE3M19WNA" alt="img"></p><p>如果是uniformbuffer数据的话，然后把FShaderParametersMetadata链到全局的一个链表上去。</p><h2 id="3-参数代码检查"><a href="#3-参数代码检查" class="headerlink" title="3.参数代码检查"></a>3.参数代码检查</h2><p>在shader编译完成后，会调用Shader的构造函数，做两件事</p><ul><li>调用父类的构造</li><li>调用BindForLegacyShaderParameters</li></ul><p>Shader需要的参数会被存储在编译结果FShaderCompilerOutput::ParameterMap，这样在构造函数中，就可以做绑定。对于没有定义SHADER_USE_PARAMETER_STRUCT宏的Shader，需要手动声明构造函数，这些Shader有的会手动做参数的绑定，这里的绑定只是做了代码检查，即C++侧的参数，是否真的在Shader中被定义了，如果存在就把ParameterMap中对应的ParameterMap的bBound设为true，方便在后续真正传参。以MobileBasePassPS举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">TMobileBasePassPSPolicyParamType</span>(<span class="type">const</span> FMeshMaterialShaderType::CompiledShaderInitializerType&amp; Initializer)</span><br><span class="line">    : <span class="built_in">FMeshMaterialShader</span>(Initializer)</span><br><span class="line">&#123;</span><br><span class="line">    LightMapPolicyType::PixelParametersType::<span class="built_in">Bind</span>(Initializer.ParameterMap);</span><br><span class="line">    PassUniformBuffer.<span class="built_in">Bind</span>(Initializer.ParameterMap, FMobileBasePassUniformParameters::StaticStructMetadata.<span class="built_in">GetShaderVariableName</span>());</span><br><span class="line">    </span><br><span class="line">    MobileDirectionLightBufferParam.<span class="built_in">Bind</span>(Initializer.ParameterMap, FMobileDirectionalLightShaderParameters::StaticStructMetadata.<span class="built_in">GetShaderVariableName</span>());</span><br><span class="line">    ReflectionParameter.<span class="built_in">Bind</span>(Initializer.ParameterMap, FMobileReflectionCaptureShaderParameters::StaticStructMetadata.<span class="built_in">GetShaderVariableName</span>());</span><br><span class="line"></span><br><span class="line">    HQReflectionCubemaps[<span class="number">0</span>].<span class="built_in">Bind</span>(Initializer.ParameterMap, <span class="built_in">TEXT</span>(<span class="string">&quot;ReflectionCubemap0&quot;</span>));</span><br><span class="line">    HQReflectionSamplers[<span class="number">0</span>].<span class="built_in">Bind</span>(Initializer.ParameterMap, <span class="built_in">TEXT</span>(<span class="string">&quot;ReflectionCubemapSampler0&quot;</span>));</span><br><span class="line">    HQReflectionCubemaps[<span class="number">1</span>].<span class="built_in">Bind</span>(Initializer.ParameterMap, <span class="built_in">TEXT</span>(<span class="string">&quot;ReflectionCubemap1&quot;</span>));</span><br><span class="line">    HQReflectionSamplers[<span class="number">1</span>].<span class="built_in">Bind</span>(Initializer.ParameterMap, <span class="built_in">TEXT</span>(<span class="string">&quot;ReflectionCubemapSampler1&quot;</span>));</span><br><span class="line">    HQReflectionCubemaps[<span class="number">2</span>].<span class="built_in">Bind</span>(Initializer.ParameterMap, <span class="built_in">TEXT</span>(<span class="string">&quot;ReflectionCubemap2&quot;</span>));</span><br><span class="line">    HQReflectionSamplers[<span class="number">2</span>].<span class="built_in">Bind</span>(Initializer.ParameterMap, <span class="built_in">TEXT</span>(<span class="string">&quot;ReflectionCubemapSampler2&quot;</span>));</span><br><span class="line">    HQReflectionInvAverageBrigtnessParams.<span class="built_in">Bind</span>(Initializer.ParameterMap, <span class="built_in">TEXT</span>(<span class="string">&quot;ReflectionAverageBrigtness&quot;</span>));</span><br><span class="line">    HQReflectanceMaxValueRGBMParams.<span class="built_in">Bind</span>(Initializer.ParameterMap, <span class="built_in">TEXT</span>(<span class="string">&quot;ReflectanceMaxValueRGBM&quot;</span>));</span><br><span class="line">    HQReflectionPositionsAndRadii.<span class="built_in">Bind</span>(Initializer.ParameterMap, <span class="built_in">TEXT</span>(<span class="string">&quot;ReflectionPositionsAndRadii&quot;</span>));</span><br><span class="line">    HQReflectionCaptureBoxTransformArray.<span class="built_in">Bind</span>(Initializer.ParameterMap, <span class="built_in">TEXT</span>(<span class="string">&quot;CaptureBoxTransformArray&quot;</span>));</span><br><span class="line">    HQReflectionCaptureBoxScalesArray.<span class="built_in">Bind</span>(Initializer.ParameterMap, <span class="built_in">TEXT</span>(<span class="string">&quot;CaptureBoxScalesArray&quot;</span>));</span><br><span class="line"></span><br><span class="line">    NumDynamicPointLightsParameter.<span class="built_in">Bind</span>(Initializer.ParameterMap, <span class="built_in">TEXT</span>(<span class="string">&quot;NumDynamicPointLights&quot;</span>));</span><br><span class="line">                </span><br><span class="line">    CSMDebugHintParams.<span class="built_in">Bind</span>(Initializer.ParameterMap, <span class="built_in">TEXT</span>(<span class="string">&quot;CSMDebugHint&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FShaderUniformBufferParameter::Bind</span><span class="params">(<span class="type">const</span> FShaderParameterMap&amp; ParameterMap,<span class="type">const</span> TCHAR* ParameterName,EShaderParameterFlags Flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint16 UnusedBaseIndex = <span class="number">0</span>;</span><br><span class="line">uint16 UnusedNumBytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!ParameterMap.<span class="built_in">FindParameterAllocation</span>(ParameterName,BaseIndex,UnusedBaseIndex,UnusedNumBytes))<span class="comment">//设置bBound</span></span><br><span class="line">&#123;</span><br><span class="line">BaseIndex = <span class="number">0xffff</span>;</span><br><span class="line"><span class="keyword">if</span>(Flags == SPF_Mandatory)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">UE_LOG_ACTIVE</span>(LogShaders, Log))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogShaders, Fatal,<span class="built_in">TEXT</span>(<span class="string">&quot;Failure to bind non-optional shader resource parameter %s!  The parameter is either not present in the shader, or the shader compiler optimized it out.&quot;</span>),ParameterName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// We use a non-Slate message box to avoid problem where we haven&#x27;t compiled the shaders for Slate.</span></span><br><span class="line">FPlatformMisc::<span class="built_in">MessageBoxExt</span>( EAppMsgType::Ok, *FText::<span class="built_in">Format</span>(</span><br><span class="line"><span class="built_in">NSLOCTEXT</span>(<span class="string">&quot;UnrealEd&quot;</span>, <span class="string">&quot;Error_FailedToBindShaderParameter&quot;</span>, <span class="string">&quot;Failure to bind non-optional shader parameter &#123;0&#125;! The parameter is either not present in the shader, or the shader compiler optimized it out. This will be an assert with LogShaders suppressed!&quot;</span>),</span><br><span class="line">FText::<span class="built_in">FromString</span>(ParameterName)).<span class="built_in">ToString</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;Warning&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">check</span>(<span class="built_in">IsBound</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于声明了宏的函数，就不需要那么麻烦，会在构造函数中直接调用BindForLegacyShaderParameters接下来我们看下Bind的是怎么用MetaData的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FShaderParameterBindings::BindForLegacyShaderParameters</span><span class="params">(<span class="type">const</span> FShader* Shader, int32 PermutationId, <span class="type">const</span> FShaderParameterMap&amp; ParametersMap, <span class="type">const</span> FShaderParametersMetadata&amp; StructMetaData, <span class="type">bool</span> bShouldBindEverything)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">const</span> FShaderType* Type = Shader-&gt;<span class="built_in">GetTypeUnfrozen</span>();</span><br><span class="line">   <span class="built_in">checkf</span>(StructMetaData.<span class="built_in">GetSize</span>() &lt; (<span class="number">1</span> &lt;&lt; (<span class="built_in">sizeof</span>(uint16) * <span class="number">8</span>)), <span class="built_in">TEXT</span>(<span class="string">&quot;Shader parameter structure can only have a size &lt; 65536 bytes.&quot;</span>));</span><br><span class="line">   <span class="built_in">check</span>(<span class="keyword">this</span> == &amp;Shader-&gt;Bindings);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">switch</span> (Type-&gt;<span class="built_in">GetFrequency</span>())</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">case</span> SF_Vertex:</span><br><span class="line">   <span class="keyword">case</span> SF_Hull:</span><br><span class="line">   <span class="keyword">case</span> SF_Domain:</span><br><span class="line">   <span class="keyword">case</span> SF_Pixel:</span><br><span class="line">   <span class="keyword">case</span> SF_Geometry:</span><br><span class="line">   <span class="keyword">case</span> SF_Compute:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">checkf</span>(<span class="number">0</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Invalid shader frequency for this shader binding technique.&quot;</span>));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   FShaderParameterStructBindingContext BindingContext;</span><br><span class="line">   BindingContext.Shader = Shader;</span><br><span class="line">   BindingContext.PermutationId = PermutationId;</span><br><span class="line">   BindingContext.Bindings = <span class="keyword">this</span>;</span><br><span class="line">   BindingContext.ParametersMap = &amp;ParametersMap;</span><br><span class="line">   BindingContext.bUseRootShaderParameters = <span class="literal">false</span>;</span><br><span class="line">   BindingContext.<span class="built_in">Bind</span>(</span><br><span class="line">      StructMetaData,</span><br><span class="line">      <span class="comment">/* MemberPrefix = */</span> <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>),</span><br><span class="line">      <span class="comment">/* ByteOffset = */</span> <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   StructureLayoutHash = StructMetaData.<span class="built_in">GetLayoutHash</span>();</span><br><span class="line">   RootParameterBufferIndex = kInvalidBufferIndex;</span><br><span class="line"></span><br><span class="line">   TArray&lt;FString&gt; AllParameterNames;</span><br><span class="line">   ParametersMap.<span class="built_in">GetAllParameterNames</span>(AllParameterNames);</span><br><span class="line">   <span class="keyword">if</span> (bShouldBindEverything &amp;&amp; BindingContext.ShaderGlobalScopeBindings.<span class="built_in">Num</span>() != AllParameterNames.<span class="built_in">Num</span>())</span><br><span class="line">   &#123;</span><br><span class="line">      FString ErrorString = FString::<span class="built_in">Printf</span>(</span><br><span class="line">         <span class="built_in">TEXT</span>(<span class="string">&quot;Shader %s, permutation %d has unbound parameters not represented in the parameter struct:&quot;</span>), Type-&gt;<span class="built_in">GetName</span>(), PermutationId);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> FString&amp; GlobalParameterName : AllParameterNames)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span> (!BindingContext.ShaderGlobalScopeBindings.<span class="built_in">Contains</span>(GlobalParameterName))</span><br><span class="line">         &#123;</span><br><span class="line">            ErrorString += FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;\n  %s&quot;</span>), *GlobalParameterName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">UE_LOG</span>(LogShaders, Fatal, <span class="built_in">TEXT</span>(<span class="string">&quot;%s&quot;</span>), *ErrorString);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终就是通过上面收集到的TArray<FShaderParametersMetadata::FMember>包含的类型信息做处理，分别把参数添加到FShaderParameterBindings对应的成员中。与Shader中定义的参数做对照检查，其实和上面手动绑定的效果类似，不过更全面。</FShaderParametersMetadata::FMember></p><h2 id="4-Shader参数绑定"><a href="#4-Shader参数绑定" class="headerlink" title="4. Shader参数绑定"></a>4. Shader参数绑定</h2><p>现在我们已经成功编译好了Shader，并且确认C++侧和Shader侧两边的定义是吻合的，我们需要搭起两边的桥梁。</p><p>对于GlobalShader因为没有BuildMeshCommands流程，所以需要手动调用Shader的SetParameters设置C++参数值。以Texture参数举例分析SetParameters：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetParameters</span><span class="params">(FRHICommandList&amp; RHICmdList, <span class="type">const</span> FTexture* NormalMapTexture)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FRHIPixelShader* PixelShaderRHI = RHICmdList.<span class="built_in">GetBoundPixelShader</span>();</span><br><span class="line"><span class="built_in">SetTextureParameter</span>(RHICmdList, PixelShaderRHI,Texture,TextureSampler,NormalMapTexture);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FOpenGLDynamicRHI::InternalSetShaderTexture</span><span class="params">(FOpenGLTextureBase* Texture, FOpenGLShaderResourceView* SRV, GLint TextureIndex, GLenum Target, GLuint Resource, <span class="type">int</span> NumMips, <span class="type">int</span> LimitMip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span>&amp; PendingTextureState = PendingState.Textures[TextureIndex];</span><br><span class="line">PendingTextureState.Texture = Texture;</span><br><span class="line">PendingTextureState.SRV = SRV;</span><br><span class="line">PendingTextureState.Target = Target;</span><br><span class="line">PendingTextureState.Resource = Resource;</span><br><span class="line">PendingTextureState.LimitMip = LimitMip;</span><br><span class="line">PendingTextureState.bHasMips = (NumMips == <span class="number">0</span> || NumMips &gt; <span class="number">1</span>);</span><br><span class="line">PendingTextureState.NumMips = NumMips;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用到DynamicRHI接口层，把参数赋值给PendingState。</p><p>对于MaterialShader，会在BuildMeshCommands调用GetShaderBinding，调用绑定，把绑定关系存储在MeshDrawCommands中，在SubmitDraw执行真正绑定，也就是调用上面手动binding的接口。</p><p>最终在DrawPrimitive中将PendingState的数据调用API传给GPU，下面是Texture最终调用API的调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> StateType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FOpenGLDynamicRHI::SetupTexturesForDraw</span><span class="params">( FOpenGLContextState&amp; ContextState, <span class="type">const</span> StateType&amp; ShaderState, int32 MaxTexturesNeeded )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">VERIFY_GL_SCOPE</span>();</span><br><span class="line">    <span class="built_in">SCOPE_CYCLE_COUNTER_DETAILED</span>(STAT_OpenGLTextureBindTime);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Skip texture setup when running bindless texture, it is done with program setup</span></span><br><span class="line">    <span class="keyword">if</span> (FOpenGL::<span class="built_in">SupportsBindlessTexture</span>() &amp;&amp; OpenGLConsoleVariables::bBindlessTexture)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32 MaxProgramTexture = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> TBitArray&lt;&gt;&amp; NeededBits = ShaderState-&gt;<span class="built_in">GetTextureNeeds</span>(MaxProgramTexture);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( int32 TextureStageIndex = <span class="number">0</span>; TextureStageIndex &lt;= MaxProgramTexture; ++TextureStageIndex )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span> (!NeededBits[TextureStageIndex])</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">// Current program doesn&#x27;t make use of this texture stage. No matter what UE4 wants to have on in,</span></span><br><span class="line">          <span class="comment">// it won&#x27;t be useful for this draw, so telling OpenGL we don&#x27;t really need it to give the driver</span></span><br><span class="line">          <span class="comment">// more leeway in memory management, and avoid false alarms about same texture being set on</span></span><br><span class="line">          <span class="comment">// texture stage and in framebuffer.</span></span><br><span class="line">          <span class="built_in">CachedSetupTextureStage</span>( ContextState, TextureStageIndex, GL_NONE, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span> );</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">          <span class="type">const</span> FTextureStage&amp; TextureStage = PendingState.Textures[TextureStageIndex];</span><br><span class="line">          </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UE_BUILD_DEBUG</span></span><br><span class="line">          <span class="comment">// Use the texture SRV&#x27;s LimitMip value to specify the mip available for sampling</span></span><br><span class="line">          <span class="comment">// This requires SupportsTextureBaseLevel &amp; is a fallback for SupportsTextureView</span></span><br><span class="line">          <span class="comment">// which should be preferred.</span></span><br><span class="line">          <span class="keyword">if</span>(!FOpenGL::<span class="built_in">SupportsTextureView</span>())</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="comment">// When trying to limit the mip available for sampling (as part of texture SRV)</span></span><br><span class="line">             <span class="comment">// ensure that the texture is bound to only one sampler, or that all samplers</span></span><br><span class="line">             <span class="comment">// share the same restriction.</span></span><br><span class="line">             <span class="keyword">if</span>(TextureStage.LimitMip != <span class="number">-1</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                <span class="keyword">for</span>( int32 TexIndex = <span class="number">0</span>; TexIndex &lt;= MaxProgramTexture; ++TexIndex )</span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="keyword">if</span>(TexIndex != TextureStageIndex &amp;&amp; ShaderState-&gt;<span class="built_in">NeedsTextureStage</span>(TexIndex))</span><br><span class="line">                   &#123;</span><br><span class="line">                      <span class="type">const</span> FTextureStage&amp; OtherStage = PendingState.Textures[TexIndex];</span><br><span class="line">                      <span class="type">const</span> <span class="type">bool</span> bSameResource = OtherStage.Resource == TextureStage.Resource;</span><br><span class="line">                      <span class="type">const</span> <span class="type">bool</span> bSameTarget = OtherStage.Target == TextureStage.Target;</span><br><span class="line">                      <span class="type">const</span> GLint TextureStageBaseMip = TextureStage.LimitMip == <span class="number">-1</span> ? <span class="number">0</span> : TextureStage.LimitMip;</span><br><span class="line">                      <span class="type">const</span> GLint OtherStageBaseMip = OtherStage.LimitMip == <span class="number">-1</span> ? <span class="number">0</span> : OtherStage.LimitMip;</span><br><span class="line">                      <span class="type">const</span> <span class="type">bool</span> bSameLimitMip = TextureStageBaseMip == OtherStageBaseMip;</span><br><span class="line">                      <span class="type">const</span> GLint TextureStageMaxMip = TextureStage.LimitMip == <span class="number">-1</span> ? TextureStage.NumMips - <span class="number">1</span> : TextureStage.LimitMip;</span><br><span class="line">                      <span class="type">const</span> GLint OtherStageMaxMip = OtherStage.LimitMip == <span class="number">-1</span> ? OtherStage.NumMips - <span class="number">1</span> : OtherStage.LimitMip;</span><br><span class="line">                      <span class="type">const</span> <span class="type">bool</span> bSameMaxMip = TextureStageMaxMip == OtherStageMaxMip;</span><br><span class="line">                      <span class="keyword">if</span>( bSameTarget &amp;&amp; bSameResource &amp;&amp; !bSameLimitMip &amp;&amp; !bSameMaxMip )</span><br><span class="line">                      &#123;</span><br><span class="line">                         <span class="built_in">UE_LOG</span>(LogRHI, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Texture SRV fallback requires that each texture SRV be bound with the same mip-range restrictions. Expect rendering errors.&quot;</span>));</span><br><span class="line">                      &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          <span class="built_in">CachedSetupTextureStage</span>( ContextState, TextureStageIndex, TextureStage.Target, TextureStage.Resource, TextureStage.LimitMip, TextureStage.NumMips );</span><br><span class="line">          </span><br><span class="line">          <span class="type">bool</span> bExternalTexture = (TextureStage.Target == GL_TEXTURE_EXTERNAL_OES);</span><br><span class="line">          <span class="keyword">if</span> (!bExternalTexture)</span><br><span class="line">          &#123;</span><br><span class="line">             FOpenGLSamplerState* PendingSampler = PendingState.SamplerStates[TextureStageIndex];</span><br><span class="line">          </span><br><span class="line">             <span class="keyword">if</span> (ContextState.SamplerStates[TextureStageIndex] != PendingSampler)</span><br><span class="line">             &#123;</span><br><span class="line">                FOpenGL::<span class="built_in">BindSampler</span>(TextureStageIndex, PendingSampler ? PendingSampler-&gt;Resource : <span class="number">0</span>);</span><br><span class="line">                ContextState.SamplerStates[TextureStageIndex] = PendingSampler;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (TextureStage.Target != GL_TEXTURE_BUFFER)</span><br><span class="line">          &#123;</span><br><span class="line">             FOpenGL::<span class="built_in">BindSampler</span>(TextureStageIndex, <span class="number">0</span>);</span><br><span class="line">             ContextState.SamplerStates[TextureStageIndex] = <span class="literal">nullptr</span>;</span><br><span class="line">             <span class="built_in">ApplyTextureStage</span>( ContextState, TextureStageIndex, TextureStage, PendingState.SamplerStates[TextureStageIndex] );</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For now, continue to clear unused stages</span></span><br><span class="line">    <span class="keyword">for</span>( int32 TextureStageIndex = MaxProgramTexture + <span class="number">1</span>; TextureStageIndex &lt; MaxTexturesNeeded; ++TextureStageIndex )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">CachedSetupTextureStage</span>( ContextState, TextureStageIndex, GL_NONE, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-UE的一些通用参数"><a href="#5-UE的一些通用参数" class="headerlink" title="5. UE的一些通用参数"></a>5. UE的一些通用参数</h2><p>ViewUniformBuffer，里面包含了非常多的公共参数，是通过FMeshPassProcessor保存，最终在BuildMeshDrawCommands中汇入上面的流程，在父类FMeshMaterialShader::GetShaderBinding中添加参数绑定。</p><p>但是ViewUniformBuffer里定义的参数，在Shader侧完全找不到定义，原因是这样的GlobalShader会通过宏定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IMPLEMENT_GLOBAL_SHADER_PARAMETER_STRUCT</span>(FViewUniformShaderParameters, <span class="string">&quot;View&quot;</span>);</span><br></pre></td></tr></table></figure><p>在shader编译的时候，通过一系列的字符串匹配操作，在编译的HLSL中插入在C++侧定义的Shader参数定义，但是我们在usf/ush中是找不到的。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/669325070">https://zhuanlan.zhihu.com/p/669325070</a></p><p><a href="https://zhuanlan.zhihu.com/p/66288908">https://zhuanlan.zhihu.com/p/66288908</a></p><p><a href="https://cloud.tencent.com/developer/article/2238861">https://cloud.tencent.com/developer/article/2238861</a></p><p><a href="https://zhuanlan.zhihu.com/p/485239547">https://zhuanlan.zhihu.com/p/485239547</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UE LandScape</title>
      <link href="/2025/03/26/UELandScape/"/>
      <url>/2025/03/26/UELandScape/</url>
      
        <content type="html"><![CDATA[<h1 id="UE-LandScape"><a href="#UE-LandScape" class="headerlink" title="UE LandScape"></a>UE LandScape</h1><p>UE的landscape主要由几个层级组成：LandScapeActor，LandScapeComponent，SectionPerComponent，Quads。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UE Animation</title>
      <link href="/2025/01/23/UEAnimation/"/>
      <url>/2025/01/23/UEAnimation/</url>
      
        <content type="html"><![CDATA[<h1 id="UE-Animation"><a href="#UE-Animation" class="headerlink" title="UE Animation"></a>UE Animation</h1><p>UE4/UE5的骨骼动画其实都是通过SkeletalMeshComponent来实现的。这个组件内部会引用到一个SkeletalMesh资源，就像StaticMeshComponent一样，也有一个StaticMesh资源，从资源层面来说SkeletalMesh和StaticMesh的区别就是多了骨骼。Component相对于资源来说，可以理解为对象实例和类的关系，同一个资源可以有很多个Component实例。</p><span id="more"></span><p>直观的来说，一个Mesh想要动起来，那么就需要去对每个顶点做Transform(位移/旋转/缩放)，当我们连续做很多帧这样的Transform并按顺序播放，就变成了动画。但是一个几万面的Mesh，在资源层面一帧就要保存几万个Transform，即使引入关键帧，也肯定还会占非常多的空间，因此这个做法明显不现实。那么能想到最直接的解决办法就是对这几万个Transform数据做压缩，把相同的归并在一起。</p><p>骨骼这个概念，本质上就是压缩相同顶点的Transform的一种方式。具体来说，就是把Mesh上一部分的顶点和其中一个或多个骨骼做绑定，那么我们只要记录这个骨骼的Transform就好了，这样一个Mesh就被划分成了多个部分，不同部分受不同的骨骼影响。最后计算顶点的实际位置时就只需要让顶点乘以关联的骨骼Transform就可以了。如果顶点是和多个骨骼关联，那么也可以分别乘以不同骨骼的Transform以及受影响的百分比，再求和，就可以得到最终的顶点位置。</p><p>进一步来看，如果每个动画都记录全局Transform数组，可能数据量还是会有些大且不规律。骨骼和骨骼之间也可以记录相对的Transform，也就是让每一级都在父级的局部空间内做Transform，这样每一级坐标的范围也会明显变小，而且也很像动物的关节一样一节一节的动，比较符合实际情况，骨骼数组就变成了一棵树，当我们记录动画时就会更容易，而计算实际的Transform时，只要递归把所有父级的Transform乘在一起，就得到了最终的Transform。</p><p>这个通过骨骼Transform计算出实际顶点的过程，叫做Skin(蒙皮)。而这个骨骼Transform数组，叫做Pose。UE4/UE5的SkeletalMeshComponent，其实就是把美术做的多个动画原始的Pose资源(AnimSequence)，通过动画蓝图做混合，得到最终的一个Pose，再根据这个Pose做蒙皮求得每个顶点实际位置并绘制的过程。</p><p>具体来说，就是下面这两个步骤：</p><ol><li>先在<strong>游戏线程</strong>中TickComponent求得当前帧的最终Pose</li><li>再在<strong>渲染线程</strong>中根据最终Pose做<a href="https://zhida.zhihu.com/search?content_id=209376946&amp;content_type=Article&amp;match_order=1&amp;q=CPUSkin&amp;zhida_source=entity">CPUSkin</a>或<a href="https://zhida.zhihu.com/search?content_id=209376946&amp;content_type=Article&amp;match_order=1&amp;q=GPUSkin&amp;zhida_source=entity">GPUSkin</a>算出顶点信息，并进行绘制</li></ol><p>UE的动画主要是依赖SkeletalMeshComponent的Tick来执行更新，对应的骨骼更新得到的数据也是存储在这里，中间计算用到的数据会保存在每个SkeletalMeshComponent Link的AnimInstance中。</p><p>下面先列出一个流程图：</p><p><img src="/2025/01/23/UEAnimation/codeProcess.jpg" alt="img"></p><h2 id="UpdateMontage"><a href="#UpdateMontage" class="headerlink" title="UpdateMontage"></a>UpdateMontage</h2><p>UpdateMontage，该Instance所有被执行播放的Montage都会存储在这里，一起更新blend值，blend值有多种选择，最常见的就是线性blend。</p><p>Montage_Advance 步进Montage，主要进行时间步进，根据当前时间戳触发blendout，累计rootmotion值，触发BranchingPoints。BranchingPoints会触发各种逻辑，所以必须放在主线程执行。BranchingPoint是即时通知的动画事件，可能会用来修改当帧的动画。</p><h2 id="ParallelAnimationEvaluation"><a href="#ParallelAnimationEvaluation" class="headerlink" title="ParallelAnimationEvaluation"></a>ParallelAnimationEvaluation</h2><p>其中最重要的是两个接口，ParallelUpdateAnimation和ParallelEvaluateAnimation，前者负责准备动画节点最终用于计算骨骼Transform的数据，后者则是依赖前者的数据执行真正的计算：比如FAnimNode_ApplyAdditive节点的Update接口用来更新用于叠加的两个输入的权重分别是多少，Evaluate接口用于真正执行两个输入的Transform。两者的执行流程类似，都是从动画蓝图的最终Pose向前递归，直到没有前置节点为止。</p><p>Evaluate的执行流程被包含在下面的函数中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">USkeletalMeshComponent::PerformAnimationProcessing</span><span class="params">(<span class="type">const</span> USkeletalMesh* InSkeletalMesh, UAnimInstance* InAnimInstance, <span class="type">bool</span> bInDoEvaluation, TArray&lt;FTransform&gt;&amp; OutSpaceBases, TArray&lt;FTransform&gt;&amp; OutBoneSpaceTransforms, FVector&amp; OutRootBoneTranslation, FBlendedHeapCurve&amp; OutCurve)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">CSV_SCOPED_TIMING_STAT</span>(Animation, WorkerThreadTickTime);</span><br><span class="line"><span class="built_in">ANIM_MT_SCOPE_CYCLE_COUNTER</span>(PerformAnimEvaluation, !<span class="built_in">IsInGameThread</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Can&#x27;t do anything without a SkeletalMesh</span></span><br><span class="line"><span class="keyword">if</span> (!InSkeletalMesh)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update anim instance</span></span><br><span class="line"><span class="keyword">if</span>(InAnimInstance &amp;&amp; InAnimInstance-&gt;<span class="built_in">NeedsUpdate</span>())</span><br><span class="line">&#123;</span><br><span class="line">InAnimInstance-&gt;<span class="built_in">ParallelUpdateAnimation</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">ShouldPostUpdatePostProcessInstance</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// If we don&#x27;t have an anim instance, we may still have a post physics instance</span></span><br><span class="line">PostProcessAnimInstance-&gt;<span class="built_in">ParallelUpdateAnimation</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do nothing more if no bones in skeleton.</span></span><br><span class="line"><span class="keyword">if</span>(bInDoEvaluation &amp;&amp; OutSpaceBases.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">FMemMark <span class="title">Mark</span><span class="params">(FMemStack::Get())</span></span>;</span><br><span class="line">FCompactPose EvaluatedPose;</span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluate pure animations, and fill up BoneSpaceTransforms</span></span><br><span class="line"><span class="built_in">EvaluateAnimation</span>(InSkeletalMesh, InAnimInstance, OutRootBoneTranslation, OutCurve, EvaluatedPose);</span><br><span class="line"><span class="built_in">EvaluatePostProcessMeshInstance</span>(OutBoneSpaceTransforms, EvaluatedPose, OutCurve, InSkeletalMesh, OutRootBoneTranslation);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finalize the transforms from the evaluation</span></span><br><span class="line"><span class="built_in">FinalizePoseEvaluationResult</span>(InSkeletalMesh, OutBoneSpaceTransforms, OutRootBoneTranslation, EvaluatedPose);</span><br><span class="line"><span class="comment">//填充结果到MeshComponent</span></span><br><span class="line"><span class="comment">// Fill SpaceBases from LocalAtoms</span></span><br><span class="line"><span class="built_in">FillComponentSpaceTransforms</span>(InSkeletalMesh, OutBoneSpaceTransforms, OutSpaceBases);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">USkeletalMeshComponent::DoParallelEvaluationTasks_OnGameThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">SwapEvaluationContextBuffers</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">ParallelAnimationEvaluation</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">SwapEvaluationContextBuffers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在解算过程中，会把计算结果都保存到AnimEvaluationContext上，解算之后再把Buffer数据Swap回真正的成员变量上。</p><p>当发送渲染数据时，SendRenderDynamicData_Concurrent会根据是CPU还是GPU蒙皮调用不同的MeshObject-&gt;Update，具体数据传输的流程如下图：</p><p><img src="/2025/01/23/UEAnimation/RenderSkin.drawio.png" alt="RenderSkin.drawio"></p><p>meshobject的UpdateDynamicData_RenderThread的UpdateRefToLocalMatrices被传给了Referencetolocal，最后传给了VF的buffer。</p><p>如果是CPUSkin，也是在Update里做蒙皮，Evaluate的结果也是存在ReferenceToLocal，SkinVertexSection中直接对LOD的顶点数据进行权重矩阵运算。</p><p>而GPU蒙皮的操作最终在通用的VF接口GetVertexFactoryIntermediates中调用CalcBoneMatrix计算蒙皮得到最终的顶点数据，输入的顶点数据中也会指定对应的骨骼权重和骨骼矩阵索引，最多是四个，如果超过四个就会带上BlendIndicesExtra和BlendWeightsExtra成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FVertexFactoryInput</span></span><br><span class="line">&#123;</span><br><span class="line">    float4 Position      : ATTRIBUTE0;</span><br><span class="line">    <span class="comment">// 0..1</span></span><br><span class="line">    half3  TangentX      : ATTRIBUTE1;</span><br><span class="line">    <span class="comment">// 0..1</span></span><br><span class="line">    <span class="comment">// TangentZ.w contains sign of tangent basis determinant</span></span><br><span class="line">    half4  TangentZ      : ATTRIBUTE2;  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GPUSKIN_UNLIMITED_BONE_INFLUENCE</span></span><br><span class="line">    uint   BlendOffsetCount   : ATTRIBUTE3;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FEATURE_LEVEL &gt;= FEATURE_LEVEL_ES3_1 || COMPILER_METAL || COMPILER_VULKAN</span></span><br><span class="line">    uint4  BlendIndices   : ATTRIBUTE3;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> GPUSKIN_USE_EXTRA_INFLUENCES</span></span><br><span class="line">    uint4  BlendIndicesExtra  : ATTRIBUTE14;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// Continue using int for SM3, compatibility of uint is unknown across SM3 platforms</span></span><br><span class="line">    int4   BlendIndices   : ATTRIBUTE3;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> GPUSKIN_USE_EXTRA_INFLUENCES</span></span><br><span class="line">    int4   BlendIndicesExtra  : ATTRIBUTE14;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    float4 BlendWeights   : ATTRIBUTE4;  </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GPUSKIN_USE_EXTRA_INFLUENCES</span></span><br><span class="line">    float4 BlendWeightsExtra  : ATTRIBUTE15;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// GPUSKIN_UNLIMITED_BONE_INFLUENCE</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PostUpdateAnimation"><a href="#PostUpdateAnimation" class="headerlink" title="PostUpdateAnimation"></a>PostUpdateAnimation</h2><p>解算出当前帧的动画之后，就需要做一些当前帧的事件通知，非BranchingPoint类的通知会在这里被抛出。</p><p>Q：</p><p>直接播放的动画蒙太奇和在节点中执行的pose节点如何混合？</p><p>直接播放的蒙太奇其实是指定slot的节点播放，这个slot节点必须被存储在以根节点为尾的树结构中，最终在slot node中被更新。</p><p>题外话：</p><p>VF是存在MeshObject中的，也是构造的时候meshcomponent的时候的renderdata赋值的。</p><p>SceneProxy里的MeshObject是copy Component里的，渲染的时候getdynamicelements直接拿数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UEMultiThread</title>
      <link href="/2025/01/12/UEMultiThread/"/>
      <url>/2025/01/12/UEMultiThread/</url>
      
        <content type="html"><![CDATA[<h1 id="UEMultiThread"><a href="#UEMultiThread" class="headerlink" title="UEMultiThread"></a>UEMultiThread</h1><h2 id="TQueue"><a href="#TQueue" class="headerlink" title="TQueue"></a>TQueue</h2><p>需要模板参数指定是单/多生产者</p><p>入队和出队都是靠new和delete，所以不用考虑CAS，没有对象复用。</p><p>效率不高，size是16字节对齐，所以会经过L3缓存？</p><span id="more"></span><p>LockFreeList</p><p>完美的无锁容器，也是TaskGraph的基础容器</p><p>CAS 本身不可靠，因为只靠一个节点值没法判断节点后面的值没有被修改，所以要加入版本号，也就是计数器的操作来统计节点被操作的次数，即Lockfreelist里的Counter</p><p>节点指针：</p><p>FIndexPointer是最最基础的一个数据结构，用来做节点的CAS状态和指针。</p><p>LIFO是一个无锁的队列，啥都没有。</p><p>LockFreeLinkPolicy是把节点重命名了一下，然后实现了节点的分配和回收接口。AllocLockFreeLink和FreeLockFreeLink，分配接口底层需要调用分配器，分配器就是LockFreeLinkAllocator_TLSCache。</p><p>而这个分配器里面push和pop操作其实都是通过FLockFreePointerListLIFORoot实现的一个无锁的栈来操作存储，而Root其实也并不能申请内存，只是用来存储，真正申请内存的是FLockFreeLinkPolicy::LinkAllocator也就是TLockFreeAllocOnceIndexedAllocator，会一次申请一大片buffer，然后分item提供需要的内存。</p><p>LIFOBase则是把上面的都包了一层，push和pop还是走的FLockFreeLinkPolicy分配，然后用LIFOroot实现一个存储最终保存线程的队列是FStallingTaskQueue，调用push会返回一个可用的线程，并且把对应的state置为0。pop相反。</p><p>UE5扩充了26位的限制。</p><h2 id="TaskGraph"><a href="#TaskGraph" class="headerlink" title="TaskGraph"></a>TaskGraph</h2><h2 id="一次完整任务的执行流程"><a href="#一次完整任务的执行流程" class="headerlink" title="一次完整任务的执行流程"></a>一次完整任务的执行流程</h2><p>​    TaskGraph是一个高效利用多线程处理外部任务及其关联任务的框架，一次任务的提交处理大致流程如下图：</p><p><img src="/2025/01/12/UEMultiThread/multithread.drawio.png" alt="multithread.drawio"></p><ul><li>构造Task</li><li>分配Task到任务队列</li><li>唤醒线程执行Task</li><li>处理Task依赖及后续Task</li></ul><h3 id="TGraphTask"><a href="#TGraphTask" class="headerlink" title="TGraphTask"></a>TGraphTask</h3><p><img src="/2025/01/12/UEMultiThread/TTask.drawio.png" alt="TTask.drawio"></p><p>​    TBaseGraphTask是TaskGraphInterface中处理任务的对象类，它的子类包含了对应的构造成员FConstructor，SubSequents后续依赖任务对象，TaskStorage则是模板指定类，也是真正外部传入要执行的任务类。</p><h3 id="分配任务-amp-唤醒进程"><a href="#分配任务-amp-唤醒进程" class="headerlink" title="分配任务&amp;唤醒进程"></a>分配任务&amp;唤醒进程</h3><p>这里真正分配任务调用的就是ConstructAndDisPatchWhenReady，这个接口首先会把TGraphTask上一节提到的成员先填充好，以便后面执行任务时处理后续依赖的任务。然后判断如果当前任务的前置依赖任务都执行完了的话，就把当前任务放入TaskGraph队列中。</p><p>放入队列的入口在QueueTassk，这里实际上调用的是FTaskGraphImplementation的全局单例，也是TaskGraph的子类（实现类）。QueueTask首先会计算两个优先级：队列优先级和任务优先级。在FTaskGraphImplementation中维护了一个任务队列数组，共三个队列（对应队列优先级），每个FStallingTaskQueue队列里又有两个小队列（对应任务优先级）。</p><p>这里的两个优先级都是通过Task的ThreadToExecuteOn成员的对应位Mask得到的，而这个成员是在构造TGraphTask的时候填充的，基类默认赋值为AnyThread。</p><p>然后唤醒线程执行队列中的任务，这里是通过FStallingTaskQueue::Push来得到唤醒的线程Index。</p><p>为了避免线程冲突，这里会把分配线程的MasterState先读取到本地线程执行然后再赋值回去。</p><p>MasterState就是上面提到的FIndexPointer，一共64位，其中26位用来做线程分配，位为1时线程空闲，反之繁忙。可以注意到，如果回写MasterState的时候发生冲突，就会重新读取最新的State找到新的线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">Push</span><span class="params">(T* InPayload, uint32 Priority)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">checkLockFreePointerList</span>(Priority &lt; NumPriorities);</span><br><span class="line">TDoublePtr LocalMasterState;</span><br><span class="line">LocalMasterState.<span class="built_in">AtomicRead</span>(MasterState);</span><br><span class="line">PriorityQueues[Priority].<span class="built_in">Push</span>(InPayload);</span><br><span class="line">TDoublePtr NewMasterState;</span><br><span class="line">NewMasterState.<span class="built_in">AdvanceCounterAndState</span>(LocalMasterState, <span class="number">1</span>);</span><br><span class="line">int32 ThreadToWake = <span class="built_in">FindThreadToWake</span>(LocalMasterState.<span class="built_in">GetPtr</span>());</span><br><span class="line"><span class="keyword">if</span> (ThreadToWake &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">NewMasterState.<span class="built_in">SetPtr</span>(<span class="built_in">TurnOffBit</span>(LocalMasterState.<span class="built_in">GetPtr</span>(), ThreadToWake));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">NewMasterState.<span class="built_in">SetPtr</span>(LocalMasterState.<span class="built_in">GetPtr</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!MasterState.<span class="built_in">InterlockedCompareExchange</span>(NewMasterState, LocalMasterState))</span><br><span class="line">&#123;</span><br><span class="line">LocalMasterState.<span class="built_in">AtomicRead</span>(MasterState);</span><br><span class="line">NewMasterState.<span class="built_in">AdvanceCounterAndState</span>(LocalMasterState, <span class="number">1</span>);</span><br><span class="line">ThreadToWake = <span class="built_in">FindThreadToWake</span>(LocalMasterState.<span class="built_in">GetPtr</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="comment">// This block of code is supposed to avoid starting the task thread if the queues are empty.</span></span><br><span class="line"><span class="comment">// There WAS a silly bug here. In rare cases no task thread is woken up.</span></span><br><span class="line"><span class="comment">// That bug has been fixed, but I don&#x27;t think we really need this code anyway.</span></span><br><span class="line"><span class="comment">// Without this block, it is possible that we do a redundant wake-up, but for task threads, that can happen anyway. </span></span><br><span class="line"><span class="comment">// For named threads, the rare redundant wakeup seems acceptable.</span></span><br><span class="line"><span class="keyword">if</span> (ThreadToWake &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> bAny = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (int32 Index = <span class="number">0</span>; !bAny &amp;&amp; Index &lt; NumPriorities; Index++)</span><br><span class="line">&#123;</span><br><span class="line">bAny = !PriorityQueues[Index].<span class="built_in">IsEmpty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!bAny) <span class="comment">// if there is nothing in the queues, then don&#x27;t wake anyone</span></span><br><span class="line">&#123;</span><br><span class="line">ThreadToWake = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (ThreadToWake &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">NewMasterState.<span class="built_in">SetPtr</span>(<span class="built_in">TurnOffBit</span>(LocalMasterState.<span class="built_in">GetPtr</span>(), ThreadToWake));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">NewMasterState.<span class="built_in">SetPtr</span>(LocalMasterState.<span class="built_in">GetPtr</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ThreadToWake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到唤醒的线程Index后调用对应的Event，Trigger来唤醒线程，可以发现这里的Index还要经过Priority 和 Set的换算，下面会讲线程的排列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartTaskThread</span><span class="params">(int32 Priority, int32 IndexToStart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ENamedThreads::Type ThreadToWake = ENamedThreads::<span class="built_in">Type</span>(IndexToStart + Priority * NumTaskThreadsPerSet + NumNamedThreads);</span><br><span class="line">((FTaskThreadAnyThread&amp;)<span class="built_in">Thread</span>(ThreadToWake)).<span class="built_in">WakeUp</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FTaskGraphImplementation"><a href="#FTaskGraphImplementation" class="headerlink" title="FTaskGraphImplementation"></a>FTaskGraphImplementation</h3><p>这个类是TaskGraph框架实现的关键，它维护了多个线程成员，并且提供了队列服务来保证线程可以有效执行任务。会根据操作系统实际提供的线程数量。具体线程排列如下：</p><p><img src="/2025/01/12/UEMultiThread/taskimpletion.drawio.png" alt="taskimpletion.drawio"></p><p>在线程的生成过程中，会给每个线程申请单独的TLS，以及Affinity（核心亲和度），这样保证每个线程可以跑在不同的核心上。需要注意一点的是，这里16线程的电脑申请的是14个工作线程，由于FIndexPointer的位数限制，实际上每次任务入队时只能获取到26个不同线程，所以超过16核心32线程的电脑，也只能分配出26个线程来执行。而上面分配了不同优先级的Sets，以个人测试为例，实际上TaskGraph分配了47个线程，其中5个NameThread，这显然超过了电脑的线程并行数量，其实是因为这里申请的线程和实际上的操作系统多线程不完全是一个概念，在实际执行的时候，可能会有两个WorkerThread在同一个核心以时间片轮转的方式执行。</p><p>由于相同优先级的线程会共享同一个任务队列，所以在执行的时候可以保证负载均衡，即每个线程都尽可能执行相似数量的任务。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">FWindowsPlatformMisc::NumberOfWorkerThreadsToSpawn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> int32 MaxServerWorkerThreads = <span class="number">4</span>;</span><br><span class="line"><span class="type">static</span> int32 MaxWorkerThreads = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">int32 NumberOfCores = FWindowsPlatformMisc::<span class="built_in">NumberOfCores</span>();</span><br><span class="line">int32 NumberOfCoresIncludingHyperthreads = FWindowsPlatformMisc::<span class="built_in">NumberOfCoresIncludingHyperthreads</span>();</span><br><span class="line">int32 NumberOfThreads = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (NumberOfCoresIncludingHyperthreads &gt; NumberOfCores)</span><br><span class="line">&#123;</span><br><span class="line">NumberOfThreads = NumberOfCoresIncludingHyperthreads - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">NumberOfThreads = NumberOfCores - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里限制了最多26</span></span><br><span class="line">int32 MaxWorkerThreadsWanted = <span class="built_in">IsRunningDedicatedServer</span>() ? MaxServerWorkerThreads : MaxWorkerThreads;</span><br><span class="line"><span class="comment">// need to spawn at least one worker thread (see FTaskGraphImplementation)</span></span><br><span class="line"><span class="keyword">return</span> FMath::<span class="built_in">Max</span>(FMath::<span class="built_in">Min</span>(NumberOfThreads, MaxWorkerThreadsWanted), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ParticleSystem</title>
      <link href="/2024/12/06/ParticleSystem/"/>
      <url>/2024/12/06/ParticleSystem/</url>
      
        <content type="html"><![CDATA[<h1 id="UEParticleSystem"><a href="#UEParticleSystem" class="headerlink" title="UEParticleSystem"></a>UEParticleSystem</h1><p>UE4的粒子系统核心成员就是ParticleSystemComponent。特效同学在编辑器下编辑粒子特效生成模板数据，程序在运行时根据模板生成对应的Component，然后在Tick中更新粒子效果直至生命周期结束。本篇暂不涉及编辑器下粒子的数据编辑与生成，只讨论运行时的粒子更新流程。</p><span id="more"></span><h2 id="ParticleSystemComponent"><a href="#ParticleSystemComponent" class="headerlink" title="ParticleSystemComponent"></a>ParticleSystemComponent</h2><p><img src="/2024/12/06/ParticleSystem/ParticleComponent.png" alt="ParticleComponent"></p><p>可以看到Particle主要分成三个部分，UParticleSystem，FParticleEmitterInstance，SceneProxy，这三个分别是粒子模板数据，运行时的粒子实例数据，以及渲染线程与Component一一对应的渲染数据。</p><p>一个完整的粒子特效通常需要多个发射器来组成，比如火焰特效需要火苗以及烟雾发射器。而每个发射区又区分多个Module，负责粒子的各种表现，如SpawnModule负责生成，LocationModule负责位置数据更新，需要注意的是，在Emitter和Module之间，还存在一个LODLevel管理，以便粒子特效的性能优化。</p><h2 id="一个粒子的更新流程"><a href="#一个粒子的更新流程" class="headerlink" title="一个粒子的更新流程"></a>一个粒子的更新流程</h2><p>CPU端主要的计算是在ParticleSystemComponent的ComputeTickComponent_Concurrent中调用的，整个更新的调用链如下：</p><p>可以看到这里跟编辑器中重合的部分就是各个Module的Update，在上面的结构图里讨论过，Instance和Module之间存在一个LODLevel，这里同样在UpdateModule中是根据LODLevel中的Module来实时更新的。</p><p>GPU端的更新分为两步：一是每帧结束时填充Proxy数据，二是渲染流程中获取Mesh数据。</p><p><img src="/2024/12/06/ParticleSystem/particlecall.jpg" alt="particlecall"></p><p>需要注意TypeDataModule，这个Module比较特殊，它决定了粒子Emitter的类型，这里有几种不同类型的粒子发射器以满足不同需求，与发射器类型对应的就是渲染数据的不同，FDynamicEmitterDataBase，在获取渲染数据时也会根据类型不同调用不同子类接口。</p><p><img src="/2024/12/06/ParticleSystem/EmitterInstanceType.png" alt="image-20241213181447276"></p><h1 id="NiagaraSystem"><a href="#NiagaraSystem" class="headerlink" title="NiagaraSystem"></a>NiagaraSystem</h1><p>这个系统可以说是UE4 ParticleSystem的升级版，可以更加自由地组合粒子发射器，对粒子系统编程。与之前Cascade系统的差别主要如下：</p><ul><li>Emitter独立于Component之外，可以自由组合。</li><li>丢弃LODLevel层。</li><li>每个Emitter可以根据阶段添加Module，进行调参。</li></ul><h2 id="NiagaraComponent"><a href="#NiagaraComponent" class="headerlink" title="NiagaraComponent"></a>NiagaraComponent</h2><p><img src="/2024/12/06/ParticleSystem/NiagaraComponent.drawio.png" alt="NiagaraComponent.drawio"></p><p>储存粒子数据的结构是FNiagaraDataSet，两个DataBuffer成员分别是当前帧的输入和输出数据。</p><p>在SceneProxy端根据Emitter类型的不同，放入不同的Render中存储渲染，存储的粒子数据位于FNiagaraDynamicDataBase，里面存储了CPU和GPU端的粒子渲染数据。</p><h2 id="粒子的更新流程"><a href="#粒子的更新流程" class="headerlink" title="粒子的更新流程"></a>粒子的更新流程</h2><p><img src="/2024/12/06/ParticleSystem/NiagaraUpdate.drawio.png" alt="NiagaraUpdate.drawio"></p><p>粒子的更新还是在Tick中完成的，与Cascade系统不同的是，这里不会再显式地调用每个Module的更新。</p><p>更新阶段区分CPU还是GPU粒子，CPU端的粒子最终是通过虚拟机执行脚本来更新，可以看到先执行SpawnContext然后执行UpdateContext，而GPU端粒子则只负责把数据放入FNiagaraSystemGpuComputeProxy的PendingTicks队列，之后会在渲染线程获取队列数据，然后把队列数据转为Dispatch数据，最终把数据传入ComputeShader进行更新。更新的数据buff始终是EmitterInstance中的DataBuffer。</p><p>GPU端粒子更新区分为三个阶段，如何决定是哪个阶段是在FNiagaraSystemGpuComputeProxy中，最简单的如果需要深度或者距离场信息，那么就需要放到不透明后再更新，默认是在PreInitView阶段。</p><p><img src="/2024/12/06/ParticleSystem/TickStage.png" alt="image-20241220175929596"></p><h2 id="粒子的渲染"><a href="#粒子的渲染" class="headerlink" title="粒子的渲染"></a>粒子的渲染</h2><p>由于渲染流程基本没什么变化，所以还是走Component数据转移到SceneProxy，然后数据生成MeshBatch，最后生成MeshDrawCommands这一套。</p><p><img src="/2024/12/06/ParticleSystem/NiagraRender.drawio.png" alt="NiagraRender.drawio"></p><p>首先先把之前更新的数据转移到Render线程下管理，然后再借助这些数据生成MeshBatch。</p><p><img src="/2024/12/06/ParticleSystem/NiagaraMeshBatch.drawio.png" alt="NiagaraMeshBatch.drawio"></p><p>生成MeshBatch的流程入口还是在GetDynamicMeshElements，一步步调用到Renderer的接口，根据粒子类型不同调用不同renderer，需要注意的是这里传输粒子顶点数据有两个重要的Buffer，FNiagaraSpriteUniformParameters和FNiagaraSpriteVFLooseParameters。</p><p>FNiagaraSpriteUniformParameters是与View相关的Buffer，包含粒子渲染的一些基础参数，比如默认位置，颜色，以及实例数据的布局等</p><p>FNiagaraSpriteVFLooseParameters是与实例相关的Buffer，存储了之前更新粒子的每个实例数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE阴影</title>
      <link href="/2024/11/07/UE%E9%98%B4%E5%BD%B1/"/>
      <url>/2024/11/07/UE%E9%98%B4%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/11/07/UE%E9%98%B4%E5%BD%B1/light.png" alt="img"></p><p>在网上有各种对UE4阴影和光源的分类，其中比较容易理解的如<a href="https://www.unrealengine.com/zh-CN/blog/chn-unreal-engine-4-light-and-shadow">参考文章一</a>，本文主要是针对代码实现进行分析，对阴影的分类可能与其他文章中略有不同，主要是由于统计口径不一致的原因，在分析代码的同时也会注明属于哪一类阴影。</p><span id="more"></span><p>本文主要分析上图中直接光和反射源造成的阴影，即蓝色部分，且是移动管线。</p><h2 id="Data-Setup"><a href="#Data-Setup" class="headerlink" title="Data  Setup"></a>Data  Setup</h2><p>这一步是准备阴影渲染的各种数据，包括但不限于：阴影渲染的物体，矩阵，阴影视图等等，因为需要从主场景中根据各种光源和以及物体判断一些物体是否需要阴影，以及需要什么类型阴影，这里会做非常多的筛选。入口在FMobileSceneRenderer::InitDynamicShadows。</p><ul><li>对每个光源遍历<ul><li>根据光源类型以及一些判断，看当前光能打出什么类型阴影</li><li>点/面/聚光源 全局投射（属于直接光照，）</li><li>方向光全局投射（属于CSM）</li><li>交互阴影</li></ul></li></ul><h3 id="CreateWholeSceneProjectedShadow"><a href="#CreateWholeSceneProjectedShadow" class="headerlink" title="CreateWholeSceneProjectedShadow"></a>CreateWholeSceneProjectedShadow</h3><p>这一步是创建点/面/聚光源的全局投射阴影，先对view进行循环，计算每个view下的光源的阴影，计算每个光源的阴影渐变alpha值，需要的分辨率的值。</p><ul><li>计算View的分辨率</li><li>计算FadeAlpha值</li><li>计算缓存模式</li><li>填充阴影数据</li></ul><p><strong>FadeAlpha值：</strong></p><p>只有当alpha值大于1/256时才真正创建阴影，因为alpha是一个根据阴影分辨率在0~1变化的一次函数，当&lt;1/256时，可以认为阴影非常小，所以不创建。</p><p><img src="https://lilithgames.feishu.cn/space/api/box/stream/download/asynccode/?code=YTAzNzA2ZWI2YWE2NGMyZTViZmRhYWZkYTQ2YThlMTdfRmEzYTFHWHBHQkFjemlCZVFkaFBvamdvMmkzVmhMblFfVG9rZW46SWI1d2JSNVQzbzRPa2N4UVNVWWNQcExibmtiXzE3MzE1NzU2NTY6MTczMTU3OTI1Nl9WNA" alt="img"></p><p><strong>阴影的缓存</strong></p><p>因为有些光源是静态的，物体也是静态的，没必要每一帧都渲染，可以把阴影贴图缓存起来。计算策略如下，基本原则就是当前满足（缓存大小，缓存频率）要求，就分开渲染动态静态，否则把动/静态渲染在一张贴图上不缓存。</p><p><img src="/2024/11/07/UE%E9%98%B4%E5%BD%B1/CacheMode.png" alt></p><p>DropRatio是计算当前贴图分辨率和原本需要的贴图分辨率相差比率：当前贴图分辨率为原本需要的分辨率取</p><p>Log2 -1，也就是下一级对数，比如需要100的分辨率，就会计算64。DropRatio越大，表示相差越多，当相差不多时(&lt;0.5f)，为了保持渲染滤波稳定，则不重新渲染。</p><p>SDCM_MovablePrimitivesOnly shadowmap 只渲染动态图元</p><p><strong>FProjectedShadowInfo</strong></p><p>投射阴影渲染信息，对应一张阴影贴图，包含阴影渲染时需要的矩阵，光源，缓存，边界等等信息，后续渲染会依赖这个结构。</p><p><strong>AddSubjectPrimitive</strong></p><p> 分别为动态，无缓冲的阴影添加需要绘制阴影的primitive。</p><p>最终把FProjectedShadowInfo添加到Light对应的数据成员进行管理。</p><p><img src="/2024/11/07/UE%E9%98%B4%E5%BD%B1/addshadow.png" alt="image-20241115155733748"></p><h3 id="AddViewDependentWholeSceneShadowsForView"><a href="#AddViewDependentWholeSceneShadowsForView" class="headerlink" title="AddViewDependentWholeSceneShadowsForView"></a>AddViewDependentWholeSceneShadowsForView</h3><p>这一步和上一步基本类似，针对单独的方向光做CSM，通过GetNumViewDependentWholeSceneShadows获取CSM层数，分别做投影，3级就渲染3张阴影贴图，每一级的贴图分辨率相同，CSM不会设置缓存，不会收集绘制物体。</p><p>除了CSM还会设置LPV的阴影，这里暂不展开。</p><h3 id="SetupInteractionShadows"><a href="#SetupInteractionShadows" class="headerlink" title="SetupInteractionShadows"></a>SetupInteractionShadows</h3><p>这一步主要是SetupPerObjectProjection，对每个物体创建独立阴影，创建对应的投影矩阵，阴影常量的计算与之前全局阴影基本一致：比如分辨率等等。</p><p>这一步对光源本身缓存的Interactionprimitive做投影，分别有三个链表缓存不同类型的LightInteraction，这些链表数据是在FLightPrimitiveInteraction构造函数中链接上去的，三个链表的区别是，用来存储经常移动的物体，不经常移动的物体，以及光照自身缓存的一个列表，前两个链表是存在全局分配器中的。<img src="/2024/11/07/UE%E9%98%B4%E5%BD%B1/LightInteraction.png" alt="image-20241115165744325"></p><p>PS:PreShadow就是静态物体投影在别的移动物体上的阴影。</p><p>  <em>A preshadow is a per object shadow that handles the static environment casting on a dynamic receiver</em></p><h3 id="InitProjectedShadowVisibility"><a href="#InitProjectedShadowVisibility" class="headerlink" title="InitProjectedShadowVisibility"></a>InitProjectedShadowVisibility</h3><p>这里再对收集上面收集的阴影信息查询一次可见性，看阴影是否被遮挡，调用的是IsShadowOccluded直接查询。遮挡数据的计算是在RenderOcclusion时。ProjectedShadow测试的大致流程是把一个在阴影空间原点的cube，转换到世界空间下绘制，看是否被遮挡。</p><p>主要有三步</p><ul><li>AllocateOcclusionTests（申请查询数据占位</li><li>Prepare×××ShadowOcclusionQuery（填充查询参数，比如阴影变化矩阵</li><li>Execute×××ShadowOcclusionQuery（执行绘制查询，记录结果</li></ul><p>计算阴影可见性，并且放入ProjectedShadowViewRelevanceMap中记录。</p><h3 id="UpdatePreshadowCache"><a href="#UpdatePreshadowCache" class="headerlink" title="UpdatePreshadowCache"></a>UpdatePreshadowCache</h3><p>清理这一帧不渲染的PreShadow缓存，并且添加新的PreShadow到缓存。（为什么需要缓存）</p><h3 id="GatherShadowPrimitives"><a href="#GatherShadowPrimitives" class="headerlink" title="GatherShadowPrimitives"></a>GatherShadowPrimitives</h3><p>收集每个阴影包含的primitive，在前面处理perobj shadow的时候其实是有添加过primitive的，但是只收集了perobj 的那个obj 自身，以及它的<em>primitive’s attachment group，</em>但是其他被包含在阴影视锥中的primitive并没有添加。</p><ul><li>先通过空间八叉树定位与perobj / CSM 相交的空间节点（与任何一个阴影相交都为true<ul><li>对每个空间节点获取其中包含的primitive<ul><li>对每个primitive测试与perobj/CSM 进行视锥相交测试 &amp; 各种裁剪测试<ul><li>通过测试的调用AddSubjectPrimitive_AnyThread</li></ul></li></ul></li></ul></li></ul><h3 id="AllocateShadowDepthTargets"><a href="#AllocateShadowDepthTargets" class="headerlink" title="AllocateShadowDepthTargets"></a>AllocateShadowDepthTargets</h3><p>这一步主要就是为上面的得到的projectshadowinfo申请不同的rt来渲染，首先将阴影进行分类（是否能存在多帧，是否能进图集），然后分别调用对应的allocate方法，</p><p>拿perobj shadow举例AllocatePerObjectShadowDepthTargets，这里申请的RT都是存放在Pass下</p><ul><li>首先判断cachemode，如果只渲染moveable的primitive，并且当前没有需要渲的物体，那么直接从cacheshadowmap里找之前的RHI RT引用拿过来</li><li>SortedShadowsForShadowDepthPass.ShadowMapAtlases 添加阴影图集，根据阴影逐个添加元素。所有的perobject 都渲在一张RT上，从左到右，从上到下排列，如果放不下了（CurrentShadowLayout.AddElement），再申请一张新的RT。</li></ul><h3 id="GatherShadowDynamicMeshElements"><a href="#GatherShadowDynamicMeshElements" class="headerlink" title="GatherShadowDynamicMeshElements"></a>GatherShadowDynamicMeshElements</h3><p>从之前收集的Primitive中获取MeshBatch，并且生成MeshDrawCommands放到对应的Pass下。</p><p>生成MeshDrawCommands分为两部分，静态和动态，动态绘制路径通过GatherDynamicMeshElementsArray先生成MeshBatch，GetDynamicMeshElements的详细作用可以参考渲染流程第二篇。静态的部分因为MeshDrawCommands是可以缓存的，所以在AddSubjectPrimitive部分中已经提前copy了原有的Commands。生成MeshDrawCommands也分为两部分，因为UE的阴影分为两种实现，一个是ShadowMap（在BasePass中），一个是ShadowVolume（在PostPass前）最终调用SetupMeshDrawCommandsForShadowDepth，DispatchPassSetup生成对应的MeshDrawCommands是ShadowMap的部分。</p><p>因为要生成MeshDrawCommands，所以要先申请UniformBuffer。</p><p>调用SetupMeshDrawCommandsForShadowDepth生成MeshDrawCommands。</p><p>SetupMeshDrawCommandsForProjectionStenciling（TODO）</p><h2 id="Render-Shadow-Depth"><a href="#Render-Shadow-Depth" class="headerlink" title="Render Shadow Depth"></a>Render Shadow Depth</h2><p>第一步完成收集阴影信息后，开始对阴影进行渲染。</p><p>入口在RenderShadowDepthMaps，会对上面生成的所有shadowdepthtargets进行处理，以第一个图集为例子：FSceneRenderer::RenderShadowDepthMapAtlases(RHICmdList);</p><p>先beginrenderpass，这样会cacherendertarget，后面在applyrendertarget的时候可以直接用前面的，这样可以让多个阴影都渲在一个图上。</p><p>入口在FProjectedShadowInfo::RenderDepth，</p><ol><li>首先更新UniformBuffer</li><li>设置drawstate（包括blend depth stencil</li><li>前面提到的cachemode，如果是只画move primitive，那么先copy之前的static primitive到shadowmap上，不用重复绘制。</li><li>dispatch draw，执行渲染提交。</li></ol><h2 id="Apply-Shadow-Depth"><a href="#Apply-Shadow-Depth" class="headerlink" title="Apply Shadow Depth"></a>Apply Shadow Depth</h2><p>根据第二步渲染得到的阴影贴图，把他们应用在物体上，完成最终效果渲染。</p><p>以方向光举例，Shadow贴图会在SetupMobileDirectionalLightUniformParameters随光照一起传入UniformBuffer，然后在BasePass中通过PCF读取阴影贴图，和Color进行混合。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.unrealengine.com/zh-CN/blog/chn-unreal-engine-4-light-and-shadow">https://www.unrealengine.com/zh-CN/blog/chn-unreal-engine-4-light-and-shadow</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UE Slate</title>
      <link href="/2024/08/28/UESlate/"/>
      <url>/2024/08/28/UESlate/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码看起来不对哦。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="e94b170388bf6a597954944068417e9046051ded04bcbf5076fbd8989e7191c4">661226a2b75cb52a126e6a4e2c900cbb2dc9d25081b96db865748d0412610f3103b0d90eff0403111a111a351534da09e48cf30f19469bc6e5dab6a34f293bcfe879bf88dd61090e1c9c4fe9cba188bce8548676ce0a1f411c40e0f9c4074e91867b8aba25b7a54e293e940bbe4833aec160c371cd8957915b44cada73d09821b122b29a5a55e856b0478bb56ddc54ffd0e4082208e4f2ed53e93aa9affe27da3c8851c0b78fecf27c6f9cfa692b1b1f924f50fa5249c12a0e7eca9d1b2fa23ef68875eb51564e05162ec2006f0a19ca984d88734b3fd5524f974cce464c9163b2d44fd4343cb98c69348a82b163ce0071278308478084a2ecc614d6a3abcfccb2a273da36673a237f357d9ad9010bd3277fd01c5f79dfae26a92d8345e1b25eab6979d1252cdde4a4fc4fd4ad2ecca40f5b8d763d9c636025be8a39ed5f2bec170cfc490792adcabf95b3e56a6b12f25e555266b1d16ada1ec12984e4ec1592276222a527ee8aa7cdaa45735c279f9efa6a34771449e305e89ffdff1985229b04ede991be55e14f49c4699704fff855d34b9b24eaafc5fef709d237a3c004df17ce2a1d01247b54b816ecc4a05e51c0f58218bed01fa89905c9b0d5581510cd60f876b07a34bc196c36612066e9546f60589d899e61e73dafa7caa3d372204b5ef6a44b8b1c11adec6869ebde861ef298200ef6c034643cb4e55426ad6e14233169e71c584e76d858455f23ec1be7a407efdae47e47d1964cd02d02b0faa60024f63f92819fa6496f4b5d409cfb3003701aa62a1d4ba27ccfbdd581be7f669422b0a8acb50782332ac5d899baf91ed95cd94c7333bfa50de823bfd015a7c9e7a4f6be1f683d56799623c407ac54af5504ead08453e5866f781a018d6aee6bdf211c2aefdf73c8ba9ae7a49f6f0c750b5de40ae746fee564130e8169116a5fd187e271fcc130151a8f182d34738160407b063fe15bf0f8b304d8291275b018a531363422e16b4cda149645a6bfdef8278435de143c4469a2af72d49b675d5d1d59c1d8e51f7e9a282837f4a8c16d3dc38cca8ab1ba57f093fc91162a032d494cc9f52925512abca06ec7b5117a11b786e1c14b16c5cf296095b50e49815cbe3797a9d31bc13509b1450cf08c0add87852facc7de4f25117499f639a31a022f703b2beb097ca8211e481fff987221315e4a1d7cc0569700f5b45a1f5c0dd3897e2280073360907025ca017fe2199e41bfe80143dc95688933ffea101125a5aab1b5292f23768f3225566f4e24a2b0e8a00c63cd9c1119c18198e701757a4d3cbe30f433d6ee3abe76f982369403a21a1864d33998eea696216ddfaac7746d79f04685b468d87b35aa8570c80337cd93ec20c10f733f71cade6a95ffe6e19f9d1540a616a966e354f872ca506ab78e655474101dd75950ef072b683bafc5abf7b5131b6b692a76f6dffb025272f16991c47271616f46ce5a5cac987e9bbffe6ef16a2d40d6c9327095015d00518f7c6d1972d966fa2d4cd924e8449bf0b11db1640669c3861b2e3c8d95c72bac8580e2dbdc37bed95e18eacc61c9777708a810730c3d7a94dc311633c93661f66a44bc2559b95991dc80d928b9bb4ffc791ef107e7cbc531a2b2b0e943540a346ecec799491d364547f5934d9309f0d5f30e5172982399b0630140be7c8d1cc59e675d2293a8b009d4dca6f26842c5f88d6892aa6566eea4f6516cb6ad81ceb17aba07386f7274035f06df4beb8e06bec331bc6db702d018d85fed5a50e2e8b70bf1adfd2988e8360fb9c59a56049ff158c30f7b102c4aaccc7f9f8e14cea1dfc8917b7d772ad57fbd0913477f37165ad268080bb425503d5dc7eda2d366c8b803ffd74326645d9e225ff50fd5dedbde1b131cb3c5f6abf5c2c876a7a937ed4b4bcaf480551fc0f5084ba9560dcb9c29bee649133124f12ef469d4c27c65cae112e65350cea79453b033e43728c4e16af64d60b5fb05df2c0eaaa3b9d914066f50b128a4a34a8cb308b7df08f7a5eecbe24a5d707e0482480d31a620e5687480f3d2212f2ad390338e6c63f05a816013eddb3cb66d63c992726945adc2539f5021728f048d946a4817a7dbe6e59169ed4f72ab4b8ccf24a9ae655d0355f3ad7fe971e91e35db13d98180d757248dd0139980ffed0f36b196621d51f9de5714b5e029534413a4e33b4a1d8871a0e63c8f6fbbf5a09a2445808bc1f3d3b8b410e042297edac91c85b6a302ea1a26df4955c716a8464cd78542219ad58887da577878adb726ba732a18bfb4f124ec7fb6e3e787dfd26869d2932a35689201c19bb8e9879352c5adec384fed3a5be5190a94c89a02c7169cd1bfc53225aac937ac9a425e0c6e0be0328b3a238f845a63e52df445058e565aed93266c91b0c0f12102f5c59e1a2897ddae979841a47ac39ee234998fc1f48d9bf0c958d634435e23d3100fa97c13859754bc48d43354478604b45f21a0cc2c013d4768a0c7ff8a73d5bea54a9fb6b600fc30b88df698734715fbaa41c5b818f54e42aa0a69a3a432ad116344a1e715dcd93afaecee97c7136c60a0f4e5a15c596f565f519cca804780ae80e642fd3a90ef48dbcd8f410a74fef29ec35e77eb0225efaa80669fec95aabe5b09ec46faa3dda9772c5785077cd02b1613ace0ba20ef1a15bf8f1bcac3fedf86ea3eda3752a10addb27f9c2150d17b2b9feddec40d74ac49a0c9bf21541e51bc11e3d4c23e463ec800231e368979833b43d934222a1540fe8d0730009d75393c0e7c58a9f819c3667f0e55489796d32d05d2b66b9231cdd87d4fea2c5ca1ccb0a6951bdce51b1b82a29591f877a1f2630bd6acf15bd07e16e1021900d3d1b540b8ab466bdbd6ef7bf5ad4906a7e1169b853e113994fc1fb93b6f10543c93bb4c47ee86b3e98054984275fa59c8eff53f6dd01825ba7d2912c54ce8cb0e26603b440bc1816664b66ac1af14c7ead10d90bebe71225c5c98e47f1e968c6d243981661f4d8335ddcdbeed7a3c25e751130db51bee6553b605f669f2ba7d1ca72fa51e5eb78aab5adbdb512d16b0d2107e2592e8cdbce577f59df5d528f49df8a76bb0970bbf83768118dad14509beedee646b712493ec6074a93505df7a3c2302b8cc042e7a1c9024bd7563d098762ea2cfe7459d16c43a2bf52f8b7f22732da8b9bfbb7115dc3c55e10e8d6cb83ac5bbf4e2f00eb550ef9632e08e86b8d92702215566c923a534afbdc51f63ab778d0578948e5de9ac1d16426a0b6097a96bba3f91a1dd20494e4c7cd500de939e11c8940811290e5cbd115283acceb94cbd447bf2f67459673a55a5de5f843933f5b7f4a6dabc2b27b3203dd28cc0814b8c7d1084ce7cbd096b0b877bd67339e94831a8d2f4ad252d279fbde3e8a15e179afb697344837ddb4911c5ee7c4e700ea20499ca03b33c52271148020e5adda7a71e798ad1d496887863593f5a03e948ca9af457cc40140c48f38f820590bc04ff7ccc7e6fe515fbfc9534813484c398618c80554d047e41288f9603d92560ae622e58e04ecdcb4a9cbb5e04e9498f086e904377cd47cc37fa97fea1f5195795dc1edc1d44788a400a60ef8f1688ad8d858b216c2d6950445460a0d297c4555e0a7c663e3e27f43439898623477cdf36d5fb5db53e00e4a759d329c17d099e52b941ae3700a51b6f0c5f56b6b5649173d2ca5b374c6e39c4f63094876d5508c743d1b1d8880215b43275d9d578668a56ba35d4f6d35429d6924864b0dbb5dd7d40579aae47cbb612d862e73f05fb0f93dd9a2c3b80c8ad17e36e64a4da4dd0fef62dc1ec0646c52fc7373eb34a17b1269278a19507d8f978bc502eca486fbdfc5e44cf1e4cf87a2b8e0498197411843b99c52305e510da9545d5cfff58e8c86a7aa0302f9388085d2f760c323aab5ce6e18bf37e0c01b841230b42f566ef020f2de9d0489cdb56a991773004ee6f60825a0468272338fa1f7ac03df9a62074c9527936aee0230681edb937e4c8e688225e64cdfca5970f00e302f331963d723d962bd72845fe1b1e6999dc4fa5e7ab95a29ffda49039edc0366f29e43a5509b45bd0ecb828f166572e8e5976cd294e6895fe50b3e9cc17dca8a8004c4e25a504fd39200b63180f656ef10568e80c888acc6e7991273f3248ef0832e018704de88e511ea3911e9233d3af8a7dc97d46e8a72f95cc004499c91d4303b171ef6ff53fe7eb824b0f183e9fa39cc57ff01ce17b9a1a368497948207548cb4257174b8540cf11ef952f88bfb20f0b9cdd581c652e22ec23af8e0c0ba65b727f3a3be8fee2c5bc8a4497b7992fd3c7bbd67c391abe9be086a075416c036c72be66dbec661960fb7a112b399d19f4b553b63a229d062b6ca85f4a33b94025eb586da0f20b7b380d0edf32689a5bf1b10b38c37e95b4577536a91b63d904d5e317c7164318917de4c6b74f0a00f8af7462fcf372f0617b71d5a307ec08db72697c0f0d65c4c08df5eafa3b0d5b837eb702218872d416aff5eb5999055c620ab60759f92d998c08aba8e712f43b479e77f5c540353d7540e0fee2eb9e75c732d365fd412473387f7be6bef63ccf3bedb93044b682a52f30811aa75a96a710943692793901379884f251561df184935a2d064ba266d0b850e6a2ee2037c725022d9665d8f7eed9f45b5ade1384e463e715a9dd869e409a57eb96a77cae70d403b7707c3f6323332b1e06b7abe6478ac41371a071a71c0eec5d7f635dd10a274365b6a37beda183cda3ac140d249ce95748739d0f11b2ae865d340c2e7fcb2a9e8884fa0dbf2dbc180a1ec2654430329f067478fe10227e6be2f645734339c874fa0929e33fee20d4157fa65d8e492beefda89ef243f1551f2e25ad58269d56940578988891ad2f6b3692062595ad2bc9c338c0823d5c460ea4d98df316f6369a26ccfb044f6e607e48ab01655f89fa059713d586784141bae2aff320568311a40e115905aa89d326bd6312f9b73b5d4b7f3f5bdb6305bef814956e57940e41e7027731d5705274f3ea4e31e442f2ff51be984c3d0180646ae2fbaaf1ff837e77b11c2c93cfe990ff69259bcc0dc37ad5b071d6b1be12d3c02002690002f1862ce5d0d0b75dc11935b7c975d54785581852b5643882ab4a5bb304f79d180684b3ce5c81f4158af9546e5875350719d7a6df2de9a8e08d39c42489dcdab0430e6a72a61f5efbb085a699f2d7ab43528607926589dcd61297d0fa87ae7969052fa46e3d5c5a8d5e901fde70ea2987895e1a4aafa10e30cd21a8199796a81f06809794f05e3fee441190c0b364b2f14e9c656417d24e4a4eb29e883a490d5aae4da3154fbb06e0be59793aa021f865da2f01a6f973be1885e5c334ea8a6111e7c07d7c6a814376f439cba3f6220c67ebf0ee770402905861ae495e380ae9745ebd1de84f3e88388811cefaee3ed7005f510df887f6541043335783dcc98ba7b767fd555b9d4c4870309631bd5d124f6873def6fe9dd457bac3e5025df644869a1fbb6f3ef8dc9fdbd3ff074b53ce121724795cae0c5d15d84c014615603d236ab73e9746b4fcc203582d713dc0197aa7a88e5604bd5f07c208ae5b606872a5640ffa87fee1226bdadc24cc2384285dc6c8f7e5b54b340f64ea634ceca9abac38add836c02f85638d5bb45a4a6d718dafb9df74dc2cadb7fd4a30a8c5a8e1352e94f64047e9b7888f8aded9314de2d92e0539616fd245c651fcaca9fb3af6277da9e7b4651db3a9cc5acb3adf9af964e8d171fa1e8e1a7d75ce54f3691a67eb48f52cfa08816cc4b63a760415a5b853d86cb75f0e8ece4c5cd6db1070410c1de135fb3f9e3394d9bde1c458ccb5e9fab8adaac3fcdde7518e3b0280c9f3b4c167b112e8b90d6e2afeb6abae10387696f2f10b71e30ca55cb3f787e7c99c3779fcd6eea135a1c5d66052aa250415b8b338fc19b8eb80d7b34cc86a57297a5356e448cad4513b720ee4647aec10521075e1f0c7e83f6b7120f027e7a858881417bb7110ebbb2432488bc229a99be9f0d01837bafbc18c8b446f2ad853b900cdc21d8d22f7c5872444fd74209321ebaa2a8f915958996e4528247c9fbd50255e2dde547990808f46c01444e417e82bad0a9992f00237f280f15cb72f17ab59ef9631d363676799b6eb09295ff1e4aa6c8caedd1a695c57486f48a6e936b8f5dbf6289d848d3c357bd013d2a2c20d37efeba6321524af39239f68c9118c4002b2738c5c6e2ae21f1f156622ddfa3c11e592772147053199d305c6cf5cee902ec4ab3642444f67f9ed78b3403896bf84efeac2675a3c44970c3ec9b19331b8dd532db82eaf311f87adf1601ade8dfbb370a42e9c24134572a8993cbd6160e9486b67d1f7a60154371c5764bff96ab0197e3db20612d24662611b4d75f8465a53134b0d9e4d1e231fff287d51620d74d3f00b6859fd65b864cb50fa5fd8437f6cbab0a75e47245d2ebbdafb7f982d6df66687df062f4c3e2617b455d7bc5755617b74f4228b56404f80a438fad0bfd753e3a21146d880a50008c8c5c6d6844a62b89be61a8280889cf8ec10c24d97ab372af7129ac858d298eac5e3ea8d34de029bc5587b5d02f27826a4a461e087774110ed891523a057e77f17cb63501086678b96ddfd03e8bb52d1e122c9b564840a0cd6cc14ccb1b7d99e1a25027d48af1eb8a7fb4cb05f33c80d5569d1fc2a11acc1458eacaa0ef5545aeea7c8b70bca3ed75037353679ea97523851ae5d848c41ff93352fcf8508e6e671115f4da99cdc875edc94653ecfb9bdc17daca09231936c6c0a6bcdcf8e8056e37794b7bb20585fb58f28ca05f0eb6d7097d18c7a58dcdffff905aaaf1f3a63bd66d1883aa6ed0e94bbda67ac1fe61ace9cc0b026a6f0f7453f4ef45d15c6f6360762d13a2e5ebb98819f5d54624a5a29e962299e9decb3ef1ffbb5467c219a184bd055a445d6e9ea8e61f192b8b89c6bc5479c00d2f58b2951b472a7490f15115383bf7ea06e337ee8504b32639083fe923021b80a47fa7588b7d6247b30e18cf79f4d746d44cf08ac44df9b9cefb04f24547291c3d26ec9b9d44663fa359e646a8886345c78133e814c1cb73fe3427f0e8c8ab5f98a116f424d66b06cd0eb246398b179788ed33bda999d308a680f748e54bd88b5f5bdf2774b87dca3e50f5acf74a48432be0ce7ff82f7a34079d6b80f2ed739aee3b759bca183c65dd5a40510225fcc3f12a93af8a043fe536084e10b7f035933fd80e176f018f5b55bc8cca7ce9657c32c944c6edd295abce361197cb4e784469b71f3a05879c7b79a349df8bb5f115547266363ca69f8920d8839c88c3d75b54ddb8214dc58a0a191b9aba3d7a44845fe1304fc210dddb7093d43cc4e266495b3dcf2ac8717619c6055323f96fa401851bee0ea9c920a338e6415dc37a4837f995f5778369cb28cb57db78856b03d5595ccd00c7f87f8531fb3d3a54a2ba5e21293b53e7dce7c24b2d5b2e2c15e83bb42c01b6cedac82f0e94e0a623037716542160cf988ee56b62f53ce9051d0f3cef8cf9ba2e2fa05bd07cf8f947107dcb9ef612a7c3572673552a0e0a7c6d98c95bbf395812b3a39a64f346fe5575028300365bf62f04f62719371cb3e823d392eee9a4f2ddc5efae9e402237f37fce78dfebd18a523ac3a67f8f54172d49828111409eb2c49f0473a93f152c76a34209f6e1471757a39df6e00d2dc623ece628c347a83cf3b78abe7998d6cf14e7cf728414c90b6b6fcd18b9dea37748b775adb025889b8ef0721313261e3f22e36f28d22ee45503ac551b8d8fe7f0dad59fc05bc7203c37e348b185d90885c4ec3aca1b988a38d1523df91d40bac379a28f78d0cc25faee134a0895ca9dd8e2770bcdf65d1c088aae46336e89bb3571b56676faff2c3e58986a55f0cde7340a6bcc830247b6cbe15af09ac0bfffa31a9bdf57647c737eb27ede8edcc77418f92e6cd8d113bd217e931b6815bc277731761eeb353eb20f546956faec59f7800841263bd60c093d143c50d6a9b402264a93455c79bab7351d3b8604a68c42b2706e0f2d3f55708ad8063cb38f58092721e154416ed4e2afccda560e41ea79362ca56946f3e988f43bc70489fcbbd45a2320f87002e1affa3e791aba0051b0a26eed2e7594be4e91b0516105920955efdd725d4619ddd8e6860fe27ae4cc857892044f6ce2f738c1053aac57e3c1922565568c34570ee4497adc8c89064938597e164e82bff3971b7c16164646776956e3c46e979fbd4c4aaa9beb86b6a7c08175058ccf81d0ba39d7a5f9e9ef38854742d8796d2d737815a2f06aa9ca5d32998fc6b1226c42129d1b442851bc22b189a267d3f007c856ea6c872fbd964c9f3246e204201a559c18cdbbbd256326eabbf0fb25850ab4d42ffde1f4aa9a71e2ce3b514738831bf843f6376f2f78612acdee800912c1903db19129f9b4fb6e60c1c3a8b8a43136ed844a2e22909bea6d756c3ae91018c31c05d57cd557dce6d660191d8757bf91a128583eddfaf2e2420411bfaf9fdb6d08405b17941e33a079e956ff8591242b224bf35980cf4c43522c22920ccdf58c4be4902960743d0e22dd721b8b759815f069b0dd2e7c8486b5a053ea71534fa113a9a71d9290e66912528cb564bd8a0798edc3dc19ea709985e3bb2ca539ebdf08b28987e2e1c59473ccad78c13aa8fa1a7ed872b3f4ba00641495f03aab0c5f1c62f0e2ad8281447fabb095807961a2385cb50cb97ca678e7a66a9f189acaf7dc728ef9f32a7e5d445e31f125c0bce539eead87e7874ab765d9daf3ca900a369e06b9c073e1e187cc17e4c5be60ee8ec74eea554e88db06bdaadb4bdfe7799202cbd18b5e8399474787f3c9e120602323c43797b9c5b5ec59468685118260c595cb85aac20519035d158026b894ca41484fe177c635f860ba852bef4291e083ef3f4eb612626bc0c2e26a152fd8f8aa04a178e4675bb3ed1bebd5b2042f44167614c2478d0ac6b4dd6291a89b162755fd8d2e1cf6c2164c94bbbcbd72a932b0ac466abbea5ebbf71fa2953b3fbe69a144ae15e460b81e8542c37066a92b3d4faa474f42d67589df19aec1609a3d2c6d6c22115ae61a91dca4b4c755e11dafc35f300e8ddf71d83b25d1a5f42c7717ca21f6c29d38b63fd0d24286e9458aa63f6f782c7f831381549269f16f87825cc978ebd4a8f01cfdbee660c1608b43b231f33f004ac68611c1b9a3c3f58b183f974a6b1f90d7e30bf462ddc54b78bebbe7a9e45f5209b0fadb480d445160e0af4b24bdef4f089f5241ce225a6bfdfcf2f334a39ec5e1f1d664c4e80712c6ca50ef4d1cfdf3a34c47521c545d5507d2fbe529641daa9d09540a415d3fca2c2d9b86b7718f49c16f319162f8fdbfa6773cc0e65ff17e62140cde0122ca061cbc747c921b1a89dce27a591146022a4e57239aff3ced817dff17017bbf62585e5f80560dfeb9c67764be12b6ec60f0cc37d0d24041a4737a5627062d2a19ba4e72a8b075b1a24ad0aa645f44c287c13430e4ddb2b007adc50a7a9296dce9873c9682ce5dc944ccf3576efe160a4748f2010e75d0cfcd283c638c60ca28dc31c50df67eb715394e0575cd8521fdf7c22693eac89ae58f2c2a7b81fade1958b8e983cb4f84da86671ba849f72aeed158804afa45126d73a50904451cd0a4a29246963c72da421291374a6af4d6c06e57d8cb82e7fe456976919f41ecb9755afc13b40e458a39001fc96e5885fda9a10c80695ee7cb2f78506fd54ff2c67994eb6b2fd909e50c252a9d65c4f1f6ce2881c8c2ec00bfc939f9e14608dd842e17837e9721f38030ef671058296e01f85683c1beeee7836c5996ca6a8b4aa0ca937a2b1b5a8c12bdce2b80dc7afd44329576f6ee4ef56d42ec11e75af0f623f63fd778ecd0e068227be437fadd9cd49981d98db6ff89c46a8f7c95a35bdf5a413be345f29e381f9295bf879a3f8500a7c6308f3d31c7069da2b7751082e4b896a7594ad843cde1a1e9dcecf05b7d4bcc606cfbb46840657e52817ab69eedb1f533865af7dafd358cdc8fa33487d3a71e8babf1ebde3684959c2ba1f0917c99b7a768478bb6861c3a7201453be65cfefbeb527becfd1c53e01dfe6c34c46eb45406c1af33dc0ceafc8977fba1c9366da8178c83935835aaa0640cd732c4556b49cff570c988d367b0e20fdbc2cb1b70fdc51626ec31044ce93020a84959f2d8d26ec55428a85a01f9a59fca2b5869660c5e4164f57735a24af62f3a67f989daf943245c6d22608649f57187f9aa1564a9a69333012acb25009b983a1e90d759ed84fff68995ab47996eda73d4ed67770401ad3add51943540f253edc5678fc528e5069d5ef24182ef49a15181830240ab3107f1d367a2e50c0f1111242c2f8be58130ca321aaa9dc68eb4ecc4fbf705760de252bb46edef9a0fb7db76ac44961dc014f1c1b2c0fe70be1e718fd0bbe581d532c7bdbeb70bc41be36bd4d7ba9bc3bf03095cc7ec0040a1d3fa3c688e10256c43a5bf70155ba517eb2654af22b6a1fb024abde2ff7eb0ce3c1fba4d1cc5d9b7d391eb2540b4ee4aa6d055430c2542de6e5465019bc0dbb4fc6fecc1428aa54bae2351f26663dfba7793959e7d017ad0590d4f46b9a6ecaebeceb3dc8d43d3330bfecfa25dc2a4cacf18edc15a8f9fbd6526b1e0f32746c4800b51915925ff51b5cc22e2022cb309402498ccd0fbfa839624de8aa3962fc8a0bc88b4addb6b297c7484e89eb7baf5454c7504147187b64cabef2d1b332e897ab95922440126b3c74e8f11bf85770a64dda65bfa4799abe321faf95a08c47f4efc975eba477e0e3c584188802af24c4eba23c8d35aea057fe52144155eea85be3eab4d0370e5f41be6fd8c256e40f070ae78c0d435cdb2975ee3c50225fda0368e9c4c08c60efa03707ea2836eb27d5b10212185d391ec5c57cd01a1e76f9657c638ea08dc84284ee48ff633aa15f052572a426aa2b337443924d3ee9b6b244c70a9e16e37f01a9776e6ac80c737be766c8df521739ac9a864bbf5bc0d8acdc1d8700d42e531261d89ce42dd8c1011050e9f292cc396fd75dc3a072c7a5b9f3970c04686f024a73ff30ed79319544a48803a24b09af284bd82213c787c19052bc6bbaabab174bb39c2b86c52bd113799d99ddd15bce451a42a094966e75a0e38b9768f673712a5276e090ccef3a787f662bdcc5d3d80afc9ce3dc715b08ac6cf49bf231fba471a65862ef0527677a6474080596003ad01eaeaec022e09404ce4b89d1f5a7d93aa0bf1e314f9711677125b38960bd070d6d241427f9e74f246667259b87d78d59282938d7ae7956c51c336fdbe888b4191c653d19f46ec65fef133647face9a7bd51ca893d7fd780211db09aae1a7c2bbee7541512ad2679991371b661b7aaea5a332e3a16750e688f93da7198f7071f1c5b0d11ce96a7b107f664979495705330acc9f427545ba1cd526f5942aebf025134f00db9cb257dca6f8228aa0b5ccec62da5c9731ab8072def06f119227179bb50ff25c95fa5ede8c98367abd8751b5876bd3a8c35f7c0712d1ff55d6e9ed99fe841b5ed1b4a2d44d743ef526e6997667a1f9e950313934f4b71d9a713dd80acd6f1ccb1a918442885ded847798fe684b6938a4de12a19a3d9452224cc43acf7ea17abe0a61ff200740f8c3a8ef4a99a70314d0988399b4c1d836b42c57c9d5c55d47ed46f4feb1a5db2b4877719dc9712fe50a657b6b34e61d9ffb17749c13ecf47933424f331597379a2d130f4a3819d03cf2cf8af9f3bc94da2c50ad88e4f636fdd62b518088228fac98978da8af8e3eeed3e11dc01f318cab268d9f2b8fd22486de2562480be566912ba7a6e6005577e85599bb0b043ec056b7e0878b158d8ac6032d396b40d98f0ec86e6e688bedb0913f22e7cbfe2cb03a9fe1151d55a023e7573617e3c390b30dc1105052e4fae20ee7438b7279adcb4c1f7a78cbba488950825e17e001e2c258814a3b273f7fcc3750fbff0ebeb9f3a86900986a3d251f55078bf868ea2098eec3f182f5127698de3d0ec0d396eb3c65a52b277a6ccd4c46e4b3f4237cbabfaf40cb21221a6c34e0bd3d94ae9d56ecf9f4132adf5cd9e4955871c443bcb69ab7b504f9c674fc447eec96e83e7beae9c3262750da5e925095c53df900a2ba0de769e39d377424cacaf773ed238eda20ba9af346d33e62d7276b191471d3accd1be08383ae4be06318fb6cd7a42b89ea39eeda8dd92224d602d9c2d677600e126e0b6e47949f88dcfffe20cda8e37666feb9b5cdcadd06c6f2b32c4f3d57ecafd958ee329361158f0eff63026aa4559207eaef220a4faf96a17ecae56cf05bc78b40d107bc6edf823de1775c628376004563f5e11d2366df45908938ca948d88be8a71aaeaa81be517697b90b1a550b4649780f5c7539f6badb28718db14aaf3e44f029e91d5d61d6078df4812cf37579978534cf442fb292dca66727d8ef0262ceb80af9764254839f877c2eada713395eee973f0e434e71b94cb2a717122eefc7727206aadb7d70f0bcc87ff84488bf2d6b27dfe619f4e08277a6b59a5cab9b633d78caea80c7ac9ffc22ba2d7b1ccd05e668a3512aab533589b53ae2a0c9c5803338998b0a5cad069aabc14d92f4778740dbace2854cdcd7b2b0592fdf8ab322c798c9960439aada789567cf8d44e09cf2ab867ed7e897903d5a11014f83b0e8ab453ff34dab80fe45642da5c480707b30b931cb59235a0732dd4e56d981cfa98e2bf402bcb4d0f127f54e71f42716c1e8c1ead3e862831ec4ac773fb039423b80eeeb5af7b16fdf15b95a97d8c68a3625ec8683dec49b4acea47cb2b6aa1953c328ad32611ac0cd8150aec9dd06a1fafaa08f0198e80d53b2eec55bc3e3f35f2e52ff634f21132df7eb80710c56542bbfa42ad0dc0a806ecc5b52ebd8d2b88993fc49cfb678f0183320648f86e341c258d2663932951f80e9a12597202e5fa6aa1d55fa11b9d570c30dbb80f9aa907b607eeddf7dca6bf288774a805cb537634109f9c666d5f90078eeb642cf5ec953e79722697718c6c7c22fe8965297391c972635f212b8517d94e7a913a7470e028fcc4d6502019e53794a6a19c73a84ad3e70e2ece8d1a25540a2c6ddd00e916f269311f6781efd2cec3c57e845104c3a8032affbab9e15e8893b71b1811a9cd9144d9b4aa551ec8b91cec224cc5b650e74ead5d039866534054c197ff1456096815e8eb4ce14a53a624771844163f1d4281856e0159f1564d9106de6a92ed310b4af9fd9da053494162d7bc1f44f784c118f435a8c8c2c8cb4c2079f2dbb856fb6c2fb251b1bbddde9af258c63ea127849732df22ab7a95b8c4fa3e993ced229ae0f235cc77ef981e0ef9666eb657faa3f6ebbde5b1f22e40212baed28d75404450f271447ff52207ab13d7a1119911fd43ea57c9aff3c7c0e941319d4eb786017b844d2382786d86999fe5f6f10a68dd2ae409228ab087689b36744d1a4833e25453e757a8067f0e462d0221ff8014dfeec45229ef68581a45803e94a53ae51ff60b971359eeaf072db4735c2b86c8b4b8739554bc3ce72d1eaa5f4b3afcccc2969a0b388eef3070930b18a56f8df5587b5843a84fbf5428c5f70cc1af5d48719b31be948651b08984e11dd11816457579d02db50866b9608ef0ede343dc4f424a0c00ab2b8875c719ab5792ffa2d2aa3379dcba6e887a9d393175bae121ab9c62416ae4977e758f9e67454ab14e80cf048fbfa488d1d41687efa9a94dfb92914031019605d820284b4500ef85e7ff082f61a155d2b2bb1ac6d9dd33a818f427db39b3d0672896121b968f4d91e04723be96cb439eae8441f59b8cf32be0a7a48282b52b825cbc87c34689959d9f9bf2f8750f6e828f54f4c2fe3269dbefaed6fbc98bb9efc6e7a12e42840ac483bff83a9fea5a6394d6df16c4d51701857302d60612f4deded22249c2bff01e148178feb6577c6af489322655d6b3e9eb8fd7fd6721e3beb2384e67adb23704bebd4d074df131ffc3fc07500d32ffdc3b6b973e265817d4618968099fe765f96189efa4885222641fc6df13e2db43563b1332db2a424796cca122c1d9f674de30e229ead809e4f8562c3420fe6ce2badef6b242657ec2e0a29b4c4744aaffbce3753bd99c1d5f27f44d5af92d447a5dcd3f6dd5c8adc202769b548786c199c3d83201a96636c4b8ce817fc7ee47a11839bfcdb51da5d700f7e161549c09922bc02caaa69abe15a91f0b746a290c74cb3d159c6deee92a0be0596b04a949fee49e5f9225d90afd79661a89e85053da346ec163d4f2cc14a882fc3268720a20ca3b8c6edaa74a3b532070926</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">文章暂未公开哦，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HISM</title>
      <link href="/2024/07/28/HISM/"/>
      <url>/2024/07/28/HISM/</url>
      
        <content type="html"><![CDATA[<h1 id="HierarchicalInstancedStaticMeshComponent"><a href="#HierarchicalInstancedStaticMeshComponent" class="headerlink" title="HierarchicalInstancedStaticMeshComponent"></a>HierarchicalInstancedStaticMeshComponent</h1><p>​    InstancedStaticMesh是UE针对使用相同Material，但是具有不同transform的物体的优化方案，可以将这些物体在创建时静态合批，大量减少drawcall，而InstancedStaticMesh(后续简称ISM)存在以下缺点：</p><ol><li>所有的ISM都使用相同的LOD，导致远处的ISM也会被赋予高级别LOD，造成浪费。</li><li>一组ISM共享剔除，只要有一个ISM实例被绘制，那么这一组都会被绘制，剔除同理，也会造成浪费。</li></ol><p>​    因此又衍生出了HISM，可以针对一组ISM生成对应的N叉树，便于空间管理，在生成meshbatch的时候根据可见性剔除不必要的子节点，避免造成浪费。</p><span id="more"></span><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>HISM中有两个关键成员，用来保存每个Instance Transform的PerInstanceSMData，用来空间管理Instance的ClusterTreePtr。</p><h2 id="HISM-空间管理"><a href="#HISM-空间管理" class="headerlink" title="HISM 空间管理"></a>HISM 空间管理</h2><p>​    通常我们一般用八叉树来进行空间管理，这样既直观，而且算法上也便于理解，如下图：<img src="/2024/07/28/HISM/eightbranchtree.png" alt="空间八叉树" style="zoom: 50%;"></p><p>​    然而HISM采用N叉树来进行空间划分，这样的好处是空间划分更加灵活，剔除更加高效，缺点是不那么直观。下面我们看下HISM是如何构建N叉树的：</p><h3 id="N叉树构建"><a href="#N叉树构建" class="headerlink" title="N叉树构建"></a>N叉树构建</h3><p>​    HISM的构建入口在BuildTree，借助了FClusterBuilder类来实现真正的构建，构建大体分为以下几步：</p><ol><li>初始化Builder以及N叉树的预设值。</li><li>构建底层叶子节点。</li><li>搭建N叉树结构。</li></ol><h4 id="1-初始化构建参数"><a href="#1-初始化构建参数" class="headerlink" title="1. 初始化构建参数"></a>1. 初始化构建参数</h4><p>​    MaxInstancesPerLeaf：N叉树每个叶子节点最多包含的Instance个数，初始化值为8192/该Mesh LOD0下的顶点数，所以Mesh越复杂，MaxInstancesPerLeaf越小，叶子节点划分越细。</p><p>​    InternalNodeBranchingFactor：N叉树叶子的分支系数，默认是16，每个节点最多有多少个子节点</p><h4 id="2-构建子节点"><a href="#2-构建子节点" class="headerlink" title="2.构建子节点"></a>2.构建子节点</h4><p>​    对所有的Instance进行递归二分，二分规则是根据所有节点的坐标，对当前范围所有节点所形成的包围盒的长轴进行二分，然后不断递归，直至当前二分Instance的个数小于BranchingFactor结束。<br>​    如下图所示，在一个立方体内随机生成50个Instance，每次二分会根据当前所在空间最长轴将Instanec进行划分，直到当前空间内包含的Instance个数小于BranchingFactor，最终生成M个包含若干个Instance的ClusterNode，可以看出每个ClusterNode所分配的空间与空间内包含Instance的密度有关。</p><p>举例：如果有50个Instance，那么根据节点所在空间密度，划分为以下几个子节点：<br>    [0,10] [11,25] [26,35] [36,40] [41,50]</p><p>这些节点会作为N叉树构建的叶子节点</p><p><img src="/2024/07/28/HISM/Nbranchtree.png" alt="HISM的空间不断划分"></p><ol><li><h4 id="构建树结构"><a href="#构建树结构" class="headerlink" title="构建树结构"></a>构建树结构</h4></li></ol><p>​        根据第二步得到的叶子节点，再进行split递归算法，每一次split，都会向上生成一层父节点，直到生成根节点为止，而split的算法本质上就是进行递归归化，不断的将一个空间内的节点按照空间位置进行划分，合并成新的节点。</p><p><img src="/2024/07/28/HISM/Ntree.png" alt="构建N叉树"></p><p>需要注意的是，每个HISM实例是按照顺序PerInstanceSMData数组中，但是排序下标不会按照空间划分好的顺序，上图中可以看出每个节点包含的实例index都是连续的切从大到小的，这是由split算法决定的，且在构建树结构的过程中，需要不断更新索引值，但是不会修改PerInstanceSMData原有数据的位置，最终Builder会输出SortedInstances来重定向tree中实例的index-&gt;数组中真正的下标index。</p><p>在下面接口的调用中可以看出用了remapping</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GatherInstanceTransformsInArea</span><span class="params">(<span class="type">const</span> UHierarchicalInstancedStaticMeshComponent&amp; Component, <span class="type">const</span> FBox&amp; AreaBox, int32 Child, TArray&lt;FTransform&gt;&amp; InstanceData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> TArray&lt;FClusterNode&gt;&amp; ClusterTree = *Component.ClusterTreePtr;</span><br><span class="line">    <span class="keyword">if</span> (ClusterTree.<span class="built_in">Num</span>())</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="type">const</span> FClusterNode&amp; ChildNode = ClusterTree[Child];</span><br><span class="line">       <span class="type">const</span> FBox WorldNodeBox = <span class="built_in">FBox</span>(ChildNode.BoundMin, ChildNode.BoundMax).<span class="built_in">TransformBy</span>(Component.<span class="built_in">GetComponentTransform</span>());</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">if</span> (AreaBox.<span class="built_in">Intersect</span>(WorldNodeBox))</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">if</span> (ChildNode.FirstChild &lt; <span class="number">0</span> || AreaBox.<span class="built_in">IsInside</span>(WorldNodeBox))</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="comment">// Unfortunately ordering of PerInstanceSMData does not match ordering of cluster tree, so we have to use remaping</span></span><br><span class="line">             <span class="comment">//重定向到数组中的index</span></span><br><span class="line">              <span class="type">const</span> <span class="type">bool</span> bUseRemaping = Component.SortedInstances.<span class="built_in">Num</span>() &gt; <span class="number">0</span>;</span><br><span class="line">          </span><br><span class="line">             <span class="comment">// In case there no more subdivision or node is completely encapsulated by a area box</span></span><br><span class="line">             <span class="comment">// add all instances to the result</span></span><br><span class="line">             <span class="keyword">for</span> (int32 i = ChildNode.FirstInstance; i &lt;= ChildNode.LastInstance; ++i)</span><br><span class="line">             &#123;</span><br><span class="line">                int32 SortedIdx = bUseRemaping ? Component.SortedInstances[i] : i;</span><br><span class="line">             &#125;</span><br><span class="line">              <span class="comment">//...</span></span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终Builder输出了一个FClusterTree结构体，并赋值给HISM对应的成员。</p><p>N叉树构建好了，接下来就是如何根据空间结构进行裁剪，然后进行合批。</p><h3 id="可见性剔除"><a href="#可见性剔除" class="headerlink" title="可见性剔除"></a>可见性剔除</h3><p>之前在渲染工作流的可见性篇中有提到所有动态相关性的物体生成Meshbatch都是通过GetDynamicMeshElements接口来的，HISM也不例外，而空间剔除就发生在这个时候，函数入口是FHierarchicalStaticMeshSceneProxy::Traverse，该算法主要是递归HISM的ClusterTree，如果父节点没有和视锥相交，那么子节点也同样不会相交，这样即可停止递归，如果该节点可见，那么需要判断节点的LOD是否不满足要求（是否满足最模糊LOD绘制，LOD0为最清晰，所以LOD越大，越模糊），通过CalcLOD，可以计算出当前节点绘制的LOD（原理是通过节点在屏幕上的绘制大小，得到绘制距离，与StaticMesh的LOD距离对比，得到匹配的LOD级数）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FHierarchicalStaticMeshSceneProxy::Traverse</span><span class="params">(<span class="type">const</span> FFoliageCullInstanceParams&amp; Params, int32 Index, int32 MinLOD, int32 MaxLOD, <span class="type">bool</span> bFullyContained)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FClusterNode&amp; Node = Params.Tree[Index];</span><br><span class="line">    <span class="comment">//该节点不相交，停止递归</span></span><br><span class="line">    <span class="keyword">if</span> (!bFullyContained)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">CullNode</span>&lt;TUseVector&gt;(Params, Node, bFullyContained))</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//判断LOD是否满足要求</span></span><br><span class="line">    <span class="keyword">if</span> (MinLOD != MaxLOD)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">CalcLOD</span>(MinLOD, MaxLOD, Node.BoundMin, Node.BoundMax, Params.ViewOriginInLocalZero, Params.ViewOriginInLocalOne, Params.LODPlanesMin, Params.LODPlanesMax);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (MinLOD &gt;= Params.LODs)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Index &gt;= Params.FirstOcclusionNode &amp;&amp; Index &lt;= Params.LastOcclusionNode)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">check</span>(Params.OcclusionResults != <span class="literal">NULL</span>);</span><br><span class="line">       <span class="type">const</span> TArray&lt;<span class="type">bool</span>&gt;&amp; OcclusionResultsArray = *Params.OcclusionResults;</span><br><span class="line">       <span class="keyword">if</span> (OcclusionResultsArray[Params.OcclusionResultsStart + Index - Params.FirstOcclusionNode])</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">INC_DWORD_STAT_BY</span>(STAT_OcclusionCulledFoliageInstances, <span class="number">1</span> + Node.LastInstance - Node.FirstInstance);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> bShouldGroup = Node.FirstChild &lt; <span class="number">0</span></span><br><span class="line">       || ((Node.LastInstance - Node.FirstInstance + <span class="number">1</span>) &lt; Params.MinInstancesToSplit[MinLOD]</span><br><span class="line">          &amp;&amp; <span class="built_in">CanGroup</span>(Node.BoundMin, Node.BoundMax, Params.ViewOriginInLocalZero, Params.ViewOriginInLocalOne, Params.LODPlanesMax[Params.LODs - <span class="number">1</span>]));</span><br><span class="line">    <span class="type">bool</span> bSplit = (!bFullyContained || MinLOD &lt; MaxLOD || Index &lt; Params.FirstOcclusionNode)</span><br><span class="line">       &amp;&amp; !bShouldGroup;</span><br><span class="line"><span class="comment">//节点不可分割时，把节点添加到结果中</span></span><br><span class="line">    <span class="keyword">if</span> (!bSplit)</span><br><span class="line">    &#123;</span><br><span class="line">       MaxLOD = FMath::<span class="built_in">Min</span>(MaxLOD, Params.LODs - <span class="number">1</span>);</span><br><span class="line">       Params.<span class="built_in">AddRun</span>(MinLOD, MaxLOD, Node);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归子节点</span></span><br><span class="line">    <span class="keyword">for</span> (int32 ChildIndex = Node.FirstChild; ChildIndex &lt;= Node.LastChild; ChildIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">Traverse</span>&lt;TUseVector&gt;(Params, ChildIndex, MinLOD, MaxLOD, bFullyContained);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">CalcLOD</span><span class="params">(int32&amp; InOutMinLOD, int32&amp; InOutMaxLOD, <span class="type">const</span> FVector&amp; BoundMin, <span class="type">const</span> FVector&amp; BoundMax, <span class="type">const</span> FVector&amp; ViewOriginInLocalZero, <span class="type">const</span> FVector&amp; ViewOriginInLocalOne, <span class="type">const</span> <span class="type">float</span> (&amp;LODPlanesMin)[MAX_STATIC_MESH_LODS], <span class="type">const</span> <span class="type">float</span> (&amp;LODPlanesMax)[MAX_STATIC_MESH_LODS])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (InOutMinLOD != InOutMaxLOD)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> FVector Center = (BoundMax + BoundMin) * <span class="number">0.5f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> DistCenterZero = FVector::<span class="built_in">Dist</span>(Center, ViewOriginInLocalZero);</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> DistCenterOne = FVector::<span class="built_in">Dist</span>(Center, ViewOriginInLocalOne);</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> HalfWidth = FVector::<span class="built_in">Dist</span>(BoundMax, BoundMin) * <span class="number">0.5f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> NearDot = FMath::<span class="built_in">Min</span>(DistCenterZero, DistCenterOne) - HalfWidth;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> FarDot = FMath::<span class="built_in">Max</span>(DistCenterZero, DistCenterOne) + HalfWidth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (InOutMaxLOD &gt; InOutMinLOD &amp;&amp; NearDot &gt; LODPlanesMax[InOutMinLOD])</span><br><span class="line">&#123;</span><br><span class="line">InOutMinLOD++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (InOutMaxLOD &gt; InOutMinLOD &amp;&amp; FarDot &lt; LODPlanesMin[InOutMaxLOD - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">InOutMaxLOD--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过可见性检查的节点会被添加到一个LOD数组中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> FORCEINLINE_DEBUGGABLE <span class="type">void</span> <span class="title">AddRun</span><span class="params">(TArray&lt;uint32, SceneRenderingAllocator&gt;&amp; Array, int32 FirstInstance, int32 LastInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Array.<span class="built_in">Num</span>() &amp;&amp; Array.<span class="built_in">Last</span>() + <span class="number">1</span> == FirstInstance)</span><br><span class="line">&#123;</span><br><span class="line">Array.<span class="built_in">Last</span>() = (uint32)LastInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Array.<span class="built_in">Add</span>((uint32)FirstInstance);</span><br><span class="line">Array.<span class="built_in">Add</span>((uint32)LastInstance);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">FORCEINLINE_DEBUGGABLE <span class="type">void</span> <span class="title">AddRun</span><span class="params">(int32 MinLod, int32 MaxLod, int32 FirstInstance, int32 LastInstance)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bNeedsSingleLODRuns)</span><br><span class="line">    &#123;</span><br><span class="line">       int32 CurrentLOD = bOverestimate ? MaxLod : MinLod;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (CurrentLOD &lt; MAX_STATIC_MESH_LODS)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">AddRun</span>(SingleLODRuns[CurrentLOD], FirstInstance, LastInstance);</span><br><span class="line">          TotalSingleLODInstances[CurrentLOD] += <span class="number">1</span> + LastInstance - FirstInstance;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bNeedsMultipleLODRuns)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span> (int32 Lod = MinLod; Lod &lt;= MaxLod; Lod++)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">if</span> (Lod &lt; MAX_STATIC_MESH_LODS)</span><br><span class="line">          &#123;</span><br><span class="line">             TotalMultipleLODInstances[Lod] += <span class="number">1</span> + LastInstance - FirstInstance;</span><br><span class="line">             <span class="built_in">AddRun</span>(MultipleLODRuns[Lod], FirstInstance, LastInstance);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交合批数据"><a href="#提交合批数据" class="headerlink" title="提交合批数据"></a>提交合批数据</h2><p>该数组在FillDynamicMeshElements中被用于将赋值给meshbatch的numinstances字段，方便在提交drawcall的时候知道绘制多少个实例，而每个实例数据的transform data，则是在FInstancedStaticMeshVertexFactory::InitRHI接口中（可以参考笔者的VertexFactory文章），绑定到顶点buffer的其中几个属性，在ush的顶点结构声明中也有同样的结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FInstancedStaticMeshVertexFactory::InitRHI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="comment">// toss in the instanced location stream</span></span><br><span class="line"><span class="built_in">check</span>(Data.InstanceOriginComponent.VertexBuffer);</span><br><span class="line"><span class="keyword">if</span> (Data.InstanceOriginComponent.VertexBuffer)</span><br><span class="line">&#123;</span><br><span class="line">Elements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(Data.InstanceOriginComponent, <span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">check</span>(Data.InstanceTransformComponent[<span class="number">0</span>].VertexBuffer);</span><br><span class="line"><span class="keyword">if</span> (Data.InstanceTransformComponent[<span class="number">0</span>].VertexBuffer)</span><br><span class="line">&#123;</span><br><span class="line">Elements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(Data.InstanceTransformComponent[<span class="number">0</span>], <span class="number">9</span>));</span><br><span class="line">Elements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(Data.InstanceTransformComponent[<span class="number">1</span>], <span class="number">10</span>));</span><br><span class="line">Elements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(Data.InstanceTransformComponent[<span class="number">2</span>], <span class="number">11</span>));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//localVertexFactory.ush</span></span><br><span class="line">struct FVertexFactoryInput</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#if USE_INSTANCING &amp;&amp; !MANUAL_VERTEX_FETCH</span></span><br><span class="line">float4 InstanceOrigin : ATTRIBUTE8;  <span class="comment">// per-instance random in w </span></span><br><span class="line">half4 InstanceTransform1 : ATTRIBUTE9;  <span class="comment">// hitproxy.r + 256 * selected in .w</span></span><br><span class="line">half4 InstanceTransform2 : ATTRIBUTE10; <span class="comment">// hitproxy.g in .w</span></span><br><span class="line">half4 InstanceTransform3 : ATTRIBUTE11; <span class="comment">// hitproxy.b in .w</span></span><br><span class="line">float4 InstanceLightmapAndShadowMapUVBias : ATTRIBUTE12; </span><br><span class="line"><span class="meta">#endif //USE_INSTANCING</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MaterialTemplate.ush</span></span><br><span class="line"><span class="comment">/** Return the object&#x27;s position in world space */</span></span><br><span class="line">float3 GetObjectWorldPosition(FMaterialPixelParameters Parameters)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> GetPrimitiveData(Parameters.PrimitiveId).ObjectWorldPositionAndRadius.xyz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Return the object&#x27;s position in world space. For instanced meshes, this returns the instance position. */</span></span><br><span class="line">float3 GetObjectWorldPosition(FMaterialVertexParameters Parameters)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#if USE_INSTANCING || IS_MESHPARTICLE_FACTORY</span></span><br><span class="line">       <span class="keyword">return</span> Parameters.InstanceLocalToWorld[<span class="number">3</span>].xyz;</span><br><span class="line">    <span class="meta">#else</span></span><br><span class="line">       <span class="keyword">return</span> GetPrimitiveData(Parameters.PrimitiveId).ObjectWorldPositionAndRadius.xyz;</span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与GPUScene的区别"><a href="#与GPUScene的区别" class="headerlink" title="与GPUScene的区别"></a>与GPUScene的区别</h2><p>而在shader的多处对instance的transform取值中我们也可以看出，以USE_INSTANCING或其他参数作为区分，返回动态合批的instance数据（GPUScene）或者HISM的Instance数据。</p><p>这两者的区别笔者认为有以下几点：</p><ol><li>GPUScene可以合批各种场景Proxy，只要渲染状态相同即可，并且可以存储数据较多，而HISM只能合批当前的components，并且只存储Transform。</li><li>GPUScene的Instance数据是通过Struct或者Texture一起传输到GPU的，而HISM则是提前放置在Vertex Buffer中。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> UE源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE渲染工作流(二)——可见性篇</title>
      <link href="/2024/06/28/renderworkflow_visibility/"/>
      <url>/2024/06/28/renderworkflow_visibility/</url>
      
        <content type="html"><![CDATA[<h1 id="UE渲染工作流-二-——可见性篇"><a href="#UE渲染工作流-二-——可见性篇" class="headerlink" title="UE渲染工作流(二)——可见性篇"></a>UE渲染工作流(二)——可见性篇</h1><p>​    上一篇我们讨论到StaticMesh的数据从RenderData数据成员设置到VF中，然后再赋值给渲染线程的FPrimitiveSceneInfo的MeshBatch，这一篇主要讨论在渲染线程拥有了Mesh数据后，如何做可见性的过滤。</p><span id="more"></span><p>​    可见性计算的入口在FMobileSceneRenderer::InitViews，其中有三个主要函数，我们主要讨论最重要的ComputeViewVisibility，前后两个SetUp是对视对本帧数据做一些预处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PreVisibilityFrameSetup</span>(RHICmdList);</span><br><span class="line"><span class="built_in">ComputeViewVisibility</span>(RHICmdList, BasePassDepthStencilAccess, ViewCommandsPerView, DynamicIndexBuffer, DynamicVertexBuffer, DynamicReadBuffer);</span><br><span class="line"><span class="built_in">PostVisibilityFrameSetup</span>(ILCTaskData);</span><br></pre></td></tr></table></figure><p>​    ComputeViewVisibility分为几个模块执行</p><ol><li><p>更新View下的可见性Map数据结构</p></li><li><p>视锥裁剪</p></li><li><p>更新视图中隐藏/仅可见/线框绘制的图元</p></li><li><p>计算并标记视图相关性</p></li><li><p>获取动态图元的MeshBatch</p></li><li><p>设置MeshPass数据</p><p>其中1，3步骤比较直接，这里不再解读，都是直接对PrimitiveMap进行操作赋值。</p><p>这里的大部分Map都使用了FSceneBitArray结构，其实本质上是一个uint32的数组，每一个uint32的位单独代表一个Primitive，所以在操作的时候需要先找到对于的uint32，然后再操作对应的位数。</p></li></ol><h2 id="FrustumCull"><a href="#FrustumCull" class="headerlink" title="FrustumCull"></a>FrustumCull</h2><p>​    在执行视锥裁剪之前，UE先做了HLOD的更新，本篇不多赘述，后面会单独讲这个系统，大概作用是会将远处的Mesh按照一定范围，合并成一个Mesh，生成新的Material，这样的好处是可以减小drawcall，但是因为需要合并新的Mesh，所以内存会变大。</p><p>​    视锥裁剪函数入口为FrustumCull，实际算法就是根据FPrimitiveSceneInfo的绘制距离与当前视角远点对比，根据大于，等于，小于渐变距离范围分别加入到View的三个PrimitiveMap中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据primitiveid下标，填充三种map，可见/不可见/淡出</span></span><br><span class="line"><span class="keyword">if</span> (FadingBits)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">check</span>(!View.PotentiallyFadingPrimitiveMap.<span class="built_in">GetData</span>()[WordIndex]); <span class="comment">// this should start at zero</span></span><br><span class="line">View.PotentiallyFadingPrimitiveMap.<span class="built_in">GetData</span>()[WordIndex] = FadingBits;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (VisBits)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">check</span>(!View.PrimitiveVisibilityMap.<span class="built_in">GetData</span>()[WordIndex]); <span class="comment">// this should start at zero</span></span><br><span class="line">View.PrimitiveVisibilityMap.<span class="built_in">GetData</span>()[WordIndex] = VisBits;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (DistanceCulledBits)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">check</span>(!View.DistanceCullingPrimitiveMap.<span class="built_in">GetData</span>()[WordIndex]); <span class="comment">// this should start at zero</span></span><br><span class="line">View.DistanceCullingPrimitiveMap.<span class="built_in">GetData</span>()[WordIndex] = DistanceCulledBits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ComputeAndMarkRelevanceForViewParallel"><a href="#ComputeAndMarkRelevanceForViewParallel" class="headerlink" title="ComputeAndMarkRelevanceForViewParallel"></a>ComputeAndMarkRelevanceForViewParallel</h2><p>这一步主要是通过SceneProxy的GetViewRelevance接口获取每一个proxy是否跟View相关，来决定每一个PrimitiveSceneInfo后续的绘制操作，每一个相关性的作用可以参考FPrimitiveViewRelevance类的成员，我们这里只关注它的动态/静态相关性，它们最终决定了对应的PrimitiveSceneInfo是通过哪种绘制路径来绘制。</p><p><img src="/2024/06/28/renderworkflow_visibility/renderpath.png" alt></p><p>​    绘制路径是UE针对静态物体的一种优化手段，UE的渲染数据流向为上图从左到右，一层一层数据归集，最终生成一个FMeshDrawCommands丢给RHI线程调用底层图形API，但是对于场景中那些不怎么变化的物体，不需要每帧都重复这个流程，可以把他们的MeshDrawCommands缓存下来，这就是静态绘制路径，而需要每帧都重新生成的是动态绘制路径。</p><p>这一步主要通过FRelevancePacket对View.PrimitiveVisibilityMap遍历进行多线程计算，PrimitiveVisibilityMap已经在2，3步骤中被更新，主要执行其接口AnyThreadTask()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnyThreadTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ComputeRelevance</span>();</span><br><span class="line">    <span class="built_in">MarkRelevant</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ComputeRelevance"><a href="#ComputeRelevance" class="headerlink" title="ComputeRelevance"></a>ComputeRelevance</h3><p>这一步主要就是通过SceneProxy的GetViewRelevance接口获取每一个proxy的相关性，加入不同的数组队列中保存，这里我们关注两个相关性：静态/动态。对于静态会添加到RelevantStaticPrimitives，对于动态会对函数的返回值OutHasDynamicMeshElementsMasks做标记，在函数外再做处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ComputeRelevance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (int32 Index = <span class="number">0</span>; Index &lt; Input.NumPrims; Index++)</span><br><span class="line">&#123;</span><br><span class="line">int32 BitIndex = Input.Prims[Index];</span><br><span class="line">FPrimitiveSceneInfo* PrimitiveSceneInfo = Scene-&gt;Primitives[BitIndex];</span><br><span class="line">FPrimitiveViewRelevance&amp; ViewRelevance = <span class="built_in">const_cast</span>&lt;FPrimitiveViewRelevance&amp;&gt;(View.PrimitiveViewRelevanceMap[BitIndex]);</span><br><span class="line">ViewRelevance = PrimitiveSceneInfo-&gt;Proxy-&gt;<span class="built_in">GetViewRelevance</span>(&amp;View);</span><br><span class="line">ViewRelevance.bInitializedThisFrame = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bStaticRelevance = ViewRelevance.bStaticRelevance;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bDrawRelevance = ViewRelevance.bDrawRelevance;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bDynamicRelevance = ViewRelevance.bDynamicRelevance;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bShadowRelevance = ViewRelevance.bShadowRelevance;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bEditorRelevance = ViewRelevance.bEditorPrimitiveRelevance;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bEditorSelectionRelevance = ViewRelevance.bEditorStaticSelectionRelevance;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bTranslucentRelevance = ViewRelevance.<span class="built_in">HasTranslucency</span>();</span><br><span class="line"><span class="comment">//对静态相关性处理</span></span><br><span class="line"><span class="keyword">if</span> (bStaticRelevance &amp;&amp; (bDrawRelevance || bShadowRelevance))</span><br><span class="line">&#123;</span><br><span class="line">RelevantStaticPrimitives.<span class="built_in">AddPrim</span>(BitIndex);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (bEditorRelevance)</span><br><span class="line">&#123;</span><br><span class="line">++NumVisibleDynamicEditorPrimitives;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (GIsEditor)</span><br><span class="line">&#123;</span><br><span class="line">OutHasDynamicEditorMeshElementsMasks[BitIndex] |= ViewBit;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//动态相关性处理</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(bDynamicRelevance)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Keep track of visible dynamic primitives.</span></span><br><span class="line">++NumVisibleDynamicPrimitives;</span><br><span class="line">OutHasDynamicMeshElementsMasks[BitIndex] |= ViewBit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ViewRelevance.bHasSimpleLights)</span><br><span class="line">&#123;</span><br><span class="line">VisibleDynamicPrimitivesWithSimpleLights.<span class="built_in">AddPrim</span>(PrimitiveSceneInfo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看一下StaticMesh是如何决定是否是静态的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FPrimitiveViewRelevance <span class="title">FStaticMeshSceneProxy::GetViewRelevance</span><span class="params">(<span class="type">const</span> FSceneView* View)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">checkSlow</span>(<span class="built_in">IsInParallelRenderingThread</span>());</span><br><span class="line"></span><br><span class="line">    FPrimitiveViewRelevance Result;</span><br><span class="line">    Result.bDrawRelevance = <span class="built_in">IsShown</span>(View) &amp;&amp; View-&gt;Family-&gt;EngineShowFlags.StaticMeshes;</span><br><span class="line">    Result.bRenderCustomDepth = <span class="built_in">ShouldRenderCustomDepth</span>();</span><br><span class="line">    Result.bRenderInMainPass = <span class="built_in">ShouldRenderInMainPass</span>();</span><br><span class="line">    Result.bUsesLightingChannels = <span class="built_in">GetLightingChannelMask</span>() != <span class="built_in">GetDefaultLightingChannelMask</span>();</span><br><span class="line">    Result.bTranslucentSelfShadow = bCastVolumetricTranslucentShadow;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> STATICMESH_ENABLE_DEBUG_RENDERING</span></span><br><span class="line">    <span class="type">bool</span> bDrawSimpleCollision = <span class="literal">false</span>, bDrawComplexCollision = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bInCollisionView = <span class="built_in">IsCollisionView</span>(View-&gt;Family-&gt;EngineShowFlags, bDrawSimpleCollision, bDrawComplexCollision);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">bool</span> bInCollisionView = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bAllowStaticLighting = FReadOnlyCVARCache::<span class="built_in">Get</span>().bAllowStaticLighting;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(</span><br><span class="line">       <span class="comment">// Force down dynamic rendering path if invalid lightmap settings, so we can apply an error material in DrawRichMesh</span></span><br><span class="line">       (bAllowStaticLighting &amp;&amp; <span class="built_in">HasStaticLighting</span>() &amp;&amp; !<span class="built_in">HasValidSettingsForStaticLighting</span>()) ||</span><br><span class="line">       <span class="built_in">HasViewDependentDPG</span>()</span><br><span class="line">       )</span><br><span class="line">    &#123;</span><br><span class="line">       Result.bDynamicRelevance = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       Result.bStaticRelevance = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Result.bShadowRelevance = <span class="built_in">IsShadowCast</span>(View);</span><br><span class="line"></span><br><span class="line">    MaterialRelevance.<span class="built_in">SetPrimitiveViewRelevance</span>(Result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!View-&gt;Family-&gt;EngineShowFlags.Materials </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> STATICMESH_ENABLE_DEBUG_RENDERING</span></span><br><span class="line">       || bInCollisionView</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">    &#123;</span><br><span class="line">       Result.bOpaque = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Result.bVelocityRelevance = <span class="built_in">IsMovable</span>() &amp;&amp; Result.bOpaque &amp;&amp; Result.bRenderInMainPass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看到有几个判断决定，我们看下具体实现，其实就是判断在编辑器中勾选的移动性，以及是否支持静态光，至于Lightmap的判断我们这里暂不展开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UPrimitiveComponent::HasStaticLighting</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Mobility == EComponentMobility::Static) || LightmapType == ELightmapType::ForceSurface) &amp;&amp; <span class="built_in">SupportsStaticLighting</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是StaticMeshComponent的实现</span></span><br><span class="line"><span class="comment">/** Whether the component type supports static lighting. */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">SupportsStaticLighting</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UStaticMeshComponent::HasValidSettingsForStaticLighting</span><span class="params">(<span class="type">bool</span> bOverlookInvalidComponents)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bOverlookInvalidComponents &amp;&amp; !<span class="built_in">GetStaticMesh</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Return true for invalid components, this is used during the map check where those invalid components will be warned about separately</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">int32 LightMapWidth = <span class="number">0</span>;</span><br><span class="line">int32 LightMapHeight = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">GetLightMapResolution</span>(LightMapWidth, LightMapHeight);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Super::<span class="built_in">HasValidSettingsForStaticLighting</span>(bOverlookInvalidComponents) </span><br><span class="line">&amp;&amp; <span class="built_in">GetStaticMesh</span>()</span><br><span class="line">&amp;&amp; <span class="built_in">UsesTextureLightmaps</span>(LightMapWidth, LightMapHeight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    我们大致可以判断出什么样的StaticMeshComponent是动态相关性：支持StaticLighting的，但是没有设置对应的Lightmap。</p><h3 id="MarkRelevant"><a href="#MarkRelevant" class="headerlink" title="MarkRelevant"></a>MarkRelevant</h3><p>​    这一步只对静态相关性的Primitive处理，会根据PrimitiveSceneInfo的StaticMeshRelevances以及shadingpath，把PrimitiveSceneInfo的MeshDrawCommands添加到不同Pass的数组队列中，而静态Primitive的MeshDrawCommands在上一篇中已经在CacheMeshDrawCommands中被保存起来了，这里更像是做一个归类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MarkRelevant</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (int32 StaticPrimIndex = <span class="number">0</span>, Num = RelevantStaticPrimitives.NumPrims; StaticPrimIndex &lt; Num; ++StaticPrimIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (StaticMeshRelevance.bUseForMaterial &amp;&amp; (ViewRelevance.bRenderInMainPass || ViewRelevance.bRenderCustomDepth))</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line"><span class="comment">// Specific logic for mobile packets</span></span><br><span class="line"><span class="keyword">if</span> (ShadingPath == EShadingPath::Mobile)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Skydome must not be added to base pass bucket</span></span><br><span class="line"><span class="keyword">if</span> (!StaticMeshRelevance.bUseSkyMaterial)</span><br><span class="line">&#123;</span><br><span class="line">                        <span class="comment">//添加到basepass的队列中</span></span><br><span class="line">DrawCommandPacket.<span class="built_in">AddCommandsForMesh</span>(PrimitiveIndex, PrimitiveSceneInfo, StaticMeshRelevance, StaticMesh, Scene, bCanCache, EMeshPass::BasePass);</span><br><span class="line">DrawCommandPacket.<span class="built_in">AddCommandsForMesh</span>(PrimitiveIndex, PrimitiveSceneInfo, StaticMeshRelevance, StaticMesh, Scene, bCanCache, EMeshPass::MobileBasePassCSM);</span><br><span class="line">&#125;</span><br><span class="line">                   &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddCommandsForMesh</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    int32 PrimitiveIndex, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FPrimitiveSceneInfo* InPrimitiveSceneInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FStaticMeshBatchRelevance&amp; RESTRICT StaticMeshRelevance, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FStaticMeshBatch&amp; RESTRICT StaticMesh, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FScene* RESTRICT Scene, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bCanCache, </span></span></span><br><span class="line"><span class="params"><span class="function">    EMeshPass::Type PassType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> EShadingPath ShadingPath = Scene-&gt;<span class="built_in">GetShadingPath</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bUseCachedMeshCommand = bUseCachedMeshDrawCommands</span><br><span class="line">       &amp;&amp; !!(FPassProcessorManager::<span class="built_in">GetPassFlags</span>(ShadingPath, PassType) &amp; EMeshPassFlags::CachedMeshCommands)</span><br><span class="line">       &amp;&amp; StaticMeshRelevance.bSupportsCachingMeshDrawCommands</span><br><span class="line">       &amp;&amp; bCanCache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bUseCachedMeshCommand)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="type">const</span> int32 StaticMeshCommandInfoIndex = StaticMeshRelevance.<span class="built_in">GetStaticMeshCommandInfoIndex</span>(PassType);</span><br><span class="line">       <span class="keyword">if</span> (StaticMeshCommandInfoIndex &gt;= <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="type">const</span> FCachedMeshDrawCommandInfo&amp; CachedMeshDrawCommand = InPrimitiveSceneInfo-&gt;StaticMeshCommandInfos[StaticMeshCommandInfoIndex];</span><br><span class="line">          <span class="type">const</span> FCachedPassMeshDrawList&amp; SceneDrawList = Scene-&gt;CachedDrawLists[PassType];</span><br><span class="line"></span><br><span class="line">          <span class="comment">// AddUninitialized_GetRef()</span></span><br><span class="line">           <span class="comment">//这里的MeshdrawCommands是根据pass来分类存储</span></span><br><span class="line">          VisibleCachedDrawCommands[(uint32)PassType].<span class="built_in">AddUninitialized</span>();</span><br><span class="line">          FVisibleMeshDrawCommand&amp; NewVisibleMeshDrawCommand = VisibleCachedDrawCommands[(uint32)PassType].<span class="built_in">Last</span>();</span><br><span class="line"></span><br><span class="line">          <span class="type">const</span> FMeshDrawCommand* MeshDrawCommand = CachedMeshDrawCommand.StateBucketId &gt;= <span class="number">0</span></span><br><span class="line">             ? &amp;Scene-&gt;CachedMeshDrawCommandStateBuckets[PassType].<span class="built_in">GetByElementId</span>(CachedMeshDrawCommand.StateBucketId).Key</span><br><span class="line">             : &amp;SceneDrawList.MeshDrawCommands[CachedMeshDrawCommand.CommandIndex];</span><br><span class="line"></span><br><span class="line">          NewVisibleMeshDrawCommand.<span class="built_in">Setup</span>(</span><br><span class="line">             MeshDrawCommand,</span><br><span class="line">             PrimitiveIndex,</span><br><span class="line">             PrimitiveIndex,</span><br><span class="line">             CachedMeshDrawCommand.StateBucketId,</span><br><span class="line">             CachedMeshDrawCommand.MeshFillMode,</span><br><span class="line">             CachedMeshDrawCommand.MeshCullMode,</span><br><span class="line">             CachedMeshDrawCommand.SortKey);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       NumDynamicBuildRequestElements[PassType] += StaticMeshRelevance.NumElements;</span><br><span class="line">       DynamicBuildRequests[PassType].<span class="built_in">Add</span>(&amp;StaticMesh);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RenderThreadFinalize"><a href="#RenderThreadFinalize" class="headerlink" title="RenderThreadFinalize"></a>RenderThreadFinalize</h3><p>​    这一步主要是做一些数据拷贝的操作，把Packet处理后的数据拷贝Packet中的数据成员，这里我们只关注MeshDrawCommands的转移，WriteViewCommands其实是ComputeViewVisibility调用时传入的参数，这个参数同样在SetupMeshPass中被用来存放动态绘制指令，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderThreadFinalize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (int32 PassIndex = <span class="number">0</span>; PassIndex &lt; EMeshPass::Num; PassIndex++)</span><br><span class="line">&#123;</span><br><span class="line">FPassDrawCommandArray&amp; SrcCommands = DrawCommandPacket.VisibleCachedDrawCommands[PassIndex];</span><br><span class="line">FMeshCommandOneFrameArray&amp; DstCommands = WriteViewCommands.MeshCommands[PassIndex];</span><br><span class="line">    <span class="comment">//赋值静态绘制指令</span></span><br><span class="line"><span class="keyword">if</span> (SrcCommands.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(SrcCommands[<span class="number">0</span>]) == <span class="built_in">sizeof</span>(DstCommands[<span class="number">0</span>]), <span class="string">&quot;Memcpy sizes must match.&quot;</span>);</span><br><span class="line"><span class="type">const</span> int32 PrevNum = DstCommands.<span class="built_in">AddUninitialized</span>(SrcCommands.<span class="built_in">Num</span>());</span><br><span class="line">FMemory::<span class="built_in">Memcpy</span>(&amp;DstCommands[PrevNum], &amp;SrcCommands[<span class="number">0</span>], SrcCommands.<span class="built_in">Num</span>() * <span class="built_in">sizeof</span>(SrcCommands[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//不支持缓存会放在这里，等到生成动态绘制指令时再生成</span></span><br><span class="line">    FPassDrawCommandBuildRequestArray&amp; SrcRequests = DrawCommandPacket.DynamicBuildRequests[PassIndex];</span><br><span class="line">TArray&lt;<span class="type">const</span> FStaticMeshBatch*, SceneRenderingAllocator&gt;&amp; DstRequests = WriteViewCommands.DynamicMeshCommandBuildRequests[PassIndex];</span><br><span class="line"><span class="keyword">if</span> (SrcRequests.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(SrcRequests[<span class="number">0</span>]) == <span class="built_in">sizeof</span>(DstRequests[<span class="number">0</span>]), <span class="string">&quot;Memcpy sizes must match.&quot;</span>);</span><br><span class="line"><span class="type">const</span> int32 PrevNum = DstRequests.<span class="built_in">AddUninitialized</span>(SrcRequests.<span class="built_in">Num</span>());</span><br><span class="line">FMemory::<span class="built_in">Memcpy</span>(&amp;DstRequests[PrevNum], &amp;SrcRequests[<span class="number">0</span>], SrcRequests.<span class="built_in">Num</span>() * <span class="built_in">sizeof</span>(SrcRequests[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GatherDynamicMeshElements"><a href="#GatherDynamicMeshElements" class="headerlink" title="GatherDynamicMeshElements"></a>GatherDynamicMeshElements</h2><p>​    上一步在标记相关性后，动态相关性的primitive被保存在了OutHasDynamicEditorMeshElementsMasks结构中，这一步就是对动态相关性的primitive重新收集MeshBatch，内部调用了GetDynamicMeshElements来生成MeshBatch，这一步其实与静态绘制的primitive收集meshbatch的流程类似，GetDynamicMeshElements内部调用了统一的接口GetMeshElement，最终把meshbatch收集到参数Collector中，需要注意的是最后Collector收集MeshBatch的地方，在GatherDynamicMeshElements的开头部分Collector注册了View.DynamicMeshElements到MeshBatchs中，所以这里其实把MeshBatch按照View添加进了DynamicMeshElements数据结构，后面没有用到collector的原因正在于此。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FMeshElementCollector::<span class="built_in">AddMesh</span>(int32 ViewIndex, FMeshBatch&amp; MeshBatch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    TArray&lt;FMeshBatchAndRelevance,SceneRenderingAllocator&gt;&amp; ViewMeshBatches = *MeshBatches[ViewIndex];</span><br><span class="line"><span class="keyword">new</span> (ViewMeshBatches) <span class="built_in">FMeshBatchAndRelevance</span>(MeshBatch, PrimitiveSceneProxy, FeatureLevel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SetupMeshPass"><a href="#SetupMeshPass" class="headerlink" title="SetupMeshPass"></a>SetupMeshPass</h2><p>到这一步，我们回顾下现在拥有哪些数据：按照pass分类存储的静态绘制路径的MeshDrawCommands，动态绘制路径的MeshBatch。</p><p>SetupMeshPass主要通过DispatchPassSetup，分发任务，来实现View.ParallelMeshDrawCommandPasses结构的填充，以便在后续执行对应Pass的时候提交MeshDrawCommands。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSceneRenderer::SetupMeshPass</span><span class="params">(FViewInfo&amp; View, FExclusiveDepthStencil::Type BasePassDepthStencilAccess, FViewCommands&amp; ViewCommands)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> EShadingPath ShadingPath = Scene-&gt;<span class="built_in">GetShadingPath</span>();</span><br><span class="line">    <span class="keyword">for</span> (int32 PassIndex = <span class="number">0</span>; PassIndex &lt; EMeshPass::Num; PassIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="type">const</span> EMeshPass::Type PassType = (EMeshPass::Type)PassIndex;</span><br><span class="line">       <span class="keyword">if</span> ((FPassProcessorManager::<span class="built_in">GetPassFlags</span>(ShadingPath, PassType) &amp; EMeshPassFlags::MainView) != EMeshPassFlags::None)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">// Mobile: BasePass and MobileBasePassCSM lists need to be merged and sorted after shadow pass.</span></span><br><span class="line">          <span class="keyword">if</span> (ShadingPath == EShadingPath::Mobile &amp;&amp; (PassType == EMeshPass::BasePass || PassType == EMeshPass::MobileBasePassCSM))</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          PassProcessorCreateFunction CreateFunction = FPassProcessorManager::<span class="built_in">GetCreateFunction</span>(ShadingPath, PassType);</span><br><span class="line">          FMeshPassProcessor* MeshPassProcessor = <span class="built_in">CreateFunction</span>(Scene, &amp;View, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">          FParallelMeshDrawCommandPass&amp; Pass = View.ParallelMeshDrawCommandPasses[PassIndex];</span><br><span class="line">          Pass.<span class="built_in">DispatchPassSetup</span>(</span><br><span class="line">             Scene,</span><br><span class="line">             View,</span><br><span class="line">             PassType,</span><br><span class="line">             BasePassDepthStencilAccess,</span><br><span class="line">             MeshPassProcessor,</span><br><span class="line">             View.DynamicMeshElements,</span><br><span class="line">             &amp;View.DynamicMeshElementsPassRelevance,</span><br><span class="line">             View.NumVisibleDynamicMeshElements[PassType],</span><br><span class="line">             ViewCommands.DynamicMeshCommandBuildRequests[PassType],</span><br><span class="line">             ViewCommands.NumDynamicMeshCommandBuildRequestElements[PassType],</span><br><span class="line">             ViewCommands.MeshCommands[PassIndex]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DispatchPassSetup内部会设置FMeshDrawCommandPassSetupTaskContext的数据，然后多线程执行FMeshDrawCommandPassSetupTask，我们看下Task的内部实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnyThreadTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Mobile base pass is a special case, as final lists is created from two mesh passes based on CSM visibility.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bMobileShadingBasePass = Context.ShadingPath == EShadingPath::Mobile &amp;&amp; Context.PassType == EMeshPass::BasePass;</span><br><span class="line">    <span class="comment">// On SM5 Mobile platform, still want the same sorting</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bMobileVulkanSM5BasePass = <span class="built_in">IsVulkanMobileSM5Platform</span>(Context.ShaderPlatform) &amp;&amp; Context.PassType == EMeshPass::BasePass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bMobileShadingBasePass)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">MergeMobileBasePassMeshDrawCommands</span>(</span><br><span class="line">          Context.View-&gt;MobileCSMVisibilityInfo,</span><br><span class="line">          Context.PrimitiveBounds-&gt;<span class="built_in">Num</span>(),</span><br><span class="line">          Context.MeshDrawCommands,</span><br><span class="line">          Context.MobileBasePassCSMMeshDrawCommands</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">       <span class="built_in">GenerateMobileBasePassDynamicMeshDrawCommands</span>(</span><br><span class="line">          *Context.View,</span><br><span class="line">          Context.ShadingPath,</span><br><span class="line">          Context.PassType,</span><br><span class="line">          Context.MeshPassProcessor,</span><br><span class="line">          Context.MobileBasePassCSMMeshPassProcessor,</span><br><span class="line">          *Context.DynamicMeshElements,</span><br><span class="line">          Context.DynamicMeshElementsPassRelevance,</span><br><span class="line">          Context.NumDynamicMeshElements,</span><br><span class="line">          Context.DynamicMeshCommandBuildRequests,</span><br><span class="line">          Context.NumDynamicMeshCommandBuildRequestElements,</span><br><span class="line">          Context.MeshDrawCommands,</span><br><span class="line">          Context.MeshDrawCommandStorage,</span><br><span class="line">          Context.MinimalPipelineStatePassSet,</span><br><span class="line">          Context.NeedsShaderInitialisation</span><br><span class="line">       );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">GenerateDynamicMeshDrawCommands</span>(</span><br><span class="line">          *Context.View,</span><br><span class="line">          Context.ShadingPath,</span><br><span class="line">          Context.PassType,</span><br><span class="line">          Context.MeshPassProcessor,</span><br><span class="line">          *Context.DynamicMeshElements,</span><br><span class="line">          Context.DynamicMeshElementsPassRelevance,</span><br><span class="line">          Context.NumDynamicMeshElements,</span><br><span class="line">          Context.DynamicMeshCommandBuildRequests,</span><br><span class="line">          Context.NumDynamicMeshCommandBuildRequestElements,</span><br><span class="line">          Context.MeshDrawCommands,</span><br><span class="line">          Context.MeshDrawCommandStorage,</span><br><span class="line">          Context.MinimalPipelineStatePassSet,</span><br><span class="line">          Context.NeedsShaderInitialisation</span><br><span class="line">       );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Context.MeshDrawCommands.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span> (Context.PassType != EMeshPass::Num)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">ApplyViewOverridesToMeshDrawCommands</span>(</span><br><span class="line">             Context.ShadingPath,</span><br><span class="line">             Context.PassType,</span><br><span class="line">             Context.bReverseCulling,</span><br><span class="line">             Context.bRenderSceneTwoSided,</span><br><span class="line">             Context.BasePassDepthStencilAccess,</span><br><span class="line">             Context.DefaultBasePassDepthStencilAccess,</span><br><span class="line">             Context.MeshDrawCommands,</span><br><span class="line">             Context.MeshDrawCommandStorage,</span><br><span class="line">             Context.MinimalPipelineStatePassSet,</span><br><span class="line">             Context.NeedsShaderInitialisation,</span><br><span class="line">             Context.TempVisibleMeshDrawCommands</span><br><span class="line">          );</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Update sort keys.</span></span><br><span class="line">       <span class="keyword">if</span> (bMobileShadingBasePass || bMobileVulkanSM5BasePass)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">UpdateMobileBasePassMeshSortKeys</span>(</span><br><span class="line">             Context.ViewOrigin,</span><br><span class="line">             *Context.PrimitiveBounds,</span><br><span class="line">             Context.MeshDrawCommands</span><br><span class="line">             );</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (Context.TranslucencyPass != ETranslucencyPass::TPT_MAX)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">UpdateTranslucentMeshSortKeys</span>(</span><br><span class="line">             Context.TranslucentSortPolicy,</span><br><span class="line">             Context.TranslucentSortAxis,</span><br><span class="line">             Context.ViewOrigin,</span><br><span class="line">             Context.ViewMatrix,</span><br><span class="line">             *Context.PrimitiveBounds,</span><br><span class="line">             Context.TranslucencyPass,</span><br><span class="line">             Context.MeshDrawCommands</span><br><span class="line">          );</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">QUICK_SCOPE_CYCLE_COUNTER</span>(STAT_SortVisibleMeshDrawCommands);</span><br><span class="line">          Context.MeshDrawCommands.<span class="built_in">Sort</span>(<span class="built_in">FCompareFMeshDrawCommands</span>());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (Context.bUseGPUScene)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">BuildMeshDrawCommandPrimitiveIdBuffer</span>(</span><br><span class="line">             Context.bDynamicInstancing,</span><br><span class="line">             Context.MeshDrawCommands,</span><br><span class="line">             Context.MeshDrawCommandStorage,</span><br><span class="line">             Context.PrimitiveIdBufferData,</span><br><span class="line">             Context.PrimitiveIdBufferDataSize,</span><br><span class="line">             Context.TempVisibleMeshDrawCommands,</span><br><span class="line">             Context.MaxInstances,</span><br><span class="line">             Context.VisibleMeshDrawCommandsNum,</span><br><span class="line">             Context.NewPassVisibleMeshDrawCommandsNum,</span><br><span class="line">             Context.ShaderPlatform,</span><br><span class="line">             Context.InstanceFactor</span><br><span class="line">          );</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    Task主要实现以下几点：</p><ol><li>GenerateDynamicMeshDrawCommands</li><li>ApplyViewOverridesToMeshDrawCommands</li><li>Update/SortMeshDrawCommands</li><li>BuildMeshDrawCommandPrimitiveIdBuffer</li></ol><h3 id="GenerateDynamicMeshDrawCommands"><a href="#GenerateDynamicMeshDrawCommands" class="headerlink" title="GenerateDynamicMeshDrawCommands"></a>GenerateDynamicMeshDrawCommands</h3><p>​    这一步和上一篇的CacheMeshDrawCommands处理基本一致，都是通过processor处理MeshBatch生成MeshDrawCommands，生成的MeshDrawCommands会被收集到函数开头填入Context的VisibleCommands中，而这个VisibleCommands经过层层传递，其实就是SetupMeshPass传入的最后一个参数，与RenderThreadFinalize中存储静态指令的结构相同，这样就把静态和动态绘制指令保存在一起，可以发现这个参数变量在ComputeViewVisibility之后就没有被其他地方使用，答案就在DispatchPassSetup中，对应Pass的FMeshCommandOneFrameArray数据结构被MemSwap给了对应Pass的TaskContext，在后续提交渲染指令时，Pass会直接拿Task内的指令来提交。</p><p>​    另外这里里的数据来源是GatherDynamicMeshElements中收集来的MeshBatch，但是还有DynamicMeshCommandBuildRequests，这个是在把静态绘制指令按照Pass存储的时候，如果当前Pass不支持缓存，那就不会放在CacheCommands中，而是放在BuildRequests里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GenerateDynamicMeshDrawCommands</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FViewInfo&amp; View,</span></span></span><br><span class="line"><span class="params"><span class="function">    EShadingPath ShadingPath,</span></span></span><br><span class="line"><span class="params"><span class="function">    EMeshPass::Type PassType,</span></span></span><br><span class="line"><span class="params"><span class="function">    FMeshPassProcessor* PassMeshProcessor,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TArray&lt;FMeshBatchAndRelevance, SceneRenderingAllocator&gt;&amp; DynamicMeshElements,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TArray&lt;FMeshPassMask, SceneRenderingAllocator&gt;* DynamicMeshElementsPassRelevance,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32 MaxNumDynamicMeshElements,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TArray&lt;<span class="type">const</span> FStaticMeshBatch*, SceneRenderingAllocator&gt;&amp; DynamicMeshCommandBuildRequests,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32 MaxNumBuildRequestElements,</span></span></span><br><span class="line"><span class="params"><span class="function">    FMeshCommandOneFrameArray&amp; VisibleCommands,</span></span></span><br><span class="line"><span class="params"><span class="function">    FDynamicMeshDrawCommandStorage&amp; MeshDrawCommandStorage,</span></span></span><br><span class="line"><span class="params"><span class="function">    FGraphicsMinimalPipelineStateSet&amp; MinimalPipelineStatePassSet,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span>&amp; NeedsShaderInitialisation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">QUICK_SCOPE_CYCLE_COUNTER</span>(STAT_GenerateDynamicMeshDrawCommands);</span><br><span class="line">    <span class="built_in">check</span>(PassMeshProcessor);</span><br><span class="line">    <span class="built_in">check</span>((PassType == EMeshPass::Num) == (DynamicMeshElementsPassRelevance == <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function">FDynamicPassMeshDrawListContext <span class="title">DynamicPassMeshDrawListContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">       MeshDrawCommandStorage,</span></span></span><br><span class="line"><span class="params"><span class="function">       VisibleCommands,</span></span></span><br><span class="line"><span class="params"><span class="function">       MinimalPipelineStatePassSet,</span></span></span><br><span class="line"><span class="params"><span class="function">       NeedsShaderInitialisation</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    PassMeshProcessor-&gt;<span class="built_in">SetDrawListContext</span>(&amp;DynamicPassMeshDrawListContext);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="type">const</span> int32 NumCommandsBefore = VisibleCommands.<span class="built_in">Num</span>();</span><br><span class="line">       <span class="type">const</span> int32 NumDynamicMeshBatches = DynamicMeshElements.<span class="built_in">Num</span>();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (int32 MeshIndex = <span class="number">0</span>; MeshIndex &lt; NumDynamicMeshBatches; MeshIndex++)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">if</span> (!DynamicMeshElementsPassRelevance || (*DynamicMeshElementsPassRelevance)[MeshIndex].<span class="built_in">Get</span>(PassType))</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="type">const</span> FMeshBatchAndRelevance&amp; MeshAndRelevance = DynamicMeshElements[MeshIndex];</span><br><span class="line">             <span class="type">const</span> uint64 BatchElementMask = ~<span class="number">0ull</span>;</span><br><span class="line"></span><br><span class="line">             PassMeshProcessor-&gt;<span class="built_in">AddMeshBatch</span>(*MeshAndRelevance.Mesh, BatchElementMask, MeshAndRelevance.PrimitiveSceneProxy);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="type">const</span> int32 NumCommandsBefore = VisibleCommands.<span class="built_in">Num</span>();</span><br><span class="line">       <span class="type">const</span> int32 NumStaticMeshBatches = DynamicMeshCommandBuildRequests.<span class="built_in">Num</span>();</span><br><span class="line">       <span class="keyword">for</span> (int32 MeshIndex = <span class="number">0</span>; MeshIndex &lt; NumStaticMeshBatches; MeshIndex++)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="type">const</span> FStaticMeshBatch* StaticMeshBatch = DynamicMeshCommandBuildRequests[MeshIndex];</span><br><span class="line">          <span class="type">const</span> uint64 DefaultBatchElementMask = ~<span class="number">0ul</span>;</span><br><span class="line">          PassMeshProcessor-&gt;<span class="built_in">AddMeshBatch</span>(*StaticMeshBatch, DefaultBatchElementMask, StaticMeshBatch-&gt;PrimitiveSceneInfo-&gt;Proxy, StaticMeshBatch-&gt;Id);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ApplyViewOverridesToMeshDrawCommands"><a href="#ApplyViewOverridesToMeshDrawCommands" class="headerlink" title="ApplyViewOverridesToMeshDrawCommands"></a>ApplyViewOverridesToMeshDrawCommands</h3><p>​    这一步是根据View的一些特殊需求，重新设置MeshDrawCommands的pipeline状态。</p><h3 id="Update-SortMeshDrawCommands"><a href="#Update-SortMeshDrawCommands" class="headerlink" title="Update/SortMeshDrawCommands"></a>Update/SortMeshDrawCommands</h3><p>​    至此，动态/静态MeshDrawCommands已经全部存储在Pass对应的TaskContext.MeshDrawCommands下，但是我们需要对透明/不透明的MeshDrawCommands进行排序。</p><p>​    首先要更新MeshDrawCommands的SortKeys，然后根据Key排序。有三种排序方式：物体与视角中心距离，沿着某个轴排序，投影深度排序。排序结果会存储在FMeshDrawCommandSortKey中，其是由一个uint64的union来实现，有三种情况：BassPass，透明Pass，通用Pass。根据位域高低位不同来实现大小比较，先声明的位域是低位，比如对于透明Pass来说，先比较优先级（高位），然后是距离，最后是同一个Primitive的不同MeshID。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateTranslucentMeshSortKeys</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">ETranslucentSortPolicy::Type TranslucentSortPolicy,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> FVector&amp; TranslucentSortAxis,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> FVector&amp; ViewOrigin,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> FMatrix&amp; ViewMatrix,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> TArray&lt;<span class="keyword">struct</span> FPrimitiveBounds&gt;&amp; PrimitiveBounds,</span></span></span><br><span class="line"><span class="params"><span class="function">ETranslucencyPass::Type TranslucencyPass, </span></span></span><br><span class="line"><span class="params"><span class="function">FMeshCommandOneFrameArray&amp; VisibleMeshCommands</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">QUICK_SCOPE_CYCLE_COUNTER</span>(STAT_UpdateTranslucentMeshSortKeys);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (int32 CommandIndex = <span class="number">0</span>; CommandIndex &lt; VisibleMeshCommands.<span class="built_in">Num</span>(); ++CommandIndex)</span><br><span class="line">&#123;</span><br><span class="line">FVisibleMeshDrawCommand&amp; VisibleCommand = VisibleMeshCommands[CommandIndex];</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> int32 PrimitiveIndex = VisibleCommand.ScenePrimitiveId;</span><br><span class="line"><span class="type">const</span> FVector BoundsOrigin = PrimitiveIndex &gt;= <span class="number">0</span> ? PrimitiveBounds[PrimitiveIndex].BoxSphereBounds.Origin : FVector::ZeroVector;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Distance = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">if</span> (TranslucentSortPolicy == ETranslucentSortPolicy::SortByDistance)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//sort based on distance to the view position, view rotation is not a factor</span></span><br><span class="line">Distance = (BoundsOrigin - ViewOrigin).<span class="built_in">Size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (TranslucentSortPolicy == ETranslucentSortPolicy::SortAlongAxis)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Sort based on enforced orthogonal distance</span></span><br><span class="line"><span class="type">const</span> FVector CameraToObject = BoundsOrigin - ViewOrigin;</span><br><span class="line">Distance = FVector::<span class="built_in">DotProduct</span>(CameraToObject, TranslucentSortAxis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Sort based on projected Z distance</span></span><br><span class="line"><span class="built_in">check</span>(TranslucentSortPolicy == ETranslucentSortPolicy::SortByProjectedZ);</span><br><span class="line">Distance = ViewMatrix.<span class="built_in">TransformPosition</span>(BoundsOrigin).Z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Patch distance inside translucent mesh sort key.</span></span><br><span class="line">FMeshDrawCommandSortKey SortKey;</span><br><span class="line">SortKey.PackedData = VisibleCommand.SortKey.PackedData;</span><br><span class="line">SortKey.Translucent.Distance = (uint32)~<span class="built_in">BitInvertIfNegativeFloat</span>(*((uint32*)&amp;Distance));</span><br><span class="line">VisibleCommand.SortKey.PackedData = SortKey.PackedData;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RENDERER_API</span> FMeshDrawCommandSortKey</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line">&#123;</span><br><span class="line">uint64 PackedData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">uint64 VertexShaderHash: <span class="number">16</span>; <span class="comment">// Order by vertex shader&#x27;s hash.</span></span><br><span class="line">uint64 PixelShaderHash: <span class="number">32</span>; <span class="comment">// Order by pixel shader&#x27;s hash.</span></span><br><span class="line">uint64 Masked: <span class="number">16</span>; <span class="comment">// First order by masked.</span></span><br><span class="line">&#125; BasePass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">uint64 MeshIdInPrimitive: <span class="number">16</span>; <span class="comment">// Order meshes belonging to the same primitive by a stable id.</span></span><br><span class="line">uint64 Distance: <span class="number">32</span>; <span class="comment">// Order by distance.</span></span><br><span class="line">uint64 Priority: <span class="number">16</span>; <span class="comment">// First order by priority.</span></span><br><span class="line">&#125; Translucent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">uint64 VertexShaderHash : <span class="number">32</span>;<span class="comment">// Order by vertex shader&#x27;s hash.</span></span><br><span class="line">uint64 PixelShaderHash : <span class="number">32</span>;<span class="comment">// First order by pixel shader&#x27;s hash.</span></span><br><span class="line">&#125; Generic;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BuildMeshDrawCommandPrimitiveIdBuffer"><a href="#BuildMeshDrawCommandPrimitiveIdBuffer" class="headerlink" title="BuildMeshDrawCommandPrimitiveIdBuffer"></a>BuildMeshDrawCommandPrimitiveIdBuffer</h3><p>这一步主要是为了合批，在GPUScene中有讲，主要是将相同渲染此处不展开。</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE渲染工作流(一)——数据篇</title>
      <link href="/2024/06/18/renderworkflow_data/"/>
      <url>/2024/06/18/renderworkflow_data/</url>
      
        <content type="html"><![CDATA[<h1 id="UE渲染工作流-一-——数据篇"><a href="#UE渲染工作流-一-——数据篇" class="headerlink" title="UE渲染工作流(一)——数据篇"></a>UE渲染工作流(一)——数据篇</h1><p>​    UE的渲染工作流基于原生API做了非常多的优化和封装，需要经常查阅和回顾这些工作流和数据结构，才能理解其中的奥妙。本篇内容要讨论的是数据准备篇，主要包含一个StaticMesh被放入场景中后，它的渲染数据是如何被整理应用的。注意：本篇只讲UE的部分工作流程，对于其中某个模块的具体算法实现细节不会不过解读，需要额外查阅资料，如果有时间，笔者会尽量记录在之后的文章中。</p><span id="more"></span><h2 id="StaticMesh-gt-SceneProxy"><a href="#StaticMesh-gt-SceneProxy" class="headerlink" title="StaticMesh-&gt;SceneProxy"></a>StaticMesh-&gt;SceneProxy</h2><p>​    在UE中，一个最小的可渲染物体组件是UPrimitiveComponent(GameThread)，它渲染线程中的FPrimitiveSceneProxy一一对应，我们以最常用的一个Component说起：UStaticMeshComponent，它包含了最关键的渲染数据成员：UStaticMesh。原生的顶点数据已经预先存储在了StaticMesh的成员RenderData中，数据是如何由FBX模块导入生成的，不是本章关注的内容，略去不讲。</p><p>​    当一个StaticMesh被拖入场景中时，会调用UStaticMesh::PostLoad，然后执行RenderData的InitResources，生成我们经常在API中见到的VertexBuffer，以及VertexDeclaration。关于顶点工厂的内容，这里也不展开讲述，感兴趣的同学可以参考另一篇文章：。</p><p>​    当一个图元需要被更新渲染信息时，会调用FScene::AddPrimitive()，在其中创建对应的FPrimitiveSceneProxy和FScenePrimitiveInfo，FPrimitiveSceneProxy是图元在渲染线程的代理，FScenePrimitiveInfo则是图元在渲染线程的状态表示，包含一个对应的FPrimitiveSceneProxy，其中会调用AddPrimitiveSceneInfo_RenderThread把Primitive加入到渲染线程中的一个数据结构中，留待渲染线程去更新。</p><p>​    上面说到了，StaticMesh的顶点数据都存在了RenderData中，这一步也会一起转移给FPrimitiveSceneProxy，参考构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FScene::AddPrimitive</span><span class="params">(UPrimitiveComponent* Primitive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//... Addprimitive中的关键代码</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// Create the primitive&#x27;s scene proxy.</span></span><br><span class="line">    FPrimitiveSceneProxy* PrimitiveSceneProxy = Primitive-&gt;<span class="built_in">CreateSceneProxy</span>();</span><br><span class="line">    Primitive-&gt;SceneProxy = PrimitiveSceneProxy;</span><br><span class="line">    <span class="keyword">if</span>(!PrimitiveSceneProxy)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// Primitives which don&#x27;t have a proxy are irrelevant to the scene manager.</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the primitive scene info.</span></span><br><span class="line">    FPrimitiveSceneInfo* PrimitiveSceneInfo = <span class="keyword">new</span> <span class="built_in">FPrimitiveSceneInfo</span>(Primitive, <span class="keyword">this</span>);</span><br><span class="line">    PrimitiveSceneProxy-&gt;PrimitiveSceneInfo = PrimitiveSceneInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the primitives initial transform.</span></span><br><span class="line">    FMatrix RenderMatrix = Primitive-&gt;<span class="built_in">GetRenderMatrix</span>();</span><br><span class="line">    <span class="function">FVector <span class="title">AttachmentRootPosition</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    AActor* AttachmentRoot = Primitive-&gt;<span class="built_in">GetAttachmentRootActor</span>();</span><br><span class="line">    <span class="keyword">if</span> (AttachmentRoot)</span><br><span class="line">    &#123;</span><br><span class="line">       AttachmentRootPosition = AttachmentRoot-&gt;<span class="built_in">GetActorLocation</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FCreateRenderThreadParameters</span></span><br><span class="line">    &#123;</span><br><span class="line">       FPrimitiveSceneProxy* PrimitiveSceneProxy;</span><br><span class="line">       FMatrix RenderMatrix;</span><br><span class="line">       FBoxSphereBounds WorldBounds;</span><br><span class="line">       FVector AttachmentRootPosition;</span><br><span class="line">       FBoxSphereBounds LocalBounds;</span><br><span class="line">    &#125;;</span><br><span class="line">    FCreateRenderThreadParameters Params =</span><br><span class="line">    &#123;</span><br><span class="line">       PrimitiveSceneProxy,</span><br><span class="line">       RenderMatrix,</span><br><span class="line">       Primitive-&gt;Bounds,</span><br><span class="line">       AttachmentRootPosition,</span><br><span class="line">       Primitive-&gt;<span class="built_in">CalcBounds</span>(FTransform::Identity)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create any RenderThreadResources required and send a command to the rendering thread to add the primitive to the scene.</span></span><br><span class="line">    FScene* Scene = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this primitive has a simulated previous transform, ensure that the velocity data for the scene representation is correct</span></span><br><span class="line">    TOptional&lt;FTransform&gt; PreviousTransform = FMotionVectorSimulation::<span class="built_in">Get</span>().<span class="built_in">GetPreviousTransform</span>(Primitive);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ENQUEUE_RENDER_COMMAND</span>(AddPrimitiveCommand)(</span><br><span class="line">       [Params = <span class="built_in">MoveTemp</span>(Params), Scene, PrimitiveSceneInfo, PreviousTransform = <span class="built_in">MoveTemp</span>(PreviousTransform)](FRHICommandListImmediate&amp; RHICmdList)</span><br><span class="line">       &#123;</span><br><span class="line">          FPrimitiveSceneProxy* SceneProxy = Params.PrimitiveSceneProxy;</span><br><span class="line">          FScopeCycleCounter <span class="built_in">Context</span>(SceneProxy-&gt;<span class="built_in">GetStatId</span>());</span><br><span class="line">          SceneProxy-&gt;<span class="built_in">SetTransform</span>(Params.RenderMatrix, Params.WorldBounds, Params.LocalBounds, Params.AttachmentRootPosition);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Create any RenderThreadResources required.</span></span><br><span class="line">          SceneProxy-&gt;<span class="built_in">CreateRenderThreadResources</span>();</span><br><span class="line"></span><br><span class="line">          Scene-&gt;<span class="built_in">AddPrimitiveSceneInfo_RenderThread</span>(PrimitiveSceneInfo, PreviousTransform);</span><br><span class="line">       &#125;);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FScene::AddPrimitiveSceneInfo_RenderThread</span><span class="params">(FPrimitiveSceneInfo* PrimitiveSceneInfo, <span class="type">const</span> TOptional&lt;FTransform&gt;&amp; PreviousTransform)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">check</span>(<span class="built_in">IsInRenderingThread</span>());</span><br><span class="line"><span class="built_in">check</span>(PrimitiveSceneInfo-&gt;PackedIndex == INDEX_NONE);</span><br><span class="line"><span class="built_in">check</span>(!AddedPrimitiveSceneInfos.<span class="built_in">Contains</span>(PrimitiveSceneInfo));</span><br><span class="line">AddedPrimitiveSceneInfos.<span class="built_in">Add</span>(PrimitiveSceneInfo);</span><br><span class="line"><span class="keyword">if</span> (PreviousTransform.<span class="built_in">IsSet</span>())</span><br><span class="line">&#123;</span><br><span class="line">OverridenPreviousTransforms.<span class="built_in">Add</span>(PrimitiveSceneInfo, PreviousTransform.<span class="built_in">GetValue</span>().<span class="built_in">ToMatrixWithScale</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    接下来就是在渲染线程更新这些PrimitiveSceneInfo数据，具体调用接口在FScene::UpdateAllPrimitiveSceneInfos，这个函数总共包含500+行的代码，我们可以分块看它的主体实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FScene::UpdateAllPrimitiveSceneInfos</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList, <span class="type">bool</span> bAsyncCreateLPIs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//处理场景中移除的图元</span></span><br><span class="line">    <span class="keyword">while</span> (RemovedLocalPrimitiveSceneInfos.<span class="built_in">Num</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理场景中增加的图元</span></span><br><span class="line">    <span class="keyword">while</span> (AddedLocalPrimitiveSceneInfos.<span class="built_in">Num</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理场景中更新的图元</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; Transform : UpdatedTransforms)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理其他数据 比如距离场</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The following arrays are densely packed primitive data needed by various</span></span><br><span class="line"><span class="comment"> * rendering passes. PrimitiveSceneInfo-&gt;PackedIndex maintains the index</span></span><br><span class="line"><span class="comment"> * where data is stored in these arrays for a given primitive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Packed array of primitives in the scene. */</span></span><br><span class="line">TArray&lt;FPrimitiveSceneInfo*&gt; Primitives;</span><br><span class="line"><span class="comment">/** Packed array of all transforms in the scene. */</span></span><br><span class="line">TArray&lt;FMatrix&gt; PrimitiveTransforms;</span><br><span class="line"><span class="comment">/** Packed array of primitive scene proxies in the scene. */</span></span><br><span class="line">TArray&lt;FPrimitiveSceneProxy*&gt; PrimitiveSceneProxies;</span><br><span class="line"><span class="comment">/** Packed array of primitive bounds. */</span></span><br><span class="line">TArray&lt;FPrimitiveBounds&gt; PrimitiveBounds;</span><br><span class="line"><span class="comment">/** Packed array of primitive flags. */</span></span><br><span class="line">TArray&lt;FPrimitiveFlagsCompact&gt; PrimitiveFlagsCompact;</span><br><span class="line"><span class="comment">/** Packed array of precomputed primitive visibility IDs. */</span></span><br><span class="line">TArray&lt;FPrimitiveVisibilityId&gt; PrimitiveVisibilityIds;</span><br><span class="line"><span class="comment">/** Packed array of primitive occlusion flags. See EOcclusionFlags. */</span></span><br><span class="line">TArray&lt;uint8&gt; PrimitiveOcclusionFlags;</span><br><span class="line"><span class="comment">/** Packed array of primitive occlusion bounds. */</span></span><br><span class="line">TArray&lt;FBoxSphereBounds&gt; PrimitiveOcclusionBounds;</span><br><span class="line"><span class="comment">/** Packed array of primitive components associated with the primitive. */</span></span><br><span class="line">TArray&lt;FPrimitiveComponentId&gt; PrimitiveComponentIds;</span><br><span class="line"><span class="comment">/** Packed array of runtime virtual texture flags. */</span></span><br><span class="line">TArray&lt;FPrimitiveVirtualTextureFlags&gt; PrimitiveVirtualTextureFlags;</span><br><span class="line"><span class="comment">/** Packed array of runtime virtual texture lod info. */</span></span><br><span class="line">TArray&lt;FPrimitiveVirtualTextureLodInfo&gt; PrimitiveVirtualTextureLod;</span><br></pre></td></tr></table></figure><p>​    在处理不同图元的时候，主要是通过更新FScene中的各种数组成员，UE把FPrimitiveSceneProxy按照类型排序存储在数组中，并且在添加和移除时通过更新TypeOffsetTable来快速交换位置，以达到减少数组内数据位置移动带来的消耗。</p><h2 id="SceneProxy-gt-MeshBatch"><a href="#SceneProxy-gt-MeshBatch" class="headerlink" title="SceneProxy-&gt;MeshBatch"></a>SceneProxy-&gt;MeshBatch</h2><p>把数据赋值给了FPrimitiveSceneInfo之后，我们 就要在渲染线程对其进行整合生成MeshBatch。MeshBatch是一组拥有相同材质，顶点数据的Mesh组合，下面是处理流程图：</p><p><img src="/2024/06/18/renderworkflow_data/workflow_addstaticmesh.png" alt></p><p>​    在更新场景时，会调用FPrimitiveSceneInfo::AddToScene来把数据真正传递给渲染线程，通过SCOPE事件，我们大概能看出每一部分在做什么，比如更新Lightmap，Bounds等等，我们这里关注AddStaticMeshes的调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPrimitiveSceneInfo::AddToScene</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList, FScene* Scene, <span class="type">const</span> TArrayView&lt;FPrimitiveSceneInfo*&gt;&amp; SceneInfos, <span class="type">bool</span> bUpdateStaticDrawLists, <span class="type">bool</span> bAddToStaticDrawLists, <span class="type">bool</span> bAsyncCreateLPIs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">check</span>(<span class="built_in">IsInRenderingThread</span>());</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_IndirectLightingCacheUniformBuffer, FColor::Turquoise);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_IndirectLightingCacheAllocation, FColor::Orange);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_LightmapDataOffset, FColor::Green);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_ReflectionCaptures, FColor::Yellow);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_AddStaticMeshes, FColor::Magenta);</span><br><span class="line">       <span class="keyword">if</span> (bUpdateStaticDrawLists)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">AddStaticMeshes</span>(RHICmdList, Scene, SceneInfos, bAddToStaticDrawLists);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_AddToPrimitiveOctree, FColor::Red);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_UpdateBounds, FColor::Cyan);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_UpdateVirtualTexture, FColor::Emerald);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在AddStaticMeshes中，主要做了三步，首先DrawStaticElements填充PrimitiveSceneInfo的MeshBatch数据，然后把MeshBatch数据转移到Scene的StaticMeshes数组中，统一管理，然后缓存MeshDrawCommands。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPrimitiveSceneInfo::AddStaticMeshes</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList, FScene* Scene, <span class="type">const</span> TArrayView&lt;FPrimitiveSceneInfo*&gt;&amp; SceneInfos, <span class="type">bool</span> bAddToStaticDrawLists)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LLM_SCOPE</span>(ELLMTag::StaticMesh);</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">ParallelForTemplate</span>(SceneInfos.<span class="built_in">Num</span>(), [Scene, &amp;SceneInfos](int32 Index)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddStaticMeshes_DrawStaticElements, FColor::Magenta);</span><br><span class="line">          FPrimitiveSceneInfo* SceneInfo = SceneInfos[Index];</span><br><span class="line">          <span class="comment">// Cache the primitive&#x27;s static mesh elements.</span></span><br><span class="line">          FBatchingSPDI <span class="built_in">BatchingSPDI</span>(SceneInfo);</span><br><span class="line">          BatchingSPDI.<span class="built_in">SetHitProxy</span>(SceneInfo-&gt;DefaultDynamicHitProxy);</span><br><span class="line">           <span class="comment">//创建MeshBatch</span></span><br><span class="line">          SceneInfo-&gt;Proxy-&gt;<span class="built_in">DrawStaticElements</span>(&amp;BatchingSPDI);</span><br><span class="line">          SceneInfo-&gt;StaticMeshes.<span class="built_in">Shrink</span>();</span><br><span class="line">          SceneInfo-&gt;StaticMeshRelevances.<span class="built_in">Shrink</span>();</span><br><span class="line"></span><br><span class="line">          <span class="built_in">check</span>(SceneInfo-&gt;StaticMeshRelevances.<span class="built_in">Num</span>() == SceneInfo-&gt;StaticMeshes.<span class="built_in">Num</span>());</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddStaticMeshes_UpdateSceneArrays, FColor::Blue);</span><br><span class="line">       <span class="keyword">for</span> (FPrimitiveSceneInfo* SceneInfo : SceneInfos)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">for</span> (int32 MeshIndex = <span class="number">0</span>; MeshIndex &lt; SceneInfo-&gt;StaticMeshes.<span class="built_in">Num</span>(); MeshIndex++)</span><br><span class="line">          &#123;</span><br><span class="line">             FStaticMeshBatchRelevance&amp; MeshRelevance = SceneInfo-&gt;StaticMeshRelevances[MeshIndex];</span><br><span class="line">             FStaticMeshBatch&amp; Mesh = SceneInfo-&gt;StaticMeshes[MeshIndex];</span><br><span class="line"></span><br><span class="line">             <span class="comment">// Add the static mesh to the scene&#x27;s static mesh list.</span></span><br><span class="line">             FSparseArrayAllocationInfo SceneArrayAllocation = Scene-&gt;StaticMeshes.<span class="built_in">AddUninitialized</span>();</span><br><span class="line">             Scene-&gt;StaticMeshes[SceneArrayAllocation.Index] = &amp;Mesh;</span><br><span class="line">             Mesh.Id = SceneArrayAllocation.Index;</span><br><span class="line">             MeshRelevance.Id = SceneArrayAllocation.Index;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bAddToStaticDrawLists)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">CacheMeshDrawCommands</span>(RHICmdList, Scene, SceneInfos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DrawStaticElements"><a href="#DrawStaticElements" class="headerlink" title="DrawStaticElements"></a>DrawStaticElements</h3><p>我们接着看第一步具体做了什么FStaticMeshSceneProxy::DrawStaticElements，这里只关注主体分支的调用，其他一些特殊情况的分支实现基本相同，比如当指定ForcedLodModel时，我们只对指定LOD的Mesh数据创建MeshBatch。这里主要调用了两个接口填充MeshBatch，GetMeshElement和DrawMeshes，其中GetMeshElement主要负责把VF，LOD，Material相关数据从staticmesh的数据结构中存储到Meshbatch，而drawmeshes负责把meshbatch数据存储到FPrimitiveSceneInfo的StaticMeshes数组中，此外还额外存储了StaticMeshRelevances（与StaticMesh相同，存储了一些其他信息，但为了效率需要特殊处理，后续会提到）。到这一步就完成了渲染数据从场景中的StaticMesh转移到了渲染线程中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FStaticMeshSceneProxy::DrawStaticElements</span><span class="params">(FStaticPrimitiveDrawInterface* PDI)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// Draw the static mesh elements.</span></span><br><span class="line">             <span class="keyword">for</span>(int32 SectionIndex = <span class="number">0</span>;SectionIndex &lt; LODModel.Sections.<span class="built_in">Num</span>();SectionIndex++)</span><br><span class="line">             &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_EDITOR</span></span><br><span class="line">                <span class="keyword">if</span>( GIsEditor )</span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="type">const</span> FLODInfo::FSectionInfo&amp; Section = LODs[LODIndex].Sections[SectionIndex];</span><br><span class="line"></span><br><span class="line">                   bIsMeshElementSelected = Section.bSelected;</span><br><span class="line">                   PDI-&gt;<span class="built_in">SetHitProxy</span>(Section.HitProxy);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WITH_EDITOR</span></span></span><br><span class="line"></span><br><span class="line">                <span class="type">const</span> int32 NumBatches = <span class="built_in">GetNumMeshBatches</span>();</span><br><span class="line">                PDI-&gt;<span class="built_in">ReserveMemoryForMeshes</span>(NumBatches * (<span class="number">1</span> + NumRuntimeVirtualTextureTypes));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (int32 BatchIndex = <span class="number">0</span>; BatchIndex &lt; NumBatches; BatchIndex++)</span><br><span class="line">                &#123;</span><br><span class="line">                   FMeshBatch BaseMeshBatch;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="built_in">GetMeshElement</span>(LODIndex, BatchIndex, SectionIndex, PrimitiveDPG, bIsMeshElementSelected, <span class="literal">true</span>, BaseMeshBatch))</span><br><span class="line">                   &#123;</span><br><span class="line">                      <span class="keyword">if</span> (NumRuntimeVirtualTextureTypes &gt; <span class="number">0</span>)</span><br><span class="line">                      &#123;</span><br><span class="line">                         <span class="comment">// Runtime virtual texture mesh elements.</span></span><br><span class="line">                         <span class="function">FMeshBatch <span class="title">MeshBatch</span><span class="params">(BaseMeshBatch)</span></span>;</span><br><span class="line">                         <span class="built_in">SetupMeshBatchForRuntimeVirtualTexture</span>(MeshBatch);</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">for</span> (ERuntimeVirtualTextureMaterialType MaterialType : RuntimeVirtualTextureMaterialTypes)</span><br><span class="line">                         &#123;</span><br><span class="line">                            MeshBatch.RuntimeVirtualTextureMaterialType = (uint32)MaterialType;</span><br><span class="line">                            PDI-&gt;<span class="built_in">DrawMesh</span>(MeshBatch, ScreenSize);</span><br><span class="line">                         &#125;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                      &#123;</span><br><span class="line">                         <span class="comment">// Standard mesh elements.</span></span><br><span class="line">                         <span class="comment">// If we have submitted an optimized shadow-only mesh, remaining mesh elements must not cast shadows.</span></span><br><span class="line">                         <span class="function">FMeshBatch <span class="title">MeshBatch</span><span class="params">(BaseMeshBatch)</span></span>;</span><br><span class="line">                         MeshBatch.CastShadow &amp;= !bUseUnifiedMeshForShadow;</span><br><span class="line">                         MeshBatch.bUseAsOccluder &amp;= !bUseUnifiedMeshForDepth;</span><br><span class="line">                         MeshBatch.bUseForDepthPass &amp;= !bUseUnifiedMeshForDepth;</span><br><span class="line">                         PDI-&gt;<span class="built_in">DrawMesh</span>(MeshBatch, ScreenSize);</span><br><span class="line">                      &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MeshBatch-gt-MeshDrawCommands"><a href="#MeshBatch-gt-MeshDrawCommands" class="headerlink" title="MeshBatch-&gt;MeshDrawCommands"></a>MeshBatch-&gt;MeshDrawCommands</h2><p>MeshDrawCommands是由MeshBatch生成，最终会交给RHI线程的一组渲染命令，包含渲染关系状态，Shader绑定状态，Mesh信息等等。</p><p>FMeshPassProcessor是一个将MeshBatch转换成MeshDrawCommands的工具类，有多种Pass子类实现。</p><p>注意：这里因为是处理StaticMesh，所以最终MeshDrawCommands会存储到CachedDrawCommands中</p><h3 id="CacheMeshDrawCommands"><a href="#CacheMeshDrawCommands" class="headerlink" title="CacheMeshDrawCommands"></a>CacheMeshDrawCommands</h3><p>​    这一步做的事情很多，主要是缓存对应的MeshDrawCommands，在后面的工作流中也会用到这里的结果。看代码可以发现主要是通过多线程执行对应的lambda，首先预创建StaticMeshCommandInfos数据结构，大小等于Meshbatch*MeshPassNum，然后通过PassMeshProcessor创建对应的MeshDrawCommands，并填充StaticMeshCommandInfos数据结构，这个结构在后面标记相关性时会用到。下面截取CacheMeshDrawCommands的主要代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPrimitiveSceneInfo::CacheMeshDrawCommands</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList, FScene* Scene, <span class="type">const</span> TArrayView&lt;FPrimitiveSceneInfo*&gt;&amp; SceneInfos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...预创建StaticMeshCommandInfos</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> DoWorkLambda = [Scene, SceneInfos](int32 Index)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">for</span> (int32 PassIndex = <span class="number">0</span>; PassIndex &lt; EMeshPass::Num; PassIndex++)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="type">const</span> EShadingPath ShadingPath = Scene-&gt;<span class="built_in">GetShadingPath</span>();</span><br><span class="line">          EMeshPass::Type PassType = (EMeshPass::Type)PassIndex;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((FPassProcessorManager::<span class="built_in">GetPassFlags</span>(ShadingPath, PassType) &amp; EMeshPassFlags::CachedMeshCommands) != EMeshPassFlags::None)</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="function">FCachedMeshDrawCommandInfo <span class="title">CommandInfo</span><span class="params">(PassType)</span></span>;</span><br><span class="line"></span><br><span class="line">             FCriticalSection&amp; CachedMeshDrawCommandLock = Scene-&gt;CachedMeshDrawCommandLock[PassType];</span><br><span class="line">             FCachedPassMeshDrawList&amp; SceneDrawList = Scene-&gt;CachedDrawLists[PassType];</span><br><span class="line">             FStateBucketMap&amp; CachedMeshDrawCommandStateBuckets = Scene-&gt;CachedMeshDrawCommandStateBuckets[PassType];</span><br><span class="line">              <span class="comment">//将CommandInfo传入context，MeshDrawCommands最后会填充这个结构</span></span><br><span class="line">             <span class="function">FCachedPassMeshDrawListContext <span class="title">CachedPassMeshDrawListContext</span><span class="params">(CommandInfo, CachedMeshDrawCommandLock, SceneDrawList, CachedMeshDrawCommandStateBuckets, *Scene)</span></span>;</span><br><span class="line"><span class="comment">//这里拿到MeshProcessor创建函数</span></span><br><span class="line">             PassProcessorCreateFunction CreateFunction = FPassProcessorManager::<span class="built_in">GetCreateFunction</span>(ShadingPath, PassType);</span><br><span class="line">             <span class="comment">//获得具体的Processor</span></span><br><span class="line">              FMeshPassProcessor* PassMeshProcessor = <span class="built_in">CreateFunction</span>(Scene, <span class="literal">nullptr</span>, &amp;CachedPassMeshDrawListContext);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (PassMeshProcessor != <span class="literal">nullptr</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> FMeshInfoAndIndex&amp; MeshAndInfo : MeshBatches)</span><br><span class="line">                &#123;</span><br><span class="line">                   FPrimitiveSceneInfo* SceneInfo = SceneInfos[MeshAndInfo.InfoIndex];</span><br><span class="line">                   FStaticMeshBatch&amp; Mesh = SceneInfo-&gt;StaticMeshes[MeshAndInfo.MeshIndex];</span><br><span class="line">                   </span><br><span class="line">                   CommandInfo = <span class="built_in">FCachedMeshDrawCommandInfo</span>(PassType);</span><br><span class="line">                   FStaticMeshBatchRelevance&amp; MeshRelevance = SceneInfo-&gt;StaticMeshRelevances[MeshAndInfo.MeshIndex];</span><br><span class="line"></span><br><span class="line">                   <span class="built_in">check</span>(!MeshRelevance.CommandInfosMask.<span class="built_in">Get</span>(PassType));</span><br><span class="line"></span><br><span class="line">                   uint64 BatchElementMask = ~<span class="number">0ull</span>;</span><br><span class="line">                    <span class="comment">//添加对应的Meshbatch，并生成MeshDrawCommands，这里</span></span><br><span class="line">                   PassMeshProcessor-&gt;<span class="built_in">AddMeshBatch</span>(Mesh, BatchElementMask, SceneInfo-&gt;Proxy);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (CommandInfo.CommandIndex != <span class="number">-1</span> || CommandInfo.StateBucketId != <span class="number">-1</span>)</span><br><span class="line">                   &#123;</span><br><span class="line">                      <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(MeshRelevance.CommandInfosMask) * <span class="number">8</span> &gt;= EMeshPass::Num, <span class="string">&quot;CommandInfosMask is too small to contain all mesh passes.&quot;</span>);</span><br><span class="line">                      MeshRelevance.CommandInfosMask.<span class="built_in">Set</span>(PassType);</span><br><span class="line">                      MeshRelevance.CommandInfosBase++;</span><br><span class="line"></span><br><span class="line">                      <span class="type">int</span> CommandInfoIndex = MeshAndInfo.MeshIndex * EMeshPass::Num + PassType;</span><br><span class="line">                      <span class="built_in">check</span>(SceneInfo-&gt;StaticMeshCommandInfos[CommandInfoIndex].MeshPass == EMeshPass::Num);</span><br><span class="line">                       <span class="comment">//填充StaticMeshCommandInfos数据结构</span></span><br><span class="line">                      SceneInfo-&gt;StaticMeshCommandInfos[CommandInfoIndex] = CommandInfo;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                PassMeshProcessor-&gt;~<span class="built_in">FMeshPassProcessor</span>();</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后续其他处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    我们接着看AddMeshBatch是如何生成MeshDrawCommands的，内部调用了TryAddMeshBatch，然后通过对应Processor的Process接口调用BuildMeshDrawCommands最终生MeshDrawCommands。</p><p>BuildMeshDrawCommands这里会设置对应的材质shader，管线状态，以及VF声明。最后调用FinalizeCommand接口填充GPUScene用来合批的StateBuckets，以及把MeshDrawCommands放入Scene-&gt;CachedDrawLists[PassType]中，并把对应下标赋值给最开始传入Processsor的context的CommandInfo，也就是PrimitiveInfo中StaticMeshCommandInfos要赋值的对象。</p><p>这里涉及的函数太多就不展开了，总之我们知道这一步生成了MeshDrawCommands，并且存在了TaskContext的成员中，并且primitivesceneInfo中保存了对应的下标，这里TaskContext的保存MeshDrawCommands的成员就是最开始创建Processor中指定的Drawlist，也就是上面代码中的Scene-&gt;CachedDrawLists。</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPUScene</title>
      <link href="/2024/06/13/GPUScene/"/>
      <url>/2024/06/13/GPUScene/</url>
      
        <content type="html"><![CDATA[<h1 id="GPUScene"><a href="#GPUScene" class="headerlink" title="GPUScene"></a>GPUScene</h1><p>GPUScene是UE用来实例化渲染的代码手段，想象场景中包含了数十上百个一样的物体，他们的材质，顶点信息都一样，不同的是他们的位置，缩放等不同，那么我们是否可以通过一个drawcall，来渲染这一批看起来是一个模板的物体，DX和OpenGL都提供了对应的API，我们统称为实例化渲染，本章主要是讲UE是怎么封装这些API，实现自动合批的。</p><span id="more"></span><p>要搞明白上面的问题，我们首先需要知道我们需要哪些信息，才能实现自动合批？首先我们需要知道哪些物体是可以合批的，因为UE是通过Meshdrawcommands来提交绘制的，所以我们需要把同批次的Meshdrawcommands合并，然后在提交绘制时选择对应的实例化绘制API，最终在shader中根据实例化id获取当前实例的数据(如变换矩阵等)来进行渲染。</p><p>UE的做法基本和我们需要的一致，流程如下：</p><h2 id="收集同批次的Meshdrawcommands"><a href="#收集同批次的Meshdrawcommands" class="headerlink" title="收集同批次的Meshdrawcommands"></a>收集同批次的Meshdrawcommands</h2><p>UE的静态绘制路径会生成对应的MeshDrawcommands，调用函数如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FCachedPassMeshDrawListContext::FinalizeCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FMeshBatch&amp; MeshBatch, </span></span></span><br><span class="line"><span class="params"><span class="function">    int32 BatchElementIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32 DrawPrimitiveId,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32 ScenePrimitiveId,</span></span></span><br><span class="line"><span class="params"><span class="function">    ERasterizerFillMode MeshFillMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    ERasterizerCullMode MeshCullMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    FMeshDrawCommandSortKey SortKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FGraphicsMinimalPipelineStateInitializer&amp; PipelineState,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FMeshProcessorShaders* ShadersForDebugging,</span></span></span><br><span class="line"><span class="params"><span class="function">    FMeshDrawCommand&amp; MeshDrawCommand)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FGraphicsMinimalPipelineStateId PipelineId = FGraphicsMinimalPipelineStateId::<span class="built_in">GetPersistentId</span>(PipelineState);</span><br><span class="line"></span><br><span class="line">    MeshDrawCommand.<span class="built_in">SetDrawParametersAndFinalize</span>(MeshBatch, BatchElementIndex, PipelineId, ShadersForDebugging);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UseGPUScene</span>(GMaxRHIShaderPlatform, GMaxRHIFeatureLevel))</span><br><span class="line">       &#123;</span><br><span class="line">       Experimental::FHashElementId SetId;</span><br><span class="line">       <span class="keyword">auto</span> hash = CachedMeshDrawCommandStateBuckets.<span class="built_in">ComputeHash</span>(MeshDrawCommand);</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="function">FScopeLock <span class="title">Lock</span><span class="params">(&amp;CachedMeshDrawCommandLock)</span></span>;</span><br><span class="line">          SetId = CachedMeshDrawCommandStateBuckets.<span class="built_in">FindOrAddIdByHash</span>(hash, MeshDrawCommand, <span class="built_in">FMeshDrawCommandCount</span>());</span><br><span class="line">          .<span class="built_in">GetByElementId</span>(SetId).Value.Num++;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MESH_DRAW_COMMAND_DEBUG_DATA</span></span><br><span class="line">          <span class="keyword">if</span> (CachedMeshDrawCommandStateBuckets.<span class="built_in">GetByElementId</span>(SetId).Value.Num == <span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">          MeshDrawCommand.<span class="built_in">ClearDebugPrimitiveSceneProxy</span>(); <span class="comment">//When using State Buckets multiple PrimitiveSceneProxies use the same MeshDrawCommand, so The PrimitiveSceneProxy pointer can&#x27;t be stored.</span></span><br><span class="line">          &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">check</span>(CommandInfo.StateBucketId == <span class="number">-1</span>);</span><br><span class="line">       CommandInfo.StateBucketId = SetId.<span class="built_in">GetIndex</span>();</span><br><span class="line">       <span class="built_in">check</span>(CommandInfo.CommandIndex == <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看到这里用了一个比较关键的数据结构：CachedMeshDrawCommandStateBuckets，key是meshdrawcommands的hash。</p><p>看代码可以发现，Buckets的模板参数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FStateBucketMap = Experimental::TRobinHoodHashMap&lt;FMeshDrawCommand, FMeshDrawCommandCount, MeshDrawCommandKeyFuncs&gt;;</span><br></pre></td></tr></table></figure><p>上面的ComputeHash最终调用MeshDrawCommandKeyFuncs内的实现：GetDynamicInstancingHash，传入当前MeshdrawCommands的VertexBuffer，VertexStream等等决定合批的因素。</p><p>FindOrAddIdByHash最终调用MeshDrawCommandKeyFuncs内的Matches，也就是MeshDrawCommands的MatchesForDynamicInstancing，这里就是决定是否可以合批的判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MatchesForDynamicInstancing</span><span class="params">(<span class="type">const</span> FMeshDrawCommand&amp; Rhs)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CachedPipelineId == Rhs.CachedPipelineId</span><br><span class="line">       &amp;&amp; StencilRef == Rhs.StencilRef</span><br><span class="line">       &amp;&amp; ShaderBindings.<span class="built_in">MatchesForDynamicInstancing</span>(Rhs.ShaderBindings)</span><br><span class="line">       &amp;&amp; VertexStreams == Rhs.VertexStreams</span><br><span class="line">       &amp;&amp; PrimitiveIdStreamIndex == Rhs.PrimitiveIdStreamIndex</span><br><span class="line">       &amp;&amp; IndexBuffer == Rhs.IndexBuffer</span><br><span class="line">       &amp;&amp; FirstIndex == Rhs.FirstIndex</span><br><span class="line">       &amp;&amp; NumPrimitives == Rhs.NumPrimitives</span><br><span class="line">       &amp;&amp; NumInstances == Rhs.NumInstances</span><br><span class="line">       &amp;&amp; ((NumPrimitives &gt; <span class="number">0</span> &amp;&amp; VertexParams.BaseVertexIndex == Rhs.VertexParams.BaseVertexIndex &amp;&amp; VertexParams.NumVertices == Rhs.VertexParams.NumVertices)</span><br><span class="line">          || (NumPrimitives == <span class="number">0</span> &amp;&amp; IndirectArgs.Buffer == Rhs.IndirectArgs.Buffer &amp;&amp; IndirectArgs.Offset == Rhs.IndirectArgs.Offset));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断具有合批条件的MeshDrawCommands，会被塞入CachedMeshDrawCommandStateBuckets同一个hash地址中，并且计数会加一。</p><h2 id="执行MeshDrawCommands合并"><a href="#执行MeshDrawCommands合并" class="headerlink" title="执行MeshDrawCommands合并"></a>执行MeshDrawCommands合并</h2><h3 id="合并Meshdrawcommands"><a href="#合并Meshdrawcommands" class="headerlink" title="合并Meshdrawcommands"></a>合并Meshdrawcommands</h3><p>上面已经将可以合并的MeshDrawCommands做了统计，放在Buckets中，然而我们渲染要执行的MeshDrawCommands数量并没有减少，接下来我们就需要对MeshDrawCommands进行真正的合并，入口在：BuildMeshDrawCommandPrimitiveIdBuffer。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMeshDrawCommandPrimitiveIdBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bDynamicInstancing,</span></span></span><br><span class="line"><span class="params"><span class="function">    FMeshCommandOneFrameArray&amp; VisibleMeshDrawCommands,</span></span></span><br><span class="line"><span class="params"><span class="function">    FDynamicMeshDrawCommandStorage&amp; MeshDrawCommandStorage,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* RESTRICT PrimitiveIdData,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32 PrimitiveIdDataSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    FMeshCommandOneFrameArray&amp; TempVisibleMeshDrawCommands,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32&amp; MaxInstances,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32&amp; VisibleMeshDrawCommandsNum,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32&amp; NewPassVisibleMeshDrawCommandsNum,</span></span></span><br><span class="line"><span class="params"><span class="function">    EShaderPlatform ShaderPlatform,</span></span></span><br><span class="line"><span class="params"><span class="function">    uint32 InstanceFactor = <span class="number">1</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">QUICK_SCOPE_CYCLE_COUNTER</span>(STAT_BuildMeshDrawCommandPrimitiveIdBuffer);</span><br><span class="line">    <span class="built_in">check</span>(PrimitiveIdData &amp;&amp; PrimitiveIdDataSize &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> FVisibleMeshDrawCommand* RESTRICT PassVisibleMeshDrawCommands = VisibleMeshDrawCommands.<span class="built_in">GetData</span>();</span><br><span class="line">    <span class="type">const</span> int32 NumDrawCommands = VisibleMeshDrawCommands.<span class="built_in">Num</span>();</span><br><span class="line"></span><br><span class="line">    uint32 PrimitiveIdIndex = <span class="number">0</span>;</span><br><span class="line">    int32* RESTRICT PrimitiveIds = (int32*)PrimitiveIdData;</span><br><span class="line">    <span class="type">const</span> uint32 MaxPrimitiveId = PrimitiveIdDataSize / <span class="built_in">sizeof</span>(int32);</span><br><span class="line"><span class="comment">//动态合批</span></span><br><span class="line">    <span class="keyword">if</span> (bDynamicInstancing)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">QUICK_SCOPE_CYCLE_COUNTER</span>(STAT_DynamicInstancingOfVisibleMeshDrawCommands);</span><br><span class="line">       <span class="built_in">check</span>(VisibleMeshDrawCommands.<span class="built_in">Num</span>() &lt;= TempVisibleMeshDrawCommands.<span class="built_in">Max</span>() &amp;&amp; TempVisibleMeshDrawCommands.<span class="built_in">Num</span>() == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       int32 CurrentStateBucketId = <span class="number">-1</span>;</span><br><span class="line">       uint32* RESTRICT CurrentDynamicallyInstancedMeshCommandNumInstances = <span class="literal">nullptr</span>;</span><br><span class="line">       MaxInstances = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (int32 DrawCommandIndex = <span class="number">0</span>; DrawCommandIndex &lt; NumDrawCommands; DrawCommandIndex++)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="type">const</span> FVisibleMeshDrawCommand&amp; RESTRICT VisibleMeshDrawCommand = PassVisibleMeshDrawCommands[DrawCommandIndex];</span><br><span class="line"><span class="comment">//如果遇到和上一个可以合批的commands</span></span><br><span class="line">          <span class="keyword">if</span> (VisibleMeshDrawCommand.StateBucketId == CurrentStateBucketId &amp;&amp; VisibleMeshDrawCommand.StateBucketId != <span class="number">-1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//有Meshdrawcommandsinstance计数，直接加一</span></span><br><span class="line">             <span class="keyword">if</span> (CurrentDynamicallyInstancedMeshCommandNumInstances)</span><br><span class="line">             &#123;</span><br><span class="line">                <span class="type">const</span> int32 CurrentNumInstances = *CurrentDynamicallyInstancedMeshCommandNumInstances;</span><br><span class="line">                *CurrentDynamicallyInstancedMeshCommandNumInstances = CurrentNumInstances + <span class="number">1</span>;</span><br><span class="line">                MaxInstances = FMath::<span class="built_in">Max</span>(MaxInstances, CurrentNumInstances + <span class="number">1</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//没有的就直接把Commands拷贝进新数组</span></span><br><span class="line">                FVisibleMeshDrawCommand NewVisibleMeshDrawCommand = VisibleMeshDrawCommand;</span><br><span class="line">                NewVisibleMeshDrawCommand.PrimitiveIdBufferOffset = PrimitiveIdIndex;</span><br><span class="line">                TempVisibleMeshDrawCommands.<span class="built_in">Emplace</span>(<span class="built_in">MoveTemp</span>(NewVisibleMeshDrawCommand));</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">             <span class="comment">// First time state bucket setup</span></span><br><span class="line">             CurrentStateBucketId = VisibleMeshDrawCommand.StateBucketId;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (VisibleMeshDrawCommand.StateBucketId != INDEX_NONE</span><br><span class="line">                &amp;&amp; VisibleMeshDrawCommand.MeshDrawCommand-&gt;PrimitiveIdStreamIndex &gt;= <span class="number">0</span></span><br><span class="line">                &amp;&amp; VisibleMeshDrawCommand.MeshDrawCommand-&gt;NumInstances == <span class="number">1</span></span><br><span class="line">                <span class="comment">// Don&#x27;t create a new FMeshDrawCommand for the last command and make it safe for us to look at the next command</span></span><br><span class="line">                &amp;&amp; DrawCommandIndex + <span class="number">1</span> &lt; NumDrawCommands</span><br><span class="line">                <span class="comment">// Only create a new FMeshDrawCommand if more than one draw in the state bucket</span></span><br><span class="line">                &amp;&amp; CurrentStateBucketId == PassVisibleMeshDrawCommands[DrawCommandIndex + <span class="number">1</span>].StateBucketId)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//遇到实例数&gt;1，且不是倒数第二个的commands，创建新commands</span></span><br><span class="line">                <span class="type">const</span> int32 Index = MeshDrawCommandStorage.MeshDrawCommands.<span class="built_in">AddElement</span>(*VisibleMeshDrawCommand.MeshDrawCommand);</span><br><span class="line">                FMeshDrawCommand&amp; NewCommand = MeshDrawCommandStorage.MeshDrawCommands[Index];</span><br><span class="line">                FVisibleMeshDrawCommand NewVisibleMeshDrawCommand;</span><br><span class="line"></span><br><span class="line">                NewVisibleMeshDrawCommand.<span class="built_in">Setup</span>(</span><br><span class="line">                   &amp;NewCommand,</span><br><span class="line">                   VisibleMeshDrawCommand.DrawPrimitiveId,</span><br><span class="line">                   VisibleMeshDrawCommand.ScenePrimitiveId,</span><br><span class="line">                   VisibleMeshDrawCommand.StateBucketId,</span><br><span class="line">                   VisibleMeshDrawCommand.MeshFillMode,</span><br><span class="line">                   VisibleMeshDrawCommand.MeshCullMode,</span><br><span class="line">                   VisibleMeshDrawCommand.SortKey);</span><br><span class="line"></span><br><span class="line">                NewVisibleMeshDrawCommand.PrimitiveIdBufferOffset = PrimitiveIdIndex;</span><br><span class="line">                TempVisibleMeshDrawCommands.<span class="built_in">Emplace</span>(<span class="built_in">MoveTemp</span>(NewVisibleMeshDrawCommand));</span><br><span class="line"></span><br><span class="line">                CurrentDynamicallyInstancedMeshCommandNumInstances = &amp;NewCommand.NumInstances;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//直接拷贝commands</span></span><br><span class="line">                CurrentDynamicallyInstancedMeshCommandNumInstances = <span class="literal">nullptr</span>;</span><br><span class="line">                FVisibleMeshDrawCommand NewVisibleMeshDrawCommand = VisibleMeshDrawCommand;</span><br><span class="line">                NewVisibleMeshDrawCommand.PrimitiveIdBufferOffset = PrimitiveIdIndex;</span><br><span class="line">                TempVisibleMeshDrawCommands.<span class="built_in">Emplace</span>(<span class="built_in">MoveTemp</span>(NewVisibleMeshDrawCommand));</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//@todo - refactor into instance step rate in the RHI</span></span><br><span class="line">          <span class="keyword">for</span> (uint32 InstanceFactorIndex = <span class="number">0</span>; InstanceFactorIndex &lt; InstanceFactor; InstanceFactorIndex++, PrimitiveIdIndex++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//填充primitiveid数组</span></span><br><span class="line">             <span class="comment">//@todo - refactor into memcpy</span></span><br><span class="line">             <span class="built_in">checkSlow</span>(PrimitiveIdIndex &lt; MaxPrimitiveId);</span><br><span class="line">             <span class="keyword">if</span> (!<span class="built_in">GPUSceneUseTexture2D</span>(ShaderPlatform))</span><br><span class="line">             &#123;</span><br><span class="line">                PrimitiveIds[PrimitiveIdIndex] = VisibleMeshDrawCommand.DrawPrimitiveId;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                <span class="comment">//Packing for mobile texture2D GPUScene. Must be in sync with SceneData.ush</span></span><br><span class="line">                uint16 PrimitivesPerTextureLine = FPrimitiveSceneShaderData::<span class="built_in">GetPrimitivesPerTextureLine</span>();</span><br><span class="line">                PrimitiveIds[PrimitiveIdIndex] = ((VisibleMeshDrawCommand.DrawPrimitiveId / PrimitivesPerTextureLine) &lt;&lt; <span class="number">16</span>) | (VisibleMeshDrawCommand.DrawPrimitiveId % PrimitivesPerTextureLine);</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Setup instancing stats for logging.</span></span><br><span class="line">       VisibleMeshDrawCommandsNum = VisibleMeshDrawCommands.<span class="built_in">Num</span>();</span><br><span class="line">       NewPassVisibleMeshDrawCommandsNum = TempVisibleMeshDrawCommands.<span class="built_in">Num</span>();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Replace VisibleMeshDrawCommands</span></span><br><span class="line">       FMemory::<span class="built_in">Memswap</span>(&amp;VisibleMeshDrawCommands, &amp;TempVisibleMeshDrawCommands, <span class="built_in">sizeof</span>(TempVisibleMeshDrawCommands));</span><br><span class="line">       TempVisibleMeshDrawCommands.<span class="built_in">Reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">QUICK_SCOPE_CYCLE_COUNTER</span>(STAT_BuildVisibleMeshDrawCommandPrimitiveIdBuffers);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (int32 DrawCommandIndex = <span class="number">0</span>; DrawCommandIndex &lt; NumDrawCommands; DrawCommandIndex++)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="type">const</span> FVisibleMeshDrawCommand&amp; VisibleMeshDrawCommand = VisibleMeshDrawCommands[DrawCommandIndex];</span><br><span class="line">          <span class="keyword">for</span> (uint32 InstanceFactorIndex = <span class="number">0</span>; InstanceFactorIndex &lt; InstanceFactor; InstanceFactorIndex++, PrimitiveIdIndex++)</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="built_in">checkSlow</span>(PrimitiveIdIndex &lt; MaxPrimitiveId);</span><br><span class="line">             PrimitiveIds[PrimitiveIdIndex] = VisibleMeshDrawCommand.DrawPrimitiveId;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这一步主要是合并meshdrawcommands，以及填充primitiveids数组，此数组最终会被填充到vertexfactory的vertexstream中，用来在shader中获取对应的primitivedata实例数据。数据传输顺序是：primitiveids是由FMeshDrawCommandPassSetupTask.Context.PrimitiveIdBufferData赋值，PrimitiveIdBufferData在FParallelMeshDrawCommandPass::DispatchDraw时会memcpy给PrimitiveIdsBuffer，最终PrimitiveIdsBuffer会被传给SubmitMeshDrawCommandsRange接口进行绘制，在接口中数据被赋值给VertexStream。</p><h3 id="设置meshdrawcommands的primitiveid数据"><a href="#设置meshdrawcommands的primitiveid数据" class="headerlink" title="设置meshdrawcommands的primitiveid数据"></a>设置meshdrawcommands的primitiveid数据</h3><p>下面截取部分SubmitDraw的实现，主要包含VertexStream赋值操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int32 VertexBindingIndex = <span class="number">0</span>; VertexBindingIndex &lt; MeshDrawCommand.VertexStreams.<span class="built_in">Num</span>(); VertexBindingIndex++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> FVertexInputStream&amp; Stream = MeshDrawCommand.VertexStreams[VertexBindingIndex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MeshDrawCommand.PrimitiveIdStreamIndex != <span class="number">-1</span> &amp;&amp; Stream.StreamIndex == MeshDrawCommand.PrimitiveIdStreamIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在这里赋值给对应的Stream</span></span><br><span class="line">       RHICmdList.<span class="built_in">SetStreamSource</span>(Stream.StreamIndex, ScenePrimitiveIdsBuffer, PrimitiveIdOffset);</span><br><span class="line">       StateCache.VertexStreams[Stream.StreamIndex] = Stream;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (StateCache.VertexStreams[Stream.StreamIndex] != Stream)</span><br><span class="line">    &#123;</span><br><span class="line">       RHICmdList.<span class="built_in">SetStreamSource</span>(Stream.StreamIndex, Stream.VertexBuffer, Stream.Offset);</span><br><span class="line">       StateCache.VertexStreams[Stream.StreamIndex] = Stream;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么可以通过MeshDrawCommand.PrimitiveIdStreamIndex来判断当前stream是否是primitiveid对应的Stream，原因是在buildmeshdrawcommands时就被赋值，可见UE的代码每一步都有它的用处，每到此刻会被它的设计巧妙所惊叹。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FMeshPassProcessor::BuildMeshDrawCommands</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    SharedMeshDrawCommand.PrimitiveIdStreamIndex = VertexFactory-&gt;<span class="built_in">GetPrimitiveIdStreamIndex</span>(InputStreamType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在顶点工厂数据被mesh填充时会执行下面的接口，预先创建instance需要的vertexstream：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FLocalVertexFactory::InitRHI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetType</span>()-&gt;<span class="built_in">SupportsPrimitiveIdStream</span>() &amp;&amp; bCanUseGPUScene)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这里的VertexStreamUsage指定为EVertexStreamUsage::Instancing，在寻址时，PrimitiveIdVertexStream就会是instance的寻址。</span></span><br><span class="line">StreamElements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(<span class="built_in">FVertexStreamComponent</span>(&amp;GPrimitiveIdDummy, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(uint32), VET_UInt, EVertexStreamUsage::Instancing), <span class="number">1</span>, InputStreamType));</span><br><span class="line">PrimitiveIdStreamIndex[TypeIndex] = StreamElements.<span class="built_in">Last</span>().StreamIndex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行instance绘制"><a href="#执行instance绘制" class="headerlink" title="执行instance绘制"></a>执行instance绘制</h3><p>还是在submitdraw中，根据commands的NumPrimitives字段来调用不同的RHI的API，执行instance绘制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MeshDrawCommand.IndexBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (MeshDrawCommand.NumPrimitives &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       RHICmdList.<span class="built_in">DrawIndexedPrimitive</span>(</span><br><span class="line">          MeshDrawCommand.IndexBuffer,</span><br><span class="line">          MeshDrawCommand.VertexParams.BaseVertexIndex,</span><br><span class="line">          <span class="number">0</span>,</span><br><span class="line">          MeshDrawCommand.VertexParams.NumVertices,</span><br><span class="line">          MeshDrawCommand.FirstIndex,</span><br><span class="line">          MeshDrawCommand.NumPrimitives,</span><br><span class="line">          MeshDrawCommand.NumInstances * InstanceFactor</span><br><span class="line">       );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       RHICmdList.<span class="built_in">DrawIndexedPrimitiveIndirect</span>(</span><br><span class="line">          MeshDrawCommand.IndexBuffer, </span><br><span class="line">          MeshDrawCommand.IndirectArgs.Buffer, </span><br><span class="line">          MeshDrawCommand.IndirectArgs.Offset</span><br><span class="line">          );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (MeshDrawCommand.NumPrimitives &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    RHICmdList.<span class="built_in">DrawPrimitive</span>(</span><br><span class="line">       MeshDrawCommand.VertexParams.BaseVertexIndex + MeshDrawCommand.FirstIndex,</span><br><span class="line">       MeshDrawCommand.NumPrimitives,</span><br><span class="line">          MeshDrawCommand.NumInstances * InstanceFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       RHICmdList.<span class="built_in">DrawPrimitiveIndirect</span>(</span><br><span class="line">          MeshDrawCommand.IndirectArgs.Buffer,</span><br><span class="line">          MeshDrawCommand.IndirectArgs.Offset</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在Shader中获取对应的instancedata"><a href="#在Shader中获取对应的instancedata" class="headerlink" title="在Shader中获取对应的instancedata"></a>在Shader中获取对应的instancedata</h3><p>​    在之前UE把了primitiveid数组填充进了vertexstream，对应的vertexstream是EVertexStreamUsage::Instancing类型的，也就是每个instance对应一个vertexstream中的数据，UE的顶点数据传入不是把所有的属性放在同一个buffer中传入，而是每个属性对应一个buffer，根据不同的vertexfactory，最终shader编译时include不同的ush文件，最终实现vertexfactory和shderinput的兼容。</p><p>​    Shader中获取instance数据对应scenedata.ush的接口FPrimitiveSceneData GetPrimitiveData(uint PrimitiveId)，其中primitiveid对应不同的vertexfactory中的input，以local为例子，primitiveid对应第13个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct FVertexFactoryInput</span><br><span class="line">&#123;</span><br><span class="line">    float4 Position   : ATTRIBUTE0;</span><br><span class="line"></span><br><span class="line">#if !MANUAL_VERTEX_FETCH</span><br><span class="line">    #if METAL_PROFILE</span><br><span class="line">       float3 TangentX   : ATTRIBUTE1;</span><br><span class="line">       // TangentZ.w contains sign of tangent basis determinant</span><br><span class="line">       float4 TangentZ   : ATTRIBUTE2;</span><br><span class="line"></span><br><span class="line">       float4 Color     : ATTRIBUTE3;</span><br><span class="line">    #else</span><br><span class="line">       half3  TangentX   : ATTRIBUTE1;</span><br><span class="line">       // TangentZ.w contains sign of tangent basis determinant</span><br><span class="line">       half4  TangentZ   : ATTRIBUTE2;</span><br><span class="line"></span><br><span class="line">       half4  Color     : ATTRIBUTE3;</span><br><span class="line">    #endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if USE_INSTANCING &amp;&amp; !MANUAL_VERTEX_FETCH</span><br><span class="line">    float4 InstanceOrigin : ATTRIBUTE8;  // per-instance random in w </span><br><span class="line">    half4 InstanceTransform1 : ATTRIBUTE9;  // hitproxy.r + 256 * selected in .w</span><br><span class="line">    half4 InstanceTransform2 : ATTRIBUTE10; // hitproxy.g in .w</span><br><span class="line">    half4 InstanceTransform3 : ATTRIBUTE11; // hitproxy.b in .w</span><br><span class="line">    float4 InstanceLightmapAndShadowMapUVBias : ATTRIBUTE12; </span><br><span class="line">#endif //USE_INSTANCING</span><br><span class="line"></span><br><span class="line">#if VF_USE_PRIMITIVE_SCENE_DATA</span><br><span class="line">    uint PrimitiveId : ATTRIBUTE13;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    GetPimitiveData其中调用了LoadPrimitivePrimitiveSceneDataElement，其实就是把数组数据赋值给了对应在Cpp中定义的数据结构，所以cpp中的FPrimitiveUniformShaderParameters一定要和shader中的FPrimitiveSceneData一一对应，不然就会取错下标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float4 LoadPrimitivePrimitiveSceneDataElement(FPrimitiveIndex PrimitiveIndex, uint ItemIndex)</span><br><span class="line">&#123;</span><br><span class="line">#if VF_GPU_SCENE_TEXTURE</span><br><span class="line">    return View.PrimitiveSceneDataTexture.Load(int3(PrimitiveIndex.IndX + ItemIndex, PrimitiveIndex.IndY, 0));</span><br><span class="line">#else // !VF_GPU_SCENE_TEXTURE</span><br><span class="line">    return View.PrimitiveSceneData[PrimitiveIndex.BaseOffset + ItemIndex];</span><br><span class="line">#endif // VF_GPU_SCENE_TEXTURE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    到这里还剩最后一个问题，instance的数据是如何传入到gpu的，答案就在每帧的调用的UpdateGPUScene和UploadDynamicPrimitiveShaderDataForView，我们截取UpdateGPUSceneInternal中的主要实现来看下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (NumPrimitiveDataUploads &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> int32 MaxPrimitivesUploads = <span class="built_in">GetMaxPrimitivesUpdate</span>(NumPrimitiveDataUploads, FPrimitiveSceneShaderData::PrimitiveDataStrideInFloat4s);</span><br><span class="line">    <span class="keyword">for</span> (int32 PrimitiveOffset = <span class="number">0</span>; PrimitiveOffset &lt; NumPrimitiveDataUploads; PrimitiveOffset += MaxPrimitivesUploads)</span><br><span class="line">    &#123;</span><br><span class="line">       Scene.GPUScene.PrimitiveUploadBuffer.<span class="built_in">Init</span>(MaxPrimitivesUploads, <span class="built_in">sizeof</span>(FPrimitiveSceneShaderData::Data), <span class="literal">true</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;PrimitiveUploadBuffer&quot;</span>));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (int32 IndexUpdate = <span class="number">0</span>; (IndexUpdate &lt; MaxPrimitivesUploads) &amp;&amp; ((IndexUpdate + PrimitiveOffset) &lt; NumPrimitiveDataUploads); ++IndexUpdate)</span><br><span class="line">       &#123;</span><br><span class="line">          int32 Index = Scene.GPUScene.PrimitivesToUpdate[IndexUpdate + PrimitiveOffset];</span><br><span class="line">          <span class="comment">// PrimitivesToUpdate may contain a stale out of bounds index, as we don&#x27;t remove update request on primitive removal from scene.</span></span><br><span class="line">          <span class="keyword">if</span> (Index &lt; Scene.PrimitiveSceneProxies.<span class="built_in">Num</span>())</span><br><span class="line">          &#123;</span><br><span class="line">             FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy = Scene.PrimitiveSceneProxies[Index];</span><br><span class="line">             NumLightmapDataUploads += PrimitiveSceneProxy-&gt;<span class="built_in">GetPrimitiveSceneInfo</span>()-&gt;<span class="built_in">GetNumLightmapDataEntries</span>();</span><br><span class="line"><span class="comment">//获取每个proxy的primitive数据</span></span><br><span class="line">             <span class="function">FPrimitiveSceneShaderData <span class="title">PrimitiveSceneData</span><span class="params">(PrimitiveSceneProxy)</span></span>;</span><br><span class="line">             Scene.GPUScene.PrimitiveUploadBuffer.<span class="built_in">Add</span>(Index, &amp;PrimitiveSceneData.Data[<span class="number">0</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">          Scene.GPUScene.PrimitivesMarkedToUpdate[Index] = <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (bResizedPrimitiveData)</span><br><span class="line">       &#123;</span><br><span class="line">          RHICmdList.<span class="built_in">Transition</span>(<span class="built_in">FRHITransitionInfo</span>(MirrorResourceGPU-&gt;UAV, ERHIAccess::Unknown, ERHIAccess::ERWBarrier));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">          RHICmdList.<span class="built_in">Transition</span>(<span class="built_in">FRHITransitionInfo</span>(MirrorResourceGPU-&gt;UAV, ERHIAccess::Unknown, ERHIAccess::UAVCompute));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">          Scene.GPUScene.PrimitiveUploadBuffer.<span class="built_in">ResourceUploadTo</span>(RHICmdList, *MirrorResourceGPU, <span class="literal">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RHICmdList.<span class="built_in">Transition</span>(<span class="built_in">FRHITransitionInfo</span>(MirrorResourceGPU-&gt;UAV, ERHIAccess::Unknown, ERHIAccess::SRVMask));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    (这里先看primitivedata数据部分，lightmap数据部分也是类似)</p><p>数据流向为PrimitiveSceneProxy-&gt;FPrimitiveSceneShaderData-&gt;GPUScene的成员PrimitiveUploadBuffer，调用ResourceUploadTo，而ResourceUploadTo会通过指定的ComputeShader 把GPUScene.PrimitiveUploadBuffer中的ScatterBuffer和UploadBuffer 里的数据存储到了GPUScene.PrimitiveBuffer。</p><p>UploadDynamicPrimitiveShaderDataForView则是把GpuScene中的数据buffer再次copy给View对应的Buffer：PrimitiveShaderDataBuffer/PrimitiveShaderDataTexture，之前存在了gpuscene中的buffer，为什么还需要copy给view对应的buffer转移一次，我猜是因为UE是根据view来分组渲染的，这样传数据更直观，便于区分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部分UploadDynamicPrimitiveShaderDataForView代码</span></span><br><span class="line"><span class="comment">//resize view buffer大小</span></span><br><span class="line"><span class="keyword">if</span> (ViewPrimitiveSceneNumFloat4s * BytesPerElement != ViewPrimitiveShaderDataResource.NumBytes)</span><br><span class="line">&#123;</span><br><span class="line">    ViewPrimitiveShaderDataResource.<span class="built_in">Release</span>();</span><br><span class="line">    <span class="built_in">ResizeResourceIfNeeded</span>(RHICmdList, ViewPrimitiveShaderDataResource, ViewPrimitiveSceneNumFloat4s * BytesPerElement, <span class="built_in">TEXT</span>(<span class="string">&quot;ViewPrimitiveShaderDataBuffer&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Copy scene primitive data into view primitive data</span></span><br><span class="line">&#123;</span><br><span class="line">    RHICmdList.<span class="built_in">Transition</span>(<span class="built_in">FRHITransitionInfo</span>(ViewPrimitiveShaderDataResource.UAV, ERHIAccess::Unknown, ERHIAccess::UAVCompute));</span><br><span class="line">    <span class="built_in">MemcpyResource</span>(RHICmdList, ViewPrimitiveShaderDataResource, *<span class="built_in">GetMirrorGPU</span>&lt;ResourceType&gt;(Scene), Scene.Primitives.<span class="built_in">Num</span>() * <span class="built_in">sizeof</span>(FPrimitiveSceneShaderData::Data), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    RHICmdList.<span class="built_in">Transition</span>(<span class="built_in">FRHITransitionInfo</span>(ViewPrimitiveShaderDataResource.UAV, ERHIAccess::UAVCompute, ERHIAccess::ERWBarrier));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Append View.DynamicPrimitiveShaderData to the end of the view primitive data resource</span></span><br><span class="line"><span class="keyword">if</span> (NumPrimitiveDataUploads &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int32 MaxPrimitivesUploads = <span class="built_in">GetMaxPrimitivesUpdate</span>(NumPrimitiveDataUploads, FPrimitiveSceneShaderData::PrimitiveDataStrideInFloat4s);</span><br><span class="line">    <span class="keyword">for</span> (int32 PrimitiveOffset = <span class="number">0</span>; PrimitiveOffset &lt; NumPrimitiveDataUploads; PrimitiveOffset += MaxPrimitivesUploads)</span><br><span class="line">    &#123;</span><br><span class="line">       Scene.GPUScene.PrimitiveUploadViewBuffer.<span class="built_in">Init</span>( MaxPrimitivesUploads, <span class="built_in">sizeof</span>( FPrimitiveSceneShaderData::Data ), <span class="literal">true</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;PrimitiveUploadViewBuffer&quot;</span>) );</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (int32 IndexUpdate = <span class="number">0</span>; (IndexUpdate &lt; MaxPrimitivesUploads) &amp;&amp; ((IndexUpdate + PrimitiveOffset) &lt; NumPrimitiveDataUploads); ++IndexUpdate)</span><br><span class="line">       &#123;</span><br><span class="line">          int32 DynamicUploadIndex = IndexUpdate + PrimitiveOffset;</span><br><span class="line">          <span class="function">FPrimitiveSceneShaderData <span class="title">PrimitiveSceneData</span><span class="params">(View.DynamicPrimitiveShaderData[DynamicUploadIndex])</span></span>;</span><br><span class="line">          <span class="comment">// Place dynamic primitive shader data just after scene primitive data</span></span><br><span class="line">          Scene.GPUScene.PrimitiveUploadViewBuffer.<span class="built_in">Add</span>(Scene.Primitives.<span class="built_in">Num</span>() + DynamicUploadIndex, &amp;PrimitiveSceneData.Data[<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">          RHICmdList.<span class="built_in">Transition</span>(<span class="built_in">FRHITransitionInfo</span>(ViewPrimitiveShaderDataResource.UAV, ERHIAccess::ERWBarrier, ERHIAccess::ERWBarrier));</span><br><span class="line">          Scene.GPUScene.PrimitiveUploadViewBuffer.<span class="built_in">ResourceUploadTo</span>(RHICmdList, ViewPrimitiveShaderDataResource, <span class="literal">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RumtimeVirtualTexture</title>
      <link href="/2024/05/25/VirtualTexture/"/>
      <url>/2024/05/25/VirtualTexture/</url>
      
        <content type="html"><![CDATA[<h1 id="VirtualTexture工作流程"><a href="#VirtualTexture工作流程" class="headerlink" title="VirtualTexture工作流程"></a>VirtualTexture工作流程</h1><p>VirtualTexture是利用时间换空间的技术，核心原理就是通过把Texture划分成相同大小的Page，在渲染时动态加载/卸载对应的Page，而不是对整个贴图进行操作，整个过程需要三个数据结构，VirtualTexture，PageTable，PhysicalTexture。</p><span id="more"></span><p><img src="/2024/05/25/VirtualTexture/virtualtexture.png" alt="virtualtexture"></p><h2 id="数据结构整理"><a href="#数据结构整理" class="headerlink" title="数据结构整理"></a>数据结构整理</h2><h3 id="FVirtualTextureSpace"><a href="#FVirtualTextureSpace" class="headerlink" title="FVirtualTextureSpace"></a>FVirtualTextureSpace</h3><p>​    一个VirtualTexture的空间，可能包含多个AllocatedVT，空间里的多个VT共享一个坐标系，包含一个Allocator成员用来分配VT，采用先大后小的分配原则，即对于小页面，不断产生child页面来匹配直到匹配到合适的。线分配1024×1024的page，接着分配512，最后分配256的直到大小匹配。</p><p><img src="/2024/05/25/VirtualTexture/allocator.png" alt="image-20240604173802513"></p><h3 id="FVirtualTextureProducer"><a href="#FVirtualTextureProducer" class="headerlink" title="FVirtualTextureProducer"></a>FVirtualTextureProducer</h3><p>与RVT Volume一一对应，用来生产VT的page数据，里面包含有IVirtualTexture成员，该成员的RequestPageData和ProducePageData接口用来真正创建后续绘制VT需要的数据。</p><h3 id="FAllocatedVirtualTexture"><a href="#FAllocatedVirtualTexture" class="headerlink" title="FAllocatedVirtualTexture"></a>FAllocatedVirtualTexture</h3><p>被分配的VT数据，与RVT Volume一一对应，可以注意到每个地形都可以指定一个渲染的RVT，而RVTVolume里也有一个RVT，如果一个地形被包含在RVTVolume中，但是指定的VT与Volume的不同，那么也不会被渲染。AllocatedVT可以理解成一个数据中心，包含了RVT Volume中的VT中的数据，包括每个layer对应的producer，以及Producer中对应的PhysicalGroup。</p><p>如果一个RVT在创建时指定了bSinglePhysicalSpace为true，那么所有的layer都会指向一个physicalgroup，否则的话按照layer来区分group，代码参考GetProducerDescription。</p><h3 id="FVirtualTexturePhysicalSpace"><a href="#FVirtualTexturePhysicalSpace" class="headerlink" title="FVirtualTexturePhysicalSpace"></a>FVirtualTexturePhysicalSpace</h3><p>VT的物理地址空间，是AllocatedVT中的UniquePageTableLayers数据中的成员，如上面所说，如果bSinglePhysicalSpace为true，那么AllocatedVT中所有layer都指向一个group，也就是同一个物理空间。</p><p>PhysicalSpace下面还管理了一个FTexturePagePool，用来真正保存PhysicalPage，以及对应的操作。</p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>VirtualTexture的数据一切都是从场景中放置的Volume，Volume包含VirtualTextureComponent，会向VirtualTextureSystem注册Producer数据，以及申请对应的FAllocatedVirtualTexture。看代码的时候很容易被各种Index和起名相近的数据结构搞混淆。一个Volume对应一个Producer，对应一个FAllocatedVirtualTexture，FAllocatedVirtualTexture是通过VirtualTextureSystem的Allocator分配的，同一个Space下可以分配多个FAllocatedVirtualTexture。</p><h3 id="1-Render产生FeedBack数据"><a href="#1-Render产生FeedBack数据" class="headerlink" title="1. Render产生FeedBack数据"></a>1. Render产生FeedBack数据</h3><p>这一部分的入口在basepasspixelshader最后的FinalizeVirtualTextureFeedback函数。里面实现很简单，就是把对应像素位置填充上需要加载的VT数据，为了控制带宽，这里不是每个像素都会产生加载请求，而是由VIRTUAL_TEXTURE_FEEDBACK_FACTOR决定更新颗粒度，颗粒度越小更新越细，当然性能也越差，颗粒度大会有部分像素没法更新VT的情况。里面填充的加载申请是在TextureLoadVirtualPageTable被填充。</p><h3 id="2-CPU处理FeedBack数据"><a href="#2-CPU处理FeedBack数据" class="headerlink" title="2. CPU处理FeedBack数据"></a>2. CPU处理FeedBack数据</h3><p>GPU端每帧渲染完画面会产生VT的加载请求，CPU端会在FVirtualTextureSystem::Update中做一系列处理。</p><h4 id="2-1-请求数据筛选整理"><a href="#2-1-请求数据筛选整理" class="headerlink" title="2.1 请求数据筛选整理"></a>2.1 请求数据筛选整理</h4><h5 id="2-1-1-合并同类请求"><a href="#2-1-1-合并同类请求" class="headerlink" title="2.1.1 合并同类请求"></a>2.1.1 合并同类请求</h5><p>多个像素可能申请同一个VT Page，我们需要合并这类请求，这一步通过FFeedbackAnalysisTask多线程处理。</p><h5 id="2-1-2-筛选请求数据"><a href="#2-1-2-筛选请求数据" class="headerlink" title="2.1.2 筛选请求数据"></a>2.1.2 筛选请求数据</h5><p>​    这一步UE同样用了多线程GatherRequestsTask来处理，每个线程处理若干Page的请求。</p><ol><li>对每个PageRequest<ol><li>通过PageMap查找物理Page，<ol><li>如果存在更新，更新PagePool的FreeHeap</li><li>如果不存在记录当前Page的Layer到ToLoad</li></ol></li><li>记录步骤1需要加载的LayerPage的Producer和对应的Group。</li><li>对步骤二的Producer和Group进行循环<ol><li>Producer循环</li><li>对Group循环<ol><li>找到最大分辨率对应的Physicalpage，更新存在physicalpage的LRU</li><li>对所有指向当前group的layer进行Mapping更新</li><li>如果当前group的physicalPage的分辨率远低于申请的，先做预取</li><li>对预取的group申请加载（步骤1.3.2.3得到了对应预取的group，但是我们需要对所有没有对应分辨率的group一起预取，保证所有group数据同步），更新VirtualAdress和PhysicalAdress的mapping</li><li>对于步骤2记录的group申请加载，更新Mapping。</li></ol></li></ol></li></ol></li></ol><h5 id="2-1-3-提交请求"><a href="#2-1-3-提交请求" class="headerlink" title="2.1.3 提交请求"></a>2.1.3 提交请求</h5><ol><li>加载请求：<ol><li>找到请求的producer，对每一个group处理（之前的申请加载参数包含了groupIndex），找到group对应的physicalSpace，申请物理地址，更新ProduceTarget数组</li><li>对于没申请 的group，也填充ProduceTarget数据</li><li>调用ProducePageData生成后面的绘制数据。</li></ol></li><li>Mapping请求</li></ol><p>​    注意这里填充ProduceTarget会赋值两个关键数据：Physical渲染到那个Texture，以及PhysicalPage在Texture的位置，不同的Group拥有不同的PhysicalSpace，所以对应的Texture是不一样的。</p><h4 id="2-2-绘制PhysicalTexture"><a href="#2-2-绘制PhysicalTexture" class="headerlink" title="2.2 绘制PhysicalTexture"></a>2.2 绘制PhysicalTexture</h4><p><img src="/2024/05/25/VirtualTexture/DrawMesh.png" alt="image-20240528211507163"></p><p>这一步的入口还是在SubmitRequests中，对上一步生成的IVirtualTextureFinalizer::Finalize进行绘制，最终生成共用同一个TextureRHI的Page批次信息，调用RenderPages进行同批次绘制，RenderPage则是对单个Page进行绘制，步骤如下：</p><ol><li>设置单个Page需要的View信息，Camera位置。</li><li>调用DrawMeshs绘制当前场景中RuntimeVirtualTextureMask符合的物体。</li><li>调用CompressPass来压缩第二步的RT</li><li>将压缩后的RT合并成更少的RT，以底色、法线、粗糙度、高光度为例，读取3张Texture，Packed并写入到2个RT中。</li><li>将合并后的RT放到PhysicalTexture的对应物理位置上去</li></ol><p>设置View信息时，会根据当前page的UV中心来设置相机位置，确保只渲染当前page</p><p>DrawMeshs时用来筛选物体的RuntimeVirtualTextureMask是在UpdateRuntimeVirtualTextureFlags中更新的，与FRuntimeVirtualTextureSceneProxy一一对应，考虑到一共只有7位预留，也就是说场景中最多存在7个RVTVolume（看代码注释有说会扩展，当超出7位后，会舍弃Mask方法去遍历图元的virtualtexture）</p><p>第五步Copy到PhysicalTexture时，Page在Physical中的位置信息是在2.1.3提交请求中填充ProduceTarget.pPageLocation赋值的，pPageLocation代表的是当前page在physicaltexture中的位置，比如当前physicaltexture中包含8×8个page，pPageLocation为（1，1）</p><h4 id="2-3-更新PageTable"><a href="#2-3-更新PageTable" class="headerlink" title="2.3 更新PageTable"></a>2.3 更新PageTable</h4><p>这一步的入口在FVirtualTextureSpace::ApplyUpdates中，把上面申请加载的physicaltexture更新到对应的PageTable中，数据来源是FVirtualTextureSystem::SubmitRequests中的MappingRequest。这一步主要做了两件事</p><ol><li>更新pagetable上的四叉树子节点</li><li>把pagetableCPU端的buffer渲染到GPU端的RT</li></ol><p>更新部分：PageMap是Mip组成的，MipMap本身可以用四叉树结构来表示，这里用了莫顿码来帮助搜索四叉树，可以快速找到当前Mip的子tile。</p><p>渲染部分：入口是在TPageTableUpdateVS，这里用的Instance多实例渲染，每个实例绘制8个quad，在VS中根据InstanceID和VextexID来取得cpu端对应传入的buffer数据，写到Color里。</p><h3 id="3-GPU端采样VirtualTexture"><a href="#3-GPU端采样VirtualTexture" class="headerlink" title="3. GPU端采样VirtualTexture"></a>3. GPU端采样VirtualTexture</h3><p>通过前面几步，我们得到了：混合了各个Mip的PhysicalTexture合集，以及映射vaddress和paddress的pagetable，接下来看如何使用这两个数据：</p><p>采样的代码通常在materialtemplete中被填充，主要有两个shader函数TextureLoadVirtualPageTable，TextureVirtualSample。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VTPageTableResult Local1 = TextureLoadVirtualPageTable( Material_VirtualTexturePageTable0_0 , VTPageTableUniform_Unpack(Material_VTPackedPageTableUniform[0*2], Material_VTPackedPageTableUniform[0*2+1]), VirtualTextureWorldToUV(GetWorldPosition(Parameters), Material_VectorExpressions[3].rgb, Material_VectorExpressions[2].rgb, Material_VectorExpressions[1].rgb),  0u ,  0u , View_MaterialTextureMipBias, Parameters.SvPosition.xy, 0U +  0 , Parameters.VirtualTextureFeedback);</span><br><span class="line">float4  Local2 = TextureVirtualSample(Material_VirtualTexturePhysical_0, GetMaterialSharedSampler(Material_VirtualTexturePhysical_0Sampler, View_SharedBilinearAnisoClampedSampler), Local1, 0, VTUniform_Unpack(Material_VTPackedUniform[0]));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TextureLoadVirtualPageTable负责生成VTPageTableResult结构，TextureVirtualSample负责用VTPageTableResult真正执行Physical采样。</p><h4 id="3-1-TextureLoadVirtualPageTable"><a href="#3-1-TextureLoadVirtualPageTable" class="headerlink" title="3.1 TextureLoadVirtualPageTable"></a>3.1 TextureLoadVirtualPageTable</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">VTPageTableResult TextureLoadVirtualPageTable(Texture2D&lt;uint4&gt; PageTable0, Texture2D&lt;uint4&gt; PageTable1,</span><br><span class="line">    float2 UV, float MipBias,</span><br><span class="line">    float2 SvPositionXY,</span><br><span class="line">    VTPageTableUniform PageTableUniform,</span><br><span class="line">    uint AddressU, uint AddressV)</span><br><span class="line">&#123;</span><br><span class="line">    VTPageTableResult Result = (VTPageTableResult)0.0f;</span><br><span class="line">    const float2 ScaledUV = UV * PageTableUniform.UVScale;</span><br><span class="line">    uint vLevel = 0u;</span><br><span class="line">#if PIXELSHADER</span><br><span class="line">    vLevel = TextureComputeVirtualMipLevel(Result, ddx(ScaledUV), ddy(ScaledUV), MipBias, SvPositionXY, PageTableUniform);</span><br><span class="line">#endif // PIXELSHADER</span><br><span class="line">    TextureLoadVirtualPageTableInternal(Result, PageTable0, PageTable1, ScaledUV, vLevel, PageTableUniform, AddressU, AddressV);</span><br><span class="line">    return Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这一步通过RVT的UV坐标，计算得到对应pagetable的坐标。RVT的UV坐标指的是当前像素在runtimevirtualtexturevolume内的坐标</p><p><img src="/2024/05/25/VirtualTexture/RVTUV.png" alt="image-20240603163649497"></p><p>以上图为例，黄色线框为场景 中的RVTVolume，里面包含两个带有RVT的地形块，RVT的坐标就是根据世界坐标换算到以RVTVolume的原点，XY轴为坐标轴的坐标系。代码参考如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float2 VirtualTextureWorldToUV(in float3 WorldPos, in float3 Origin, in float3 U, in float3 V)</span><br><span class="line">&#123;</span><br><span class="line">    float3 P = WorldPos - Origin;</span><br><span class="line">    return saturate(float2(dot(P, U), dot(P, V)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着通过TextureComputeVirtualMipLevel得到需要采样的MipLevel，这里额外加了一个噪声扰动以及通过UV的导数来计算MipLevel，通常dUVdx越大，对应的Mip越小（越模糊）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int TextureComputeVirtualMipLevel(</span><br><span class="line">    in out VTPageTableResult OutResult,</span><br><span class="line">    float2 dUVdx, float2 dUVdy, float MipBias,</span><br><span class="line">    float2 SvPositionXY,</span><br><span class="line">    VTPageTableUniform PageTableUniform)</span><br><span class="line">&#123;</span><br><span class="line">    OutResult.dUVdx = dUVdx * PageTableUniform.SizeInPages;</span><br><span class="line">    OutResult.dUVdy = dUVdy * PageTableUniform.SizeInPages;</span><br><span class="line"></span><br><span class="line">    const float Noise = InterleavedGradientNoise(SvPositionXY, View.StateFrameIndexMod8);</span><br><span class="line">    const float ComputedLevel = MipLevelAniso2D(OutResult.dUVdx, OutResult.dUVdy, PageTableUniform.MaxAnisoLog2) + MipBias + Noise * 0.5f - 0.25f;</span><br><span class="line"></span><br><span class="line">    return (int)floor(ComputedLevel) + int(PageTableUniform.vPageTableMipBias);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到了PageTable需要求值的Level，接下来通过TextureLoadVirtualPageTableInternal取得对应值，这一步有两个作用，一是填充PageTableValue方便后面采样，二是生成Feedbackrequest，给CPU加载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void TextureLoadVirtualPageTableInternal(</span><br><span class="line">    in out VTPageTableResult OutResult,</span><br><span class="line">    Texture2D&lt;uint4&gt; PageTable0,</span><br><span class="line">    VTPageTableUniform PageTableUniform,</span><br><span class="line">    float2 UV, int vLevel)</span><br><span class="line">&#123;</span><br><span class="line">    //这里的sizeinpage 推测应该是page的个数，而不是page的大小</span><br><span class="line">    //输入UV 是0.6 Page个数是8</span><br><span class="line">    //Outresult.uv 就是4.8 表示在第四个page中 page内坐标是0.8</span><br><span class="line">    OutResult.UV = UV * PageTableUniform.SizeInPages;</span><br><span class="line"></span><br><span class="line">    const uint vLevelClamped = clamp(vLevel, 0, int(PageTableUniform.MaxLevel));</span><br><span class="line">    const uint vPageX = (uint(OutResult.UV.x) + PageTableUniform.XOffsetInPages) &gt;&gt; vLevelClamped;</span><br><span class="line">    const uint vPageY = (uint(OutResult.UV.y) + PageTableUniform.YOffsetInPages) &gt;&gt; vLevelClamped;</span><br><span class="line">    //根据UV 坐标拿到pagetable的 值</span><br><span class="line">    OutResult.PageTableValue[0] = PageTable0.Load(int3(vPageX, vPageY, vLevelClamped));</span><br><span class="line">    OutResult.PageTableValue[1] = uint4(0u, 0u, 0u, 0u);</span><br><span class="line"></span><br><span class="line">    // PageTableID packed in upper 4 bits of &#x27;PackedPageTableUniform&#x27;, which is the bit position we want it in for PackedRequest as well, just need to mask off extra bits</span><br><span class="line">    OutResult.PackedRequest = PageTableUniform.ShiftedPageTableID;</span><br><span class="line">    OutResult.PackedRequest |= vPageX;</span><br><span class="line">    OutResult.PackedRequest |= vPageY &lt;&lt; 12;</span><br><span class="line"></span><br><span class="line">    // Feedback always encodes vLevel+1, and subtracts 1 on the CPU side.</span><br><span class="line">    // This allows the CPU code to know when we requested a negative vLevel which indicates that we don&#x27;t have sufficient virtual texture resolution.</span><br><span class="line">    const uint vLevelPlusOneClamped = clamp(vLevel + 1, 0, int(PageTableUniform.MaxLevel + 1));</span><br><span class="line">    OutResult.PackedRequest |= vLevelPlusOneClamped &lt;&lt; 24;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-TextureVirtualSample"><a href="#3-2-TextureVirtualSample" class="headerlink" title="3.2 TextureVirtualSample"></a>3.2 TextureVirtualSample</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MaterialFloat4 TextureVirtualSample(</span><br><span class="line">    Texture2D Physical, SamplerState PhysicalSampler,</span><br><span class="line">    VTPageTableResult PageTableResult, uint LayerIndex,</span><br><span class="line">    VTUniform Uniform)</span><br><span class="line">&#123;</span><br><span class="line">    const float2 pUV = VTComputePhysicalUVs(PageTableResult, LayerIndex, Uniform);</span><br><span class="line">    return Physical.SampleGrad(PhysicalSampler, pUV, PageTableResult.dUVdx, PageTableResult.dUVdy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步根据上面得到的page坐标，以及UV坐标取得PhysicalTexture的真正坐标然后采样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">float2 VTComputePhysicalUVs(in out VTPageTableResult PageTableResult, uint LayerIndex, VTUniform Uniform)</span><br><span class="line">&#123;</span><br><span class="line">    const uint PackedPageTableValue = PageTableResult.PageTableValue[LayerIndex / 4u][LayerIndex &amp; 3u];</span><br><span class="line"></span><br><span class="line">    // See packing in PageTableUpdate.usf</span><br><span class="line">    const uint vLevel = PackedPageTableValue &amp; 0xf;</span><br><span class="line">    const float UVScale = 1.0f / (float)(1 &lt;&lt; vLevel);</span><br><span class="line">    const float pPageX = (float)((PackedPageTableValue &gt;&gt; 4) &amp; ((1 &lt;&lt; Uniform.PageCoordinateBitCount) - 1));</span><br><span class="line">    const float pPageY = (float)(PackedPageTableValue &gt;&gt; (4 + Uniform.PageCoordinateBitCount));</span><br><span class="line">    //这里取小数部分得到page内的UV坐标</span><br><span class="line">    const float2 vPageFrac = frac(PageTableResult.UV * UVScale);</span><br><span class="line">    //这里得到在整个physical texture 上的坐标</span><br><span class="line">    const float2 pUV = float2(pPageX, pPageY) * Uniform.pPageSize + (vPageFrac * Uniform.vPageSize + Uniform.vPageBorderSize);</span><br><span class="line"></span><br><span class="line">    const float ddxyScale = UVScale * Uniform.vPageSize;</span><br><span class="line">    //表示当前miplevel 下 UV坐标+1 对应实际贴图移动的像素数</span><br><span class="line">    PageTableResult.dUVdx *= ddxyScale;</span><br><span class="line">    PageTableResult.dUVdy *= ddxyScale;</span><br><span class="line">    return pUV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>球谐光照</title>
      <link href="/2024/04/18/%E7%90%83%E8%B0%90%E5%85%89%E7%85%A7/"/>
      <url>/2024/04/18/%E7%90%83%E8%B0%90%E5%85%89%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><p>前置逻辑：</p><h3 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h3><p>对于任意的周期函数，都可以用一系列的正弦函数展开：</p><script type="math/tex; mode=display">f(t)=A_0+\sum_{n=1}^{\infty}A_n\sin(n\omega t + \phi_n)\tag{1.1}</script><p>也可表示为：</p><script type="math/tex; mode=display">f(t) =\frac{a_0}{2}+\sum_{n=1}^{\infty}[a_n\cos(n\omega t) + b_n\sin(n\omega t)]\tag{1.2}</script><p>这样的展开即傅里叶级数，我们最终的目标就是求出每个函数的系数$a_n$与$b_n$。</p><span id="more"></span><h3 id="傅里叶变换："><a href="#傅里叶变换：" class="headerlink" title="傅里叶变换："></a>傅里叶变换：</h3><p>对于部分在时域不容易处理的问题，我们会选择将函数转换到频域进行处理，比如我们需要去除掉语音的低频部分，这在时域函数中非常难以实现，但在频域表示下只是一个突起点，傅里叶级数只能针对周期函数有效，如果是非周期函数，我们就需要傅里叶变换帮我们把函数从时域变换到频域。</p><script type="math/tex; mode=display">\begin{cases}F(\omega)=\frac{1}{2\pi}\displaystyle\int^{\infty}_{-\infty}f(t)e^{-i\omega t}dt\\f(t)=\displaystyle\int^{\infty}_{-\infty}F(\omega)e^{i\omega t}dt\end{cases}</script><p>离散傅里叶变换是从系数求点值对。</p><p>离线傅里叶逆变换是从点值对求系数。</p><p>我们也可以用下面的一张图来理解傅里叶展开，$e^{i\omega t}$是一个连续旋转的圆，我们可以用无数个连续旋转的圆，大圆套小圆，来拟合满足狄利赫里条件。</p><p><img src="/2024/04/18/%E7%90%83%E8%B0%90%E5%85%89%E7%85%A7/eiwt.gif" alt="eiwt"></p><p>​                                                    $e^{i\omega t}$ 的表示</p><p><img src="/2024/04/18/%E7%90%83%E8%B0%90%E5%85%89%E7%85%A7/傅里叶.gif" alt="傅里叶"></p><h3 id="拉普拉斯方程："><a href="#拉普拉斯方程：" class="headerlink" title="拉普拉斯方程："></a>拉普拉斯方程：</h3><p>拉普拉斯方程是关于多元函数的二阶偏微分方程，对于一个三元函数$u=f(x,y,z)$</p><script type="math/tex; mode=display">\Delta u=\nabla\cdot\nabla u=\frac{\partial^2u}{\partial x^2} + \frac{\partial^2u}{\partial y^2}+ \frac{\partial^2u}{\partial z^2} =0\tag{2.1}</script><p>它的解分为两部分：方位角项和极角项，恰好就是我们最终需要的球谐函数表达式。其中极角项又被称为伴随勒让德多项式。</p><p>多项式乘法可以由离线变换先转换为点值对做乘法，然后逆变换回系数表达式，这样时间复杂度会变小。</p><p>通俗来说，球谐光照是对漫反射光照的一种近似手段，和IBL类似，但是好处如下：</p><pre><code> 1. 只存储球谐系数，需要的存储空间非常小 2. 利用球谐函数的性质：正交性 &amp; 旋转不变性，可以消除/大大减少漫反射过程中对半球面的积分计算，从而实现实时光照计算。</code></pre><h1 id="1-球谐函数"><a href="#1-球谐函数" class="headerlink" title="1. 球谐函数"></a>1. 球谐函数</h1><h2 id="1-1-函数定义"><a href="#1-1-函数定义" class="headerlink" title="1.1 函数定义"></a>1.1 函数定义</h2><p>球谐函数是由一组正交基函数组成，类似于傅里叶展开，这一组基函数可以用来拟合各种函数，定义如下：</p><script type="math/tex; mode=display">y_l^m=\begin{cases}    \sqrt{2}Re(Y_l^m) \quad m>0\\    \sqrt{2}Im(Y_l^m) \quad m<0\\    Y_l^0 \quad m=0\\    \end{cases}    =\begin{cases}    \sqrt{2}K_l^mcos m\varphi P_l^m(cos\theta) \quad m>0\\    \sqrt{2}K_l^msin |m|\varphi P_l^{|m|}(cos\theta) \quad m<0\\    K_l^0P_l^0cos(\theta)\\    \end{cases}\tag1</script><script type="math/tex; mode=display">P_l^m(x)=\frac{(-1)^m(1-x^2)^{\frac{m}{2}}}{2^ll!}\frac{d^{l+m}}{dx^{l+m}}[(x^2-1)^l]\tag2</script><p>其中y的下标<em>l</em>代表球谐函数的阶数，每一阶由2<em>n</em>+1(-m ~ m)个函数组成，其中$K_l^m$被称为归一化常数，$P_l^m$被称为<strong>伴随勒让德多项式</strong>，该方程是拉普拉斯方程的解，在求解时我们一般不直接对方程求解，而是利用它的递推公式，逐级求解，递推公式如下：</p><script type="math/tex; mode=display">\begin{cases}P_m^m(x)=(-1)^m(2m-1)!!(1-x^2)^{\frac{m}{2}}\\p_{m+1}^m=x(2m+1)p_m^m(x)\\(l-m)P_l^m(x)=x(2l-1)p_{l-1}^m-(l+m-1)p_{l-2}^m(x)\end{cases}\tag5</script><h2 id="1-2-函数图形化表示"><a href="#1-2-函数图形化表示" class="headerlink" title="1.2 函数图形化表示"></a>1.2 函数图形化表示</h2><p><img src="/2024/04/18/%E7%90%83%E8%B0%90%E5%85%89%E7%85%A7/球谐1.jpg" alt></p><center>    球谐函数的通用表示之一，红色代表正，蓝色代表负</center><p><img src="/2024/04/18/%E7%90%83%E8%B0%90%E5%85%89%E7%85%A7/球谐2.jpg" alt="球谐2"></p><center>    球谐函数的通用表达之二：用cubemap展开来表达函数，红色代表正，蓝色代表负，绿色代表0，其中函数值被编码进不同的channel</center><h2 id="1-3-球谐函数性质"><a href="#1-3-球谐函数性质" class="headerlink" title="1.3 球谐函数性质"></a>1.3 球谐函数性质</h2><h3 id="1-3-1-正交性"><a href="#1-3-1-正交性" class="headerlink" title="1.3.1 正交性"></a>1.3.1 正交性</h3><p>假设$y_i$，$y_j$为两个球谐函数，其中$i\in{k}$，，$k$为$2l+m$，那么:</p><script type="math/tex; mode=display">\int_S{y_iy_jd(\theta,\varphi)}=0, when\quad{i\neq j}\tag6</script><p>伴随勒让德多项式是具备正交完备性的，为了让球谐函数也具备正交完备性，所以添加了归一化参数，也就是$K_l^m$</p><script type="math/tex; mode=display">Y_l^m(\theta,\varphi)=K_l^me^{im\varphi}P_l^{|m|}(cos\theta),l\in{N},-l \leq m \leq l \tag2</script><script type="math/tex; mode=display">K_l^m=\sqrt{\frac{(2l+1)(l-|m|)!}{4\pi(l+|m|)!}}\tag3</script><h3 id="1-3-2-旋转不变性"><a href="#1-3-2-旋转不变性" class="headerlink" title="1.3.2 旋转不变性"></a>1.3.2 旋转不变性</h3><p>通过上面的介绍，我们知道一个指定的函数$f(\theta,\varphi)$可以被一组球谐函数$y(\theta,\varphi)$所表示，当$(\theta,\varphi)$所表示的点旋转一定角度后得到的新的函数$f(R(\theta,\varphi))$,$R$代表旋转函数，我们要求对应新函数的球谐函数，不需要进行重新计算，可以直接通过原函数的球谐函数经过线性变化得到。</p><h3 id="1-3-3求解"><a href="#1-3-3求解" class="headerlink" title="1.3.3求解"></a>1.3.3求解</h3><p>为了能够应用，我们需要把球谐函数用实数来表示，也就是公式$(1)$的部分，利用极坐标和正交坐标的转换表达，我们可以得到$r=1$时候的球谐函数前三阶的表达式：</p><p><img src="/2024/04/18/%E7%90%83%E8%B0%90%E5%85%89%E7%85%A7/sh_3.png" alt="sh_3"></p><p>和UE中提供的球谐函数一致：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SHCommon.ush</span></span><br><span class="line"><span class="function">FTwoBandSHVector <span class="title">SHBasisFunction</span><span class="params">(half3 InputVector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FTwoBandSHVector Result;</span><br><span class="line">    <span class="comment">// These are derived from simplifying SHBasisFunction in C++</span></span><br><span class="line">    Result.V.x = <span class="number">0.282095f</span>; </span><br><span class="line">    Result.V.y = <span class="number">-0.488603f</span> * InputVector.y;</span><br><span class="line">    Result.V.z = <span class="number">0.488603f</span> * InputVector.z;</span><br><span class="line">    Result.V.w = <span class="number">-0.488603f</span> * InputVector.x;</span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FThreeBandSHVector <span class="title">SHBasisFunction3</span><span class="params">(half3 InputVector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FThreeBandSHVector Result;</span><br><span class="line">    <span class="comment">// These are derived from simplifying SHBasisFunction in C++</span></span><br><span class="line">    Result.V0.x = <span class="number">0.282095f</span>; </span><br><span class="line">    Result.V0.y = <span class="number">-0.488603f</span> * InputVector.y;</span><br><span class="line">    Result.V0.z = <span class="number">0.488603f</span> * InputVector.z;</span><br><span class="line">    Result.V0.w = <span class="number">-0.488603f</span> * InputVector.x;</span><br><span class="line"></span><br><span class="line">    half3 VectorSquared = InputVector * InputVector;</span><br><span class="line">    Result.V1.x = <span class="number">1.092548f</span> * InputVector.x * InputVector.y;</span><br><span class="line">    Result.V1.y = <span class="number">-1.092548f</span> * InputVector.y * InputVector.z;</span><br><span class="line">    Result.V1.z = <span class="number">0.315392f</span> * (<span class="number">3.0f</span> * VectorSquared.z - <span class="number">1.0f</span>);</span><br><span class="line">    Result.V1.w = <span class="number">-1.092548f</span> * InputVector.x * InputVector.z;</span><br><span class="line">    Result.V2 = <span class="number">0.546274f</span> * (VectorSquared.x - VectorSquared.y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这样一组基底函数，是不是有点像之前的傅里叶三角函数展开，不同的是我们把三角函数换成了球谐函数。</p><h3 id="1-3-3-投影和重建"><a href="#1-3-3-投影和重建" class="headerlink" title="1.3.3 投影和重建"></a>1.3.3 投影和重建</h3><p>知道了可以将函数展开成球谐函数的表达式，我们就需要求得每阶球谐函数对应的系数，这个过程叫投影，反之利用球谐系数来构造原函数的过程叫重建。</p><script type="math/tex; mode=display">c_k=\int_{S}f(\theta, \phi) \cdot b_k(\theta,\phi)d\omega</script><p>球谐系数等于原函数与球谐函数在定义域上的定积分，与傅里叶级数展开时系数的求解一样。</p><h1 id="2-光照方程"><a href="#2-光照方程" class="headerlink" title="2. 光照方程"></a>2. 光照方程</h1><p>​    通用的渲染方程如下，其中$f_r$被称为表面传输系数，也就是我们通常提到的$brdf$，一般的$IBL$照明方案中，为了得到漫反射结果，我们通常会根据环境立方体贴图计算出一个以出射方向采样的辐照度图，图上的每一个像素代表在当前出射方向的半球内入射光积分。每次运算都需要对平面所在的半球$\Omega$进行积分。</p><script type="math/tex; mode=display">L(p,w_o)=\int_{\Omega}{f_r(p,w_i,w_o)L_i(p,w_i)n\cdot w_i}dw_i\tag7</script><p>对于漫反射来说$f_r=\frac{1}{\pi}$,然后我们把光照部分和$brdf$以及与法线与入射光夹角分别用一个球谐函数$L_k,T_k$来表示，则公式（7）可以表示为：</p><script type="math/tex; mode=display">L(p,\omega_o)=\int_{S}L(p,\omega_i)\cdot T(p,\omega_i,\omega_o)d\omega_i \tag8</script><p>对于光源部分，假设球谐系数是$l_k$可以表示为:</p><script type="math/tex; mode=display">L(p,\omega_i)=\sum_{k=0}^{k<n}l_k\cdot b_k(\omega_i) \tag9</script><p>其系数由原函数和球谐函数积分得到：</p><script type="math/tex; mode=display">l_k=\int_{S}L(p,\omega_i)\cdot b_k d\omega_i \tag{10}</script><p>对于传输部分，假设球谐系数是$t_k$可以表示为：</p><script type="math/tex; mode=display">T(p,\omega_i)=\sum_{k=0}^{k<n}t_k\cdot b_k(\omega_i) \tag9</script><p>同理其系数为：</p><script type="math/tex; mode=display">t_k=\int_{S}T(p,\omega_i)\cdot b_k d\omega_i \tag{10}</script><p>带入光照方程可得：<br>对于漫反射来说$f_r=\frac{1}{\pi}$,然后我们把光照部分和$brdf$以及与法线与入射光夹角分别用一个球谐函数$L_k,T_k$来表示，则光源部分可以表示为:</p><script type="math/tex; mode=display">L(p,\omega_i)=\sum^{k<n}_{k=0}l_k\cdot b_k(\omega_i)\tag{8}</script><p>传输部分也是一样：</p><script type="math/tex; mode=display">T(p,\omega_i,\omega_o)=\sum^{k<n}_{k=0}t_k\cdot b_k(\omega_i)</script><p>最终光照方程就可以根据球谐函数的正交完备性，消去积分项，只需要求出对应的球谐系数即可，过程如下：</p><script type="math/tex; mode=display">L(p, \omega_0)  = \int_{S}\sum_{p=0}^{p<n}l_p \cdot b_p(\omega_i)\cdot \sum_{q=0}^{q<n}t_q \cdot b_q(\omega_i) \cdot d\omega_i\\=\sum_{p=0}^{p<n}\sum_{q=0}^{q<n}l_q \cdot t_q \cdot \underbrace {\int_{S}b_p(\omega_i)b_q(\omega_i)d\omega_i}_{=\delta_{pq}}\\=\sum_{p=0}^{p<n}\sum_{q=0}^{q<n}l_q \cdot t_q \cdot \delta_{pq}\\=\sum_{k=0}^{k<n}l_k \cdot t_k</script><p>我们可以像傅里叶级数展开一样，把目标函数按照球谐函数展开，但是需要求得球谐系数，球谐系数可以由目标函数和球谐基函数积分计算得到。</p><p>这样带入原来的光照方程积分式，就可以省去积分表达，只需要计算两个部分的球谐系数就行。</p><p>光源部分的球谐系数由光照和球谐函数积分计算得到</p><p>传输部分的球谐系数可以直接转换成定积分计算出来。</p><p>光照函数拆分成两部分，分别用球谐函数预计算，就不需要积分，直接点乘就能算出来结果，但是需要提前算出来两个部分的球谐系数。</p><h1 id="UE-漫反射实现"><a href="#UE-漫反射实现" class="headerlink" title="UE 漫反射实现"></a>UE 漫反射实现</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE VertexFactory</title>
      <link href="/2023/11/05/VertexFactory/"/>
      <url>/2023/11/05/VertexFactory/</url>
      
        <content type="html"><![CDATA[<h1 id="UE-VertexFactory"><a href="#UE-VertexFactory" class="headerlink" title="UE VertexFactory"></a>UE VertexFactory</h1><p>​    个人理解：UE 的VertexFactory是一个用来做数据兼容的结构体，在FBX数据与UE的StaticMesh之间做兼容，在CPU的StaticMesh与GPU的VertexShader之间做兼容。</p><span id="more"></span><h2 id="1-在FBX与StaticMesh之间兼容"><a href="#1-在FBX与StaticMesh之间兼容" class="headerlink" title="1.在FBX与StaticMesh之间兼容"></a>1.在FBX与StaticMesh之间兼容</h2><p>在StaticMesh的导入流程中，Mesh的网格数据都被存储在了FStaticMeshRenderData结构体中，并且会依次执行两个成员的InitResources。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FStaticMeshRenderData - All data needed to render a static mesh.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FStaticMeshRenderData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Default constructor. */</span></span><br><span class="line"><span class="function">ENGINE_API <span class="title">FStaticMeshRenderData</span><span class="params">()</span></span>;</span><br><span class="line">ENGINE_API ~<span class="built_in">FStaticMeshRenderData</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Per-LOD resources. For compatibility reasons, the FStaticMeshLODResources array are not referenced through TRefCountPtr.</span></span><br><span class="line"><span class="comment"> * The LODResource still has a ref count of at least 1, see FStaticMeshLODResources() constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FStaticMeshLODResourcesArray LODResources;</span><br><span class="line">FStaticMeshVertexFactoriesArray LODVertexFactories;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UStaticMesh::InitResources</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (RenderData)</span><br><span class="line">    &#123;</span><br><span class="line">        UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line">        RenderData-&gt;<span class="built_in">InitResources</span>(World ? World-&gt;FeatureLevel.<span class="built_in">GetValue</span>() :                          ERHIFeatureLevel::Num, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中FStaticMeshLODResources::InitResources 为每一种顶点属性都申请了对应的GPU资源，如(Position)VertexBuffer，(Tangent)VertexBuffer，并且将代理保存在Cpu端的数据结构中。</p><p>FStaticMeshVertexFactories::InitResources则是将上面申请得到的代理，与VertexFactory中对应的数据结构绑定，填充其数据结构，主要用VerterxFactory存放两类数据：顶点buffer和顶点声明。</p><p>主要接口是FLocalVertexFactory::InitRHI()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FLocalVertexFactory::InitRHI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">SCOPED_LOADTIMER</span>(FLocalVertexFactory_InitRHI);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// We create different streams based on feature level</span></span><br><span class="line">   <span class="built_in">check</span>(<span class="built_in">HasValidFeatureLevel</span>());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// VertexFactory needs to be able to support max possible shader platform and feature level</span></span><br><span class="line">   <span class="comment">// in case if we switch feature level at runtime.</span></span><br><span class="line">   <span class="type">const</span> <span class="type">bool</span> bCanUseGPUScene = <span class="built_in">UseGPUScene</span>(GMaxRHIShaderPlatform, GMaxRHIFeatureLevel);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If the vertex buffer containing position is not the same vertex buffer containing the rest of the data,</span></span><br><span class="line">   <span class="comment">// then initialize PositionStream and PositionDeclaration.</span></span><br><span class="line">   <span class="keyword">if</span> (Data.PositionComponent.VertexBuffer != Data.TangentBasisComponents[<span class="number">0</span>].VertexBuffer)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">auto</span> AddDeclaration = [<span class="keyword">this</span>, bCanUseGPUScene](EVertexInputStreamType InputStreamType, <span class="type">bool</span> bAddNormal)</span><br><span class="line">      &#123;</span><br><span class="line">         FVertexDeclarationElementList StreamElements;</span><br><span class="line">         <span class="comment">//这里把Data的数据转换成FVertexElement的形式，保存起来，其中保存了顶点的bindingindex,attributeindex，stride，offset这些数据</span></span><br><span class="line">         <span class="comment">//BindingIndex是C++侧的顶点数据的下标，attributeIndex是Shader侧的顶点属性的索引</span></span><br><span class="line">         <span class="comment">//用意就是告诉Shader 第几个数据流是什么属性</span></span><br><span class="line">         StreamElements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(Data.PositionComponent, <span class="number">0</span>, InputStreamType));</span><br><span class="line"></span><br><span class="line">         bAddNormal = bAddNormal &amp;&amp; Data.TangentBasisComponents[<span class="number">1</span>].VertexBuffer != <span class="literal">NULL</span>;</span><br><span class="line">         <span class="keyword">if</span> (bAddNormal)</span><br><span class="line">         &#123;</span><br><span class="line">            StreamElements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(Data.TangentBasisComponents[<span class="number">1</span>], <span class="number">2</span>, InputStreamType));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="type">const</span> uint8 TypeIndex = <span class="built_in">static_cast</span>&lt;uint8&gt;(InputStreamType);</span><br><span class="line">         PrimitiveIdStreamIndex[TypeIndex] = <span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">GetType</span>()-&gt;<span class="built_in">SupportsPrimitiveIdStream</span>() &amp;&amp; bCanUseGPUScene)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">// When the VF is used for rendering in normal mesh passes, this vertex buffer and offset will be overridden</span></span><br><span class="line">            StreamElements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(<span class="built_in">FVertexStreamComponent</span>(&amp;GPrimitiveIdDummy, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(uint32), VET_UInt, EVertexStreamUsage::Instancing), <span class="number">1</span>, InputStreamType));</span><br><span class="line">            PrimitiveIdStreamIndex[TypeIndex] = StreamElements.<span class="built_in">Last</span>().StreamIndex;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">InitDeclaration</span>(StreamElements, InputStreamType);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">AddDeclaration</span>(EVertexInputStreamType::PositionOnly, <span class="literal">false</span>);</span><br><span class="line">      <span class="built_in">AddDeclaration</span>(EVertexInputStreamType::PositionAndNormalOnly, <span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   FVertexDeclarationElementList Elements;</span><br><span class="line">   <span class="keyword">if</span>(Data.PositionComponent.VertexBuffer != <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      Elements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(Data.PositionComponent,<span class="number">0</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">const</span> uint8 Index = <span class="built_in">static_cast</span>&lt;uint8&gt;(EVertexInputStreamType::Default);</span><br><span class="line">      PrimitiveIdStreamIndex[Index] = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">GetType</span>()-&gt;<span class="built_in">SupportsPrimitiveIdStream</span>() &amp;&amp; bCanUseGPUScene)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">// When the VF is used for rendering in normal mesh passes, this vertex buffer and offset will be overridden</span></span><br><span class="line">         Elements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(<span class="built_in">FVertexStreamComponent</span>(&amp;GPrimitiveIdDummy, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(uint32), VET_UInt, EVertexStreamUsage::Instancing), <span class="number">13</span>));</span><br><span class="line">         PrimitiveIdStreamIndex[Index] = Elements.<span class="built_in">Last</span>().StreamIndex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...... </span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">check</span>(Streams.<span class="built_in">Num</span>() &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">InitDeclaration</span>(Elements);</span><br><span class="line">   <span class="built_in">check</span>(<span class="built_in">IsValidRef</span>(<span class="built_in">GetDeclaration</span>()));</span><br><span class="line"></span><br><span class="line">   <span class="type">const</span> int32 DefaultBaseVertexIndex = <span class="number">0</span>;</span><br><span class="line">   <span class="type">const</span> int32 DefaultPreSkinBaseVertexIndex = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">RHISupportsManualVertexFetch</span>(GMaxRHIShaderPlatform) || bCanUseGPUScene)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">SCOPED_LOADTIMER</span>(FLocalVertexFactory_InitRHI_CreateLocalVFUniformBuffer);</span><br><span class="line">      UniformBuffer = <span class="built_in">CreateLocalVFUniformBuffer</span>(<span class="keyword">this</span>, Data.LODLightmapDataIndex, <span class="literal">nullptr</span>, DefaultBaseVertexIndex, DefaultPreSkinBaseVertexIndex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">check</span>(<span class="built_in">IsValidRef</span>(<span class="built_in">GetDeclaration</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InitRHI主要是用来做顶点声明RHI申请的，顶点缓冲的RHI资源已经在FStaticMeshVertexFactories::InitVertexFactory接口中从StaticMesh中的LOD数据绑定到的VF对应的Component的Buffer下，在InitRHI中调用了InitDeclaration：最终申请了一个Vertex的RHI资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FVertexFactory::InitDeclaration</span><span class="params">(<span class="type">const</span> FVertexDeclarationElementList&amp; Elements, EVertexInputStreamType StreamType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (StreamType == EVertexInputStreamType::PositionOnly)</span><br><span class="line">        &#123;</span><br><span class="line">                PositionDeclaration = PipelineStateCache::<span class="built_in">GetOrCreateVertexDeclaration</span>(Elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (StreamType == EVertexInputStreamType::PositionAndNormalOnly)</span><br><span class="line">        &#123;</span><br><span class="line">                PositionAndNormalDeclaration = PipelineStateCache::<span class="built_in">GetOrCreateVertexDeclaration</span>(Elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// (StreamType == EVertexInputStreamType::Default)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Create the vertex declaration for rendering the factory normally.</span></span><br><span class="line">                Declaration = PipelineStateCache::<span class="built_in">GetOrCreateVertexDeclaration</span>(Elements);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FRHIVertexDeclaration*        <span class="title">PipelineStateCache::GetOrCreateVertexDeclaration</span><span class="params">(<span class="type">const</span> FVertexDeclarationElementList&amp; Elements)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// Actual locking/contention time should be close to unmeasurable</span></span><br><span class="line">        <span class="function">FScopeLock <span class="title">ScopeLock</span><span class="params">(&amp;GVertexDeclarationLock)</span></span>;</span><br><span class="line">        uint32 Key = FCrc::<span class="built_in">MemCrc_DEPRECATED</span>(Elements.<span class="built_in">GetData</span>(), Elements.<span class="built_in">Num</span>() * <span class="built_in">sizeof</span>(FVertexElement));</span><br><span class="line">        FRHIVertexDeclaration** Found = GVertexDeclarationCache.<span class="built_in">Find</span>(Key);</span><br><span class="line">        <span class="keyword">if</span> (Found)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> *Found;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FVertexDeclarationRHIRef NewDeclaration = <span class="built_in">RHICreateVertexDeclaration</span>(Elements);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Add an extra reference so we don&#x27;t have TRefCountPtr in the maps</span></span><br><span class="line">        NewDeclaration-&gt;<span class="built_in">AddRef</span>();</span><br><span class="line">        GVertexDeclarationCache.<span class="built_in">Add</span>(Key, NewDeclaration);</span><br><span class="line">        <span class="keyword">return</span> NewDeclaration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-在StaticMesh和shader中兼容"><a href="#2-在StaticMesh和shader中兼容" class="headerlink" title="2.在StaticMesh和shader中兼容"></a>2.在StaticMesh和shader中兼容</h2><p>到这里VF的数据就被填充好了，什么时候会在渲染时被用到呢，首先捋一下VF被引用的链路：VF是被Mesh-&gt;RenderData-&gt;LODVertexFactories 引用的，所以在生成meshbatch的时候会把VF一起传参，那么看下MeshBatch的生成函数：FStaticMeshSceneProxy::GetMeshElement</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FStaticMeshSceneProxy::GetMeshElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        int32 LODIndex, </span></span></span><br><span class="line"><span class="params"><span class="function">        int32 BatchIndex, </span></span></span><br><span class="line"><span class="params"><span class="function">        int32 SectionIndex, </span></span></span><br><span class="line"><span class="params"><span class="function">        uint8 InDepthPriorityGroup, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> bUseSelectionOutline,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> bAllowPreCulledIndices, </span></span></span><br><span class="line"><span class="params"><span class="function">        FMeshBatch&amp; OutMeshBatch)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="comment">//.....</span></span><br><span class="line">        <span class="type">const</span> FVertexFactory* VertexFactory = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// Has the mesh component overridden the vertex color stream for this mesh LOD?</span></span><br><span class="line">        <span class="keyword">if</span> (ProxyLODInfo.OverrideColorVertexBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Make sure the indices are accessing data within the vertex buffer&#x27;s</span></span><br><span class="line">                <span class="built_in">check</span>(Section.MaxVertexIndex &lt; ProxyLODInfo.OverrideColorVertexBuffer-&gt;<span class="built_in">GetNumVertices</span>())</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Use the instanced colors vertex factory.</span></span><br><span class="line">                VertexFactory = &amp;VFs.VertexFactoryOverrideColorVertexBuffer;</span><br><span class="line"></span><br><span class="line">                OutMeshBatchElement.VertexFactoryUserData = ProxyLODInfo.OverrideColorVFUniformBuffer.<span class="built_in">GetReference</span>();</span><br><span class="line">                OutMeshBatchElement.UserData = ProxyLODInfo.OverrideColorVertexBuffer;</span><br><span class="line">                OutMeshBatchElement.bUserDataIsColorVertexBuffer = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                VertexFactory = &amp;VFs.VertexFactory;</span><br><span class="line"></span><br><span class="line">                OutMeshBatchElement.VertexFactoryUserData = VFs.VertexFactory.<span class="built_in">GetUniformBuffer</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> bWireframe = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Disable adjacency information when the selection outline is enabled, since tessellation won&#x27;t be used.</span></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> bRequiresAdjacencyInformation = !bUseSelectionOutline &amp;&amp; <span class="built_in">RequiresAdjacencyInformation</span>(MaterialInterface, VertexFactory-&gt;<span class="built_in">GetType</span>(), FeatureLevel);</span><br><span class="line">        <span class="comment">//最终在SetMeshElementGeometrySource 把VF赋值给了MeshBatch</span></span><br><span class="line">        <span class="type">const</span> uint32 NumPrimitives = <span class="built_in">SetMeshElementGeometrySource</span>(LODIndex, SectionIndex, bWireframe, bRequiresAdjacencyInformation, bUseReversedIndices, bAllowPreCulledIndices, VertexFactory, OutMeshBatch);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BuildMeshDrawCommands中把VF的声明赋值给了BoundShaderState</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> PassShadersType, <span class="keyword">typename</span> ShaderElementDataType&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FMeshPassProcessor::BuildMeshDrawCommands</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FMeshBatch&amp; RESTRICT MeshBatch,</span></span></span><br><span class="line"><span class="params"><span class="function">    uint64 BatchElementMask,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FMaterialRenderProxy&amp; RESTRICT MaterialRenderProxy,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FMaterial&amp; RESTRICT MaterialResource,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FMeshPassProcessorRenderState&amp; RESTRICT DrawRenderState,</span></span></span><br><span class="line"><span class="params"><span class="function">    PassShadersType PassShaders,</span></span></span><br><span class="line"><span class="params"><span class="function">    ERasterizerFillMode MeshFillMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    ERasterizerCullMode MeshCullMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    FMeshDrawCommandSortKey SortKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    EMeshPassFeatures MeshPassFeatures,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ShaderElementDataType&amp; ShaderElementData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FVertexFactory* RESTRICT VertexFactory = MeshBatch.VertexFactory;</span><br><span class="line">    <span class="type">const</span> FPrimitiveSceneInfo* RESTRICT PrimitiveSceneInfo = PrimitiveSceneProxy ? PrimitiveSceneProxy-&gt;<span class="built_in">GetPrimitiveSceneInfo</span>() : <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    FMeshDrawCommand SharedMeshDrawCommand;</span><br><span class="line"></span><br><span class="line">    SharedMeshDrawCommand.<span class="built_in">SetStencilRef</span>(DrawRenderState.<span class="built_in">GetStencilRef</span>());</span><br><span class="line"></span><br><span class="line">    FGraphicsMinimalPipelineStateInitializer PipelineState;</span><br><span class="line">    PipelineState.PrimitiveType = (EPrimitiveType)MeshBatch.Type;</span><br><span class="line">    PipelineState.ImmutableSamplerState = MaterialRenderProxy.ImmutableSamplerState;</span><br><span class="line"></span><br><span class="line">    EVertexInputStreamType InputStreamType = EVertexInputStreamType::Default;</span><br><span class="line">    <span class="keyword">if</span> ((MeshPassFeatures &amp; EMeshPassFeatures::PositionOnly) != EMeshPassFeatures::Default)             InputStreamType = EVertexInputStreamType::PositionOnly;</span><br><span class="line">    <span class="keyword">if</span> ((MeshPassFeatures &amp; EMeshPassFeatures::PositionAndNormalOnly) != EMeshPassFeatures::Default)   InputStreamType = EVertexInputStreamType::PositionAndNormalOnly;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check</span>(VertexFactory &amp;&amp; VertexFactory-&gt;<span class="built_in">IsInitialized</span>());</span><br><span class="line">    FRHIVertexDeclaration* VertexDeclaration = VertexFactory-&gt;<span class="built_in">GetDeclaration</span>(InputStreamType);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check</span>(!VertexFactory-&gt;<span class="built_in">NeedsDeclaration</span>() || VertexDeclaration);</span><br><span class="line">    <span class="comment">//赋值操作</span></span><br><span class="line">    SharedMeshDrawCommand.<span class="built_in">SetShaders</span>(VertexDeclaration, PassShaders.<span class="built_in">GetUntypedShaders</span>(), PipelineState);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在FMeshDrawCommand::SubmitDraw会重新获得MeshDrawCommands的BoundShaderState</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (MeshDrawCommand.CachedPipelineId.GetId() != StateCache.PipelineId)</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    FGraphicsPipelineStateInitializer GraphicsPSOInit = MeshPipelineState.AsGraphicsPipelineStateInitializer();</span><br><span class="line">    RHICmdList.ApplyCachedRenderTargets(GraphicsPSOInit);</span><br><span class="line">    SetGraphicsPipelineState(RHICmdList<span class="punctuation">,</span> GraphicsPSOInit);</span><br><span class="line">    StateCache.SetPipelineState(MeshDrawCommand.CachedPipelineId.GetId());</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在SetGraphicsPipelineState中会把BoundShaderState转换成对应平台RHI的子类，以OpenGL举例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">virtual void RHISetGraphicsPipelineState(FRHIGraphicsPipelineState* GraphicsState<span class="punctuation">,</span> bool bApplyAdditionalState) final override</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    FRHIGraphicsPipelineStateFallBack* FallbackGraphicsState = static_cast&lt;FRHIGraphicsPipelineStateFallBack*&gt;(GraphicsState);</span><br><span class="line"></span><br><span class="line">    auto&amp; PsoInit = FallbackGraphicsState-&gt;Initializer;</span><br><span class="line"></span><br><span class="line">    RHISetBoundShaderState(</span><br><span class="line">       RHICreateBoundShaderState_internal(</span><br><span class="line">          PsoInit.BoundShaderState.VertexDeclarationRHI<span class="punctuation">,</span></span><br><span class="line">          PsoInit.BoundShaderState.VertexShaderRHI<span class="punctuation">,</span></span><br><span class="line">          TESSELLATION_SHADER(PsoInit.BoundShaderState.HullShaderRHI)<span class="punctuation">,</span></span><br><span class="line">          TESSELLATION_SHADER(PsoInit.BoundShaderState.DomainShaderRHI)<span class="punctuation">,</span></span><br><span class="line">          PsoInit.BoundShaderState.PixelShaderRHI<span class="punctuation">,</span></span><br><span class="line">          GEOMETRY_SHADER(PsoInit.BoundShaderState.GeometryShaderRHI)<span class="punctuation">,</span></span><br><span class="line">          PsoInit.bFromPSOFileCache</span><br><span class="line">       ).GetReference()</span><br><span class="line">    );</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FOpenGLDynamicRHI::RHIDrawPrimitive</span><span class="params">(uint32 BaseVertexIndex,uint32 NumPrimitives,uint32 NumInstances)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">SCOPE_CYCLE_COUNTER_DETAILED</span>(STAT_OpenGLDrawPrimitiveTime);</span><br><span class="line">    <span class="built_in">VERIFY_GL_SCOPE</span>();</span><br><span class="line">    <span class="built_in">RHI_DRAW_CALL_STATS</span>(PrimitiveType,NumPrimitives*NumInstances);</span><br><span class="line"></span><br><span class="line">    FOpenGLContextState&amp; ContextState = <span class="built_in">GetContextStateForCurrentContext</span>();</span><br><span class="line">    <span class="built_in">BindPendingFramebuffer</span>(ContextState);</span><br><span class="line">    <span class="built_in">SetPendingBlendStateForActiveRenderTargets</span>(ContextState);</span><br><span class="line">    <span class="built_in">UpdateViewportInOpenGLContext</span>(ContextState);</span><br><span class="line">    <span class="built_in">UpdateScissorRectInOpenGLContext</span>(ContextState);</span><br><span class="line">    <span class="built_in">UpdateRasterizerStateInOpenGLContext</span>(ContextState);</span><br><span class="line">    <span class="built_in">UpdateDepthStencilStateInOpenGLContext</span>(ContextState);</span><br><span class="line">    <span class="built_in">BindPendingShaderState</span>(ContextState);</span><br><span class="line">    <span class="built_in">CommitGraphicsResourceTables</span>();</span><br><span class="line">    <span class="built_in">SetupTexturesForDraw</span>(ContextState);</span><br><span class="line">    <span class="built_in">SetupUAVsForDraw</span>(ContextState);</span><br><span class="line">    <span class="built_in">CommitNonComputeShaderConstants</span>();</span><br><span class="line">    <span class="built_in">CachedBindElementArrayBuffer</span>(ContextState,<span class="number">0</span>);</span><br><span class="line">    uint32 VertexCount = <span class="built_in">GetVertexCountForPrimitiveCount</span>(NumPrimitives,PrimitiveType);</span><br><span class="line">    <span class="comment">//设置顶点数组</span></span><br><span class="line">    <span class="built_in">SetupVertexArrays</span>(ContextState, BaseVertexIndex, PendingState.Streams, NUM_OPENGL_VERTEX_STREAMS, VertexCount);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>UE 在最后提交渲染命令DrawIndexPrimitive时，会先设置管线状态，设置顶点数组，这里就会用到我们上面绑定的顶点声明，参见FOpenGLDynamicRHI::SetupVertexArrays()，在这里我们终于得见底层的API接口调用：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FOpenGLDynamicRHI::SetupVertexArrays</span></span><br><span class="line">if (bAnyDifferent)</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    if (!VertexElement.bShouldConvertToFloat)</span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       FOpenGL<span class="punctuation">:</span><span class="punctuation">:</span>VertexAttribIFormat(AttributeIndex<span class="punctuation">,</span> VertexElement.Size<span class="punctuation">,</span> VertexElement.Type<span class="punctuation">,</span> VertexElement.Offset);</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    else</span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       FOpenGL<span class="punctuation">:</span><span class="punctuation">:</span>VertexAttribFormat(AttributeIndex<span class="punctuation">,</span> VertexElement.Size<span class="punctuation">,</span> VertexElement.Type<span class="punctuation">,</span> VertexElement.bNormalized<span class="punctuation">,</span> VertexElement.Offset);</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    Attr.StreamOffset = VertexElement.Offset;</span><br><span class="line">    Attr.Size = VertexElement.Size;</span><br><span class="line">    Attr.Type = VertexElement.Type;</span><br><span class="line">    Attr.bNormalized = VertexElement.bNormalized;</span><br><span class="line">    Attr.bShouldConvertToFloat = VertexElement.bShouldConvertToFloat;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">if (Attr.StreamIndex != StreamIndex)</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    FOpenGL<span class="punctuation">:</span><span class="punctuation">:</span>VertexAttribBinding(AttributeIndex<span class="punctuation">,</span> VertexElement.StreamIndex);</span><br><span class="line">    Attr.StreamIndex = StreamIndex;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这里用到了两个API接口VertexAttribIFormat和VertexAttribBinding 设置顶点属性和偏移等数据。</p><p>VertexAttribIFormat 用来设置顶点属性，告诉API如何读取数据。</p><p>VertexAttribBinding 用来设置哪个属性在哪个缓冲区对象中，这里不同的缓冲区对象对应不同的streamIndex</p><p>回过头来看顶点工厂在顶点声明的时候，其中数据所处的Streams数组中的Index决定了当前属性的缓冲区索引</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FVertexElement FVertexFactory<span class="punctuation">:</span><span class="punctuation">:</span>AccessStreamComponent(const FVertexStreamComponent&amp; Component<span class="punctuation">,</span> uint8 AttributeIndex)</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    FVertexStream VertexStream;</span><br><span class="line">    VertexStream.VertexBuffer = Component.VertexBuffer;</span><br><span class="line">    VertexStream.Stride = Component.Stride;</span><br><span class="line">    VertexStream.Offset = Component.StreamOffset;</span><br><span class="line">    VertexStream.VertexStreamUsage = Component.VertexStreamUsage;</span><br><span class="line"></span><br><span class="line">    return FVertexElement(Streams.AddUnique(VertexStream)<span class="punctuation">,</span>Component.Offset<span class="punctuation">,</span>Component.Type<span class="punctuation">,</span>AttributeIndex<span class="punctuation">,</span>VertexStream.Stride<span class="punctuation">,</span> EnumHasAnyFlags(EVertexStreamUsage<span class="punctuation">:</span><span class="punctuation">:</span>Instancing<span class="punctuation">,</span> VertexStream.VertexStreamUsage));</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>至于顶点缓冲的绑定也同样是在SetUpVertexArray中，调用了BindVertexBuffer</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">for (uint32 StreamIndex = <span class="number">0</span>; StreamIndex &lt; NumStreams &amp;&amp; StreamMask; StreamIndex++)</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    if (StreamMask &amp; <span class="number">0x1</span>)</span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       FOpenGLStream &amp;CachedStream = ContextState.VertexStreams<span class="punctuation">[</span>StreamIndex<span class="punctuation">]</span>;</span><br><span class="line">       FOpenGLStream &amp;Stream = Streams<span class="punctuation">[</span>StreamIndex<span class="punctuation">]</span>;</span><br><span class="line">       if (Stream.VertexBuffer)</span><br><span class="line">       <span class="punctuation">&#123;</span></span><br><span class="line">          uint32 Offset = BaseVertexIndex * Stream.Stride + Stream.Offset;</span><br><span class="line">          bool bAnyDifferent = <span class="comment">//bitwise ors to get rid of the branches</span></span><br><span class="line">             (CachedStream.VertexBuffer != Stream.VertexBuffer) |</span><br><span class="line">             (CachedStream.Stride != Stream.Stride)|</span><br><span class="line">             (CachedStream.Offset != Offset);</span><br><span class="line"></span><br><span class="line">          if (bAnyDifferent)</span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">             check(Stream.VertexBuffer-&gt;Resource != <span class="number">0</span>);</span><br><span class="line">             FOpenGL<span class="punctuation">:</span><span class="punctuation">:</span>BindVertexBuffer(StreamIndex<span class="punctuation">,</span> Stream.VertexBuffer-&gt;Resource<span class="punctuation">,</span> Offset<span class="punctuation">,</span> Stream.Stride);</span><br><span class="line">             CachedStream.VertexBuffer = Stream.VertexBuffer;</span><br><span class="line">             CachedStream.Offset = Offset;</span><br><span class="line">             CachedStream.Stride = Stream.Stride;</span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">          if (UpdateDivisors &amp;&amp; CachedStream.Divisor != Divisor<span class="punctuation">[</span>StreamIndex<span class="punctuation">]</span>)</span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">             FOpenGL<span class="punctuation">:</span><span class="punctuation">:</span>VertexBindingDivisor(StreamIndex<span class="punctuation">,</span> Divisor<span class="punctuation">[</span>StreamIndex<span class="punctuation">]</span>);</span><br><span class="line">             CachedStream.Divisor = Divisor<span class="punctuation">[</span>StreamIndex<span class="punctuation">]</span>;</span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">       else</span><br><span class="line">       <span class="punctuation">&#123;</span></span><br><span class="line">          UE_LOG(LogRHI<span class="punctuation">,</span> Error<span class="punctuation">,</span> TEXT(<span class="string">&quot;Stream %d marked as in use, but vertex buffer provided is NULL (Mask = %x)&quot;</span>)<span class="punctuation">,</span> StreamIndex<span class="punctuation">,</span> StreamMask);</span><br><span class="line">          </span><br><span class="line">          FOpenGL<span class="punctuation">:</span><span class="punctuation">:</span>BindVertexBuffer(StreamIndex<span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span>);</span><br><span class="line">          CachedStream.VertexBuffer = nullptr;</span><br><span class="line">          CachedStream.Offset = <span class="number">0</span>;</span><br><span class="line">          CachedStream.Stride = <span class="number">0</span>;</span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    StreamMask &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>最后附上VF和shader中变量生效的调用栈：</p><p>VF的ModifyCompilationEnvironment</p><p><img src="/2023/11/05/VertexFactory/VF_modify.jpg" alt="VF_modify"></p><p>Shader的modifyCompilationEnvironment</p><p><img src="/2023/11/05/VertexFactory/Shader_modify.jpg" alt="Shader_modify"></p>]]></content>
      
      
      
        <tags>
            
            <tag> UE源码 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
